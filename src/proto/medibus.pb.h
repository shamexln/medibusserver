// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: medibus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_medibus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_medibus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_medibus_2eproto;
namespace medibus {
class DelimitedLoopRequest;
struct DelimitedLoopRequestDefaultTypeInternal;
extern DelimitedLoopRequestDefaultTypeInternal _DelimitedLoopRequest_default_instance_;
class DeviceIdentificationRequest;
struct DeviceIdentificationRequestDefaultTypeInternal;
extern DeviceIdentificationRequestDefaultTypeInternal _DeviceIdentificationRequest_default_instance_;
class DeviceIdentificationRequest_DeviceRespond;
struct DeviceIdentificationRequest_DeviceRespondDefaultTypeInternal;
extern DeviceIdentificationRequest_DeviceRespondDefaultTypeInternal _DeviceIdentificationRequest_DeviceRespond_default_instance_;
class LoopRequest;
struct LoopRequestDefaultTypeInternal;
extern LoopRequestDefaultTypeInternal _LoopRequest_default_instance_;
class MedibusRealTimeRequest;
struct MedibusRealTimeRequestDefaultTypeInternal;
extern MedibusRealTimeRequestDefaultTypeInternal _MedibusRealTimeRequest_default_instance_;
class MedibusRealTimeRequest_DeviceRespond;
struct MedibusRealTimeRequest_DeviceRespondDefaultTypeInternal;
extern MedibusRealTimeRequest_DeviceRespondDefaultTypeInternal _MedibusRealTimeRequest_DeviceRespond_default_instance_;
class MedibusReply;
struct MedibusReplyDefaultTypeInternal;
extern MedibusReplyDefaultTypeInternal _MedibusReply_default_instance_;
class MedibusRequest;
struct MedibusRequestDefaultTypeInternal;
extern MedibusRequestDefaultTypeInternal _MedibusRequest_default_instance_;
class MedibusRequest_DeviceRespond;
struct MedibusRequest_DeviceRespondDefaultTypeInternal;
extern MedibusRequest_DeviceRespondDefaultTypeInternal _MedibusRequest_DeviceRespond_default_instance_;
}  // namespace medibus
PROTOBUF_NAMESPACE_OPEN
template<> ::medibus::DelimitedLoopRequest* Arena::CreateMaybeMessage<::medibus::DelimitedLoopRequest>(Arena*);
template<> ::medibus::DeviceIdentificationRequest* Arena::CreateMaybeMessage<::medibus::DeviceIdentificationRequest>(Arena*);
template<> ::medibus::DeviceIdentificationRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::DeviceIdentificationRequest_DeviceRespond>(Arena*);
template<> ::medibus::LoopRequest* Arena::CreateMaybeMessage<::medibus::LoopRequest>(Arena*);
template<> ::medibus::MedibusRealTimeRequest* Arena::CreateMaybeMessage<::medibus::MedibusRealTimeRequest>(Arena*);
template<> ::medibus::MedibusRealTimeRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::MedibusRealTimeRequest_DeviceRespond>(Arena*);
template<> ::medibus::MedibusReply* Arena::CreateMaybeMessage<::medibus::MedibusReply>(Arena*);
template<> ::medibus::MedibusRequest* Arena::CreateMaybeMessage<::medibus::MedibusRequest>(Arena*);
template<> ::medibus::MedibusRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::MedibusRequest_DeviceRespond>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace medibus {

// ===================================================================

class DeviceIdentificationRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.DeviceIdentificationRequest.DeviceRespond) */ {
 public:
  inline DeviceIdentificationRequest_DeviceRespond() : DeviceIdentificationRequest_DeviceRespond(nullptr) {}
  ~DeviceIdentificationRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR DeviceIdentificationRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceIdentificationRequest_DeviceRespond(const DeviceIdentificationRequest_DeviceRespond& from);
  DeviceIdentificationRequest_DeviceRespond(DeviceIdentificationRequest_DeviceRespond&& from) noexcept
    : DeviceIdentificationRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline DeviceIdentificationRequest_DeviceRespond& operator=(const DeviceIdentificationRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceIdentificationRequest_DeviceRespond& operator=(DeviceIdentificationRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceIdentificationRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceIdentificationRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const DeviceIdentificationRequest_DeviceRespond*>(
               &_DeviceIdentificationRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceIdentificationRequest_DeviceRespond& a, DeviceIdentificationRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceIdentificationRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceIdentificationRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceIdentificationRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceIdentificationRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceIdentificationRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceIdentificationRequest_DeviceRespond& from) {
    DeviceIdentificationRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceIdentificationRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.DeviceIdentificationRequest.DeviceRespond";
  }
  protected:
  explicit DeviceIdentificationRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceidFieldNumber = 1,
    kDevicenameFieldNumber = 2,
    kFacilityFieldNumber = 3,
    kPocFieldNumber = 4,
    kBedFieldNumber = 5,
    kRoomFieldNumber = 6,
    kBuildingFieldNumber = 7,
    kFloorFieldNumber = 8,
  };
  // optional string deviceid = 1;
  bool has_deviceid() const;
  private:
  bool _internal_has_deviceid() const;
  public:
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // optional string devicename = 2;
  bool has_devicename() const;
  private:
  bool _internal_has_devicename() const;
  public:
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_NODISCARD std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // optional string facility = 3;
  bool has_facility() const;
  private:
  bool _internal_has_facility() const;
  public:
  void clear_facility();
  const std::string& facility() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_facility(ArgT0&& arg0, ArgT... args);
  std::string* mutable_facility();
  PROTOBUF_NODISCARD std::string* release_facility();
  void set_allocated_facility(std::string* facility);
  private:
  const std::string& _internal_facility() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_facility(const std::string& value);
  std::string* _internal_mutable_facility();
  public:

  // optional string poc = 4;
  bool has_poc() const;
  private:
  bool _internal_has_poc() const;
  public:
  void clear_poc();
  const std::string& poc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poc();
  PROTOBUF_NODISCARD std::string* release_poc();
  void set_allocated_poc(std::string* poc);
  private:
  const std::string& _internal_poc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poc(const std::string& value);
  std::string* _internal_mutable_poc();
  public:

  // optional string bed = 5;
  bool has_bed() const;
  private:
  bool _internal_has_bed() const;
  public:
  void clear_bed();
  const std::string& bed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bed();
  PROTOBUF_NODISCARD std::string* release_bed();
  void set_allocated_bed(std::string* bed);
  private:
  const std::string& _internal_bed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bed(const std::string& value);
  std::string* _internal_mutable_bed();
  public:

  // optional string room = 6;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // optional string building = 7;
  bool has_building() const;
  private:
  bool _internal_has_building() const;
  public:
  void clear_building();
  const std::string& building() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_building(ArgT0&& arg0, ArgT... args);
  std::string* mutable_building();
  PROTOBUF_NODISCARD std::string* release_building();
  void set_allocated_building(std::string* building);
  private:
  const std::string& _internal_building() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_building(const std::string& value);
  std::string* _internal_mutable_building();
  public:

  // optional string floor = 8;
  bool has_floor() const;
  private:
  bool _internal_has_floor() const;
  public:
  void clear_floor();
  const std::string& floor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_floor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_floor();
  PROTOBUF_NODISCARD std::string* release_floor();
  void set_allocated_floor(std::string* floor);
  private:
  const std::string& _internal_floor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_floor(const std::string& value);
  std::string* _internal_mutable_floor();
  public:

  // @@protoc_insertion_point(class_scope:medibus.DeviceIdentificationRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr facility_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bed_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr building_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr floor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class DeviceIdentificationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.DeviceIdentificationRequest) */ {
 public:
  inline DeviceIdentificationRequest() : DeviceIdentificationRequest(nullptr) {}
  ~DeviceIdentificationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceIdentificationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceIdentificationRequest(const DeviceIdentificationRequest& from);
  DeviceIdentificationRequest(DeviceIdentificationRequest&& from) noexcept
    : DeviceIdentificationRequest() {
    *this = ::std::move(from);
  }

  inline DeviceIdentificationRequest& operator=(const DeviceIdentificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceIdentificationRequest& operator=(DeviceIdentificationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceIdentificationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceIdentificationRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceIdentificationRequest*>(
               &_DeviceIdentificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceIdentificationRequest& a, DeviceIdentificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceIdentificationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceIdentificationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceIdentificationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceIdentificationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceIdentificationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceIdentificationRequest& from) {
    DeviceIdentificationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceIdentificationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.DeviceIdentificationRequest";
  }
  protected:
  explicit DeviceIdentificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeviceIdentificationRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 1,
    kDevicerespondsFieldNumber = 3,
    kSequenceIdFieldNumber = 2,
  };
  // optional string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // optional .medibus.DeviceIdentificationRequest.DeviceRespond deviceresponds = 3;
  bool has_deviceresponds() const;
  private:
  bool _internal_has_deviceresponds() const;
  public:
  void clear_deviceresponds();
  const ::medibus::DeviceIdentificationRequest_DeviceRespond& deviceresponds() const;
  PROTOBUF_NODISCARD ::medibus::DeviceIdentificationRequest_DeviceRespond* release_deviceresponds();
  ::medibus::DeviceIdentificationRequest_DeviceRespond* mutable_deviceresponds();
  void set_allocated_deviceresponds(::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds);
  private:
  const ::medibus::DeviceIdentificationRequest_DeviceRespond& _internal_deviceresponds() const;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* _internal_mutable_deviceresponds();
  public:
  void unsafe_arena_set_allocated_deviceresponds(
      ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds);
  ::medibus::DeviceIdentificationRequest_DeviceRespond* unsafe_arena_release_deviceresponds();

  // optional fixed64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  uint64_t sequence_id() const;
  void set_sequence_id(uint64_t value);
  private:
  uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:medibus.DeviceIdentificationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds_;
    uint64_t sequence_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRequest.DeviceRespond) */ {
 public:
  inline MedibusRequest_DeviceRespond() : MedibusRequest_DeviceRespond(nullptr) {}
  ~MedibusRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR MedibusRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRequest_DeviceRespond(const MedibusRequest_DeviceRespond& from);
  MedibusRequest_DeviceRespond(MedibusRequest_DeviceRespond&& from) noexcept
    : MedibusRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline MedibusRequest_DeviceRespond& operator=(const MedibusRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRequest_DeviceRespond& operator=(MedibusRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const MedibusRequest_DeviceRespond*>(
               &_MedibusRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MedibusRequest_DeviceRespond& a, MedibusRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRequest_DeviceRespond& from) {
    MedibusRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRequest.DeviceRespond";
  }
  protected:
  explicit MedibusRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kValueFieldNumber = 2,
    kUnitFieldNumber = 3,
    kDescriptionFieldNumber = 4,
  };
  // optional string code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string unit = 3;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRequest) */ {
 public:
  inline MedibusRequest() : MedibusRequest(nullptr) {}
  ~MedibusRequest() override;
  explicit PROTOBUF_CONSTEXPR MedibusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRequest(const MedibusRequest& from);
  MedibusRequest(MedibusRequest&& from) noexcept
    : MedibusRequest() {
    *this = ::std::move(from);
  }

  inline MedibusRequest& operator=(const MedibusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRequest& operator=(MedibusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRequest* internal_default_instance() {
    return reinterpret_cast<const MedibusRequest*>(
               &_MedibusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MedibusRequest& a, MedibusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRequest& from) {
    MedibusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRequest";
  }
  protected:
  explicit MedibusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MedibusRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kDevicerespondsFieldNumber = 3,
    kInstanceIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
  };
  // repeated .medibus.MedibusRequest.DeviceRespond deviceresponds = 3;
  int deviceresponds_size() const;
  private:
  int _internal_deviceresponds_size() const;
  public:
  void clear_deviceresponds();
  ::medibus::MedibusRequest_DeviceRespond* mutable_deviceresponds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >*
      mutable_deviceresponds();
  private:
  const ::medibus::MedibusRequest_DeviceRespond& _internal_deviceresponds(int index) const;
  ::medibus::MedibusRequest_DeviceRespond* _internal_add_deviceresponds();
  public:
  const ::medibus::MedibusRequest_DeviceRespond& deviceresponds(int index) const;
  ::medibus::MedibusRequest_DeviceRespond* add_deviceresponds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >&
      deviceresponds() const;

  // optional string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // optional fixed64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  uint64_t sequence_id() const;
  void set_sequence_id(uint64_t value);
  private:
  uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond > deviceresponds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    uint64_t sequence_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusReply) */ {
 public:
  inline MedibusReply() : MedibusReply(nullptr) {}
  ~MedibusReply() override;
  explicit PROTOBUF_CONSTEXPR MedibusReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusReply(const MedibusReply& from);
  MedibusReply(MedibusReply&& from) noexcept
    : MedibusReply() {
    *this = ::std::move(from);
  }

  inline MedibusReply& operator=(const MedibusReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusReply& operator=(MedibusReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusReply* internal_default_instance() {
    return reinterpret_cast<const MedibusReply*>(
               &_MedibusReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MedibusReply& a, MedibusReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusReply& from) {
    MedibusReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusReply";
  }
  protected:
  explicit MedibusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // optional string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRealTimeRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRealTimeRequest.DeviceRespond) */ {
 public:
  inline MedibusRealTimeRequest_DeviceRespond() : MedibusRealTimeRequest_DeviceRespond(nullptr) {}
  ~MedibusRealTimeRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR MedibusRealTimeRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRealTimeRequest_DeviceRespond(const MedibusRealTimeRequest_DeviceRespond& from);
  MedibusRealTimeRequest_DeviceRespond(MedibusRealTimeRequest_DeviceRespond&& from) noexcept
    : MedibusRealTimeRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline MedibusRealTimeRequest_DeviceRespond& operator=(const MedibusRealTimeRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRealTimeRequest_DeviceRespond& operator=(MedibusRealTimeRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRealTimeRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRealTimeRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const MedibusRealTimeRequest_DeviceRespond*>(
               &_MedibusRealTimeRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MedibusRealTimeRequest_DeviceRespond& a, MedibusRealTimeRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRealTimeRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRealTimeRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRealTimeRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRealTimeRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRealTimeRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRealTimeRequest_DeviceRespond& from) {
    MedibusRealTimeRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRealTimeRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRealTimeRequest.DeviceRespond";
  }
  protected:
  explicit MedibusRealTimeRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
    kMaxbinFieldNumber = 3,
    kIntervalFieldNumber = 4,
    kDescriptionFieldNumber = 5,
  };
  // optional string min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const std::string& min() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_min(ArgT0&& arg0, ArgT... args);
  std::string* mutable_min();
  PROTOBUF_NODISCARD std::string* release_min();
  void set_allocated_min(std::string* min);
  private:
  const std::string& _internal_min() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min(const std::string& value);
  std::string* _internal_mutable_min();
  public:

  // optional string max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const std::string& max() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max();
  PROTOBUF_NODISCARD std::string* release_max();
  void set_allocated_max(std::string* max);
  private:
  const std::string& _internal_max() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max(const std::string& value);
  std::string* _internal_mutable_max();
  public:

  // optional string maxbin = 3;
  bool has_maxbin() const;
  private:
  bool _internal_has_maxbin() const;
  public:
  void clear_maxbin();
  const std::string& maxbin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maxbin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maxbin();
  PROTOBUF_NODISCARD std::string* release_maxbin();
  void set_allocated_maxbin(std::string* maxbin);
  private:
  const std::string& _internal_maxbin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maxbin(const std::string& value);
  std::string* _internal_mutable_maxbin();
  public:

  // optional string interval = 4;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const std::string& interval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interval();
  PROTOBUF_NODISCARD std::string* release_interval();
  void set_allocated_interval(std::string* interval);
  private:
  const std::string& _internal_interval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interval(const std::string& value);
  std::string* _internal_mutable_interval();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRealTimeRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maxbin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interval_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRealTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRealTimeRequest) */ {
 public:
  inline MedibusRealTimeRequest() : MedibusRealTimeRequest(nullptr) {}
  ~MedibusRealTimeRequest() override;
  explicit PROTOBUF_CONSTEXPR MedibusRealTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRealTimeRequest(const MedibusRealTimeRequest& from);
  MedibusRealTimeRequest(MedibusRealTimeRequest&& from) noexcept
    : MedibusRealTimeRequest() {
    *this = ::std::move(from);
  }

  inline MedibusRealTimeRequest& operator=(const MedibusRealTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRealTimeRequest& operator=(MedibusRealTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRealTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRealTimeRequest* internal_default_instance() {
    return reinterpret_cast<const MedibusRealTimeRequest*>(
               &_MedibusRealTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MedibusRealTimeRequest& a, MedibusRealTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRealTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRealTimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRealTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRealTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRealTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRealTimeRequest& from) {
    MedibusRealTimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRealTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRealTimeRequest";
  }
  protected:
  explicit MedibusRealTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MedibusRealTimeRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kDevicerespondsFieldNumber = 3,
    kInstanceIdFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kSequenceIdFieldNumber = 2,
  };
  // repeated .medibus.MedibusRealTimeRequest.DeviceRespond deviceresponds = 3;
  int deviceresponds_size() const;
  private:
  int _internal_deviceresponds_size() const;
  public:
  void clear_deviceresponds();
  ::medibus::MedibusRealTimeRequest_DeviceRespond* mutable_deviceresponds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >*
      mutable_deviceresponds();
  private:
  const ::medibus::MedibusRealTimeRequest_DeviceRespond& _internal_deviceresponds(int index) const;
  ::medibus::MedibusRealTimeRequest_DeviceRespond* _internal_add_deviceresponds();
  public:
  const ::medibus::MedibusRealTimeRequest_DeviceRespond& deviceresponds(int index) const;
  ::medibus::MedibusRealTimeRequest_DeviceRespond* add_deviceresponds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >&
      deviceresponds() const;

  // optional string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional fixed64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  uint64_t sequence_id() const;
  void set_sequence_id(uint64_t value);
  private:
  uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRealTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond > deviceresponds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    uint64_t sequence_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class LoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.LoopRequest) */ {
 public:
  inline LoopRequest() : LoopRequest(nullptr) {}
  ~LoopRequest() override;
  explicit PROTOBUF_CONSTEXPR LoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoopRequest(const LoopRequest& from);
  LoopRequest(LoopRequest&& from) noexcept
    : LoopRequest() {
    *this = ::std::move(from);
  }

  inline LoopRequest& operator=(const LoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoopRequest& operator=(LoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoopRequest* internal_default_instance() {
    return reinterpret_cast<const LoopRequest*>(
               &_LoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoopRequest& a, LoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoopRequest& from) {
    LoopRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.LoopRequest";
  }
  protected:
  explicit LoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealTimeFieldNumber = 14,
    kInstanceIdFieldNumber = 1,
    kCurMeasuredDataCp1FieldNumber = 3,
    kCurLowAlarmLimitsCp1FieldNumber = 4,
    kCurHighAlarmLimitsCp1FieldNumber = 5,
    kCurAlarmsCp1FieldNumber = 6,
    kCurDeviceSettingsFieldNumber = 7,
    kTextMessagesFieldNumber = 8,
    kCurMeasuredDataCp2FieldNumber = 9,
    kCurLowAlarmLimitsCp2FieldNumber = 10,
    kCurHighAlarmLimitsCp2FieldNumber = 11,
    kCurAlarmsCp2FieldNumber = 12,
    kDeviceIdentificationFieldNumber = 13,
    kSequenceIdFieldNumber = 2,
  };
  // repeated .medibus.MedibusRealTimeRequest real_time = 14;
  int real_time_size() const;
  private:
  int _internal_real_time_size() const;
  public:
  void clear_real_time();
  ::medibus::MedibusRealTimeRequest* mutable_real_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >*
      mutable_real_time();
  private:
  const ::medibus::MedibusRealTimeRequest& _internal_real_time(int index) const;
  ::medibus::MedibusRealTimeRequest* _internal_add_real_time();
  public:
  const ::medibus::MedibusRealTimeRequest& real_time(int index) const;
  ::medibus::MedibusRealTimeRequest* add_real_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >&
      real_time() const;

  // optional string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // optional .medibus.MedibusRequest cur_measured_data_cp1 = 3;
  bool has_cur_measured_data_cp1() const;
  private:
  bool _internal_has_cur_measured_data_cp1() const;
  public:
  void clear_cur_measured_data_cp1();
  const ::medibus::MedibusRequest& cur_measured_data_cp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_measured_data_cp1();
  ::medibus::MedibusRequest* mutable_cur_measured_data_cp1();
  void set_allocated_cur_measured_data_cp1(::medibus::MedibusRequest* cur_measured_data_cp1);
  private:
  const ::medibus::MedibusRequest& _internal_cur_measured_data_cp1() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_measured_data_cp1();
  public:
  void unsafe_arena_set_allocated_cur_measured_data_cp1(
      ::medibus::MedibusRequest* cur_measured_data_cp1);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_measured_data_cp1();

  // optional .medibus.MedibusRequest cur_low_alarm_limits_cp1 = 4;
  bool has_cur_low_alarm_limits_cp1() const;
  private:
  bool _internal_has_cur_low_alarm_limits_cp1() const;
  public:
  void clear_cur_low_alarm_limits_cp1();
  const ::medibus::MedibusRequest& cur_low_alarm_limits_cp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_low_alarm_limits_cp1();
  ::medibus::MedibusRequest* mutable_cur_low_alarm_limits_cp1();
  void set_allocated_cur_low_alarm_limits_cp1(::medibus::MedibusRequest* cur_low_alarm_limits_cp1);
  private:
  const ::medibus::MedibusRequest& _internal_cur_low_alarm_limits_cp1() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_low_alarm_limits_cp1();
  public:
  void unsafe_arena_set_allocated_cur_low_alarm_limits_cp1(
      ::medibus::MedibusRequest* cur_low_alarm_limits_cp1);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_low_alarm_limits_cp1();

  // optional .medibus.MedibusRequest cur_high_alarm_limits_cp1 = 5;
  bool has_cur_high_alarm_limits_cp1() const;
  private:
  bool _internal_has_cur_high_alarm_limits_cp1() const;
  public:
  void clear_cur_high_alarm_limits_cp1();
  const ::medibus::MedibusRequest& cur_high_alarm_limits_cp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_high_alarm_limits_cp1();
  ::medibus::MedibusRequest* mutable_cur_high_alarm_limits_cp1();
  void set_allocated_cur_high_alarm_limits_cp1(::medibus::MedibusRequest* cur_high_alarm_limits_cp1);
  private:
  const ::medibus::MedibusRequest& _internal_cur_high_alarm_limits_cp1() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_high_alarm_limits_cp1();
  public:
  void unsafe_arena_set_allocated_cur_high_alarm_limits_cp1(
      ::medibus::MedibusRequest* cur_high_alarm_limits_cp1);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_high_alarm_limits_cp1();

  // optional .medibus.MedibusRequest cur_alarms_cp1 = 6;
  bool has_cur_alarms_cp1() const;
  private:
  bool _internal_has_cur_alarms_cp1() const;
  public:
  void clear_cur_alarms_cp1();
  const ::medibus::MedibusRequest& cur_alarms_cp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_alarms_cp1();
  ::medibus::MedibusRequest* mutable_cur_alarms_cp1();
  void set_allocated_cur_alarms_cp1(::medibus::MedibusRequest* cur_alarms_cp1);
  private:
  const ::medibus::MedibusRequest& _internal_cur_alarms_cp1() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_alarms_cp1();
  public:
  void unsafe_arena_set_allocated_cur_alarms_cp1(
      ::medibus::MedibusRequest* cur_alarms_cp1);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_alarms_cp1();

  // optional .medibus.MedibusRequest cur_device_settings = 7;
  bool has_cur_device_settings() const;
  private:
  bool _internal_has_cur_device_settings() const;
  public:
  void clear_cur_device_settings();
  const ::medibus::MedibusRequest& cur_device_settings() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_device_settings();
  ::medibus::MedibusRequest* mutable_cur_device_settings();
  void set_allocated_cur_device_settings(::medibus::MedibusRequest* cur_device_settings);
  private:
  const ::medibus::MedibusRequest& _internal_cur_device_settings() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_device_settings();
  public:
  void unsafe_arena_set_allocated_cur_device_settings(
      ::medibus::MedibusRequest* cur_device_settings);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_device_settings();

  // optional .medibus.MedibusRequest text_messages = 8;
  bool has_text_messages() const;
  private:
  bool _internal_has_text_messages() const;
  public:
  void clear_text_messages();
  const ::medibus::MedibusRequest& text_messages() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_text_messages();
  ::medibus::MedibusRequest* mutable_text_messages();
  void set_allocated_text_messages(::medibus::MedibusRequest* text_messages);
  private:
  const ::medibus::MedibusRequest& _internal_text_messages() const;
  ::medibus::MedibusRequest* _internal_mutable_text_messages();
  public:
  void unsafe_arena_set_allocated_text_messages(
      ::medibus::MedibusRequest* text_messages);
  ::medibus::MedibusRequest* unsafe_arena_release_text_messages();

  // optional .medibus.MedibusRequest cur_measured_data_cp2 = 9;
  bool has_cur_measured_data_cp2() const;
  private:
  bool _internal_has_cur_measured_data_cp2() const;
  public:
  void clear_cur_measured_data_cp2();
  const ::medibus::MedibusRequest& cur_measured_data_cp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_measured_data_cp2();
  ::medibus::MedibusRequest* mutable_cur_measured_data_cp2();
  void set_allocated_cur_measured_data_cp2(::medibus::MedibusRequest* cur_measured_data_cp2);
  private:
  const ::medibus::MedibusRequest& _internal_cur_measured_data_cp2() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_measured_data_cp2();
  public:
  void unsafe_arena_set_allocated_cur_measured_data_cp2(
      ::medibus::MedibusRequest* cur_measured_data_cp2);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_measured_data_cp2();

  // optional .medibus.MedibusRequest cur_low_alarm_limits_cp2 = 10;
  bool has_cur_low_alarm_limits_cp2() const;
  private:
  bool _internal_has_cur_low_alarm_limits_cp2() const;
  public:
  void clear_cur_low_alarm_limits_cp2();
  const ::medibus::MedibusRequest& cur_low_alarm_limits_cp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_low_alarm_limits_cp2();
  ::medibus::MedibusRequest* mutable_cur_low_alarm_limits_cp2();
  void set_allocated_cur_low_alarm_limits_cp2(::medibus::MedibusRequest* cur_low_alarm_limits_cp2);
  private:
  const ::medibus::MedibusRequest& _internal_cur_low_alarm_limits_cp2() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_low_alarm_limits_cp2();
  public:
  void unsafe_arena_set_allocated_cur_low_alarm_limits_cp2(
      ::medibus::MedibusRequest* cur_low_alarm_limits_cp2);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_low_alarm_limits_cp2();

  // optional .medibus.MedibusRequest cur_high_alarm_limits_cp2 = 11;
  bool has_cur_high_alarm_limits_cp2() const;
  private:
  bool _internal_has_cur_high_alarm_limits_cp2() const;
  public:
  void clear_cur_high_alarm_limits_cp2();
  const ::medibus::MedibusRequest& cur_high_alarm_limits_cp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_high_alarm_limits_cp2();
  ::medibus::MedibusRequest* mutable_cur_high_alarm_limits_cp2();
  void set_allocated_cur_high_alarm_limits_cp2(::medibus::MedibusRequest* cur_high_alarm_limits_cp2);
  private:
  const ::medibus::MedibusRequest& _internal_cur_high_alarm_limits_cp2() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_high_alarm_limits_cp2();
  public:
  void unsafe_arena_set_allocated_cur_high_alarm_limits_cp2(
      ::medibus::MedibusRequest* cur_high_alarm_limits_cp2);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_high_alarm_limits_cp2();

  // optional .medibus.MedibusRequest cur_alarms_cp2 = 12;
  bool has_cur_alarms_cp2() const;
  private:
  bool _internal_has_cur_alarms_cp2() const;
  public:
  void clear_cur_alarms_cp2();
  const ::medibus::MedibusRequest& cur_alarms_cp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_cur_alarms_cp2();
  ::medibus::MedibusRequest* mutable_cur_alarms_cp2();
  void set_allocated_cur_alarms_cp2(::medibus::MedibusRequest* cur_alarms_cp2);
  private:
  const ::medibus::MedibusRequest& _internal_cur_alarms_cp2() const;
  ::medibus::MedibusRequest* _internal_mutable_cur_alarms_cp2();
  public:
  void unsafe_arena_set_allocated_cur_alarms_cp2(
      ::medibus::MedibusRequest* cur_alarms_cp2);
  ::medibus::MedibusRequest* unsafe_arena_release_cur_alarms_cp2();

  // optional .medibus.MedibusRequest device_identification = 13;
  bool has_device_identification() const;
  private:
  bool _internal_has_device_identification() const;
  public:
  void clear_device_identification();
  const ::medibus::MedibusRequest& device_identification() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_device_identification();
  ::medibus::MedibusRequest* mutable_device_identification();
  void set_allocated_device_identification(::medibus::MedibusRequest* device_identification);
  private:
  const ::medibus::MedibusRequest& _internal_device_identification() const;
  ::medibus::MedibusRequest* _internal_mutable_device_identification();
  public:
  void unsafe_arena_set_allocated_device_identification(
      ::medibus::MedibusRequest* device_identification);
  ::medibus::MedibusRequest* unsafe_arena_release_device_identification();

  // optional fixed64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  uint64_t sequence_id() const;
  void set_sequence_id(uint64_t value);
  private:
  uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:medibus.LoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest > real_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::medibus::MedibusRequest* cur_measured_data_cp1_;
    ::medibus::MedibusRequest* cur_low_alarm_limits_cp1_;
    ::medibus::MedibusRequest* cur_high_alarm_limits_cp1_;
    ::medibus::MedibusRequest* cur_alarms_cp1_;
    ::medibus::MedibusRequest* cur_device_settings_;
    ::medibus::MedibusRequest* text_messages_;
    ::medibus::MedibusRequest* cur_measured_data_cp2_;
    ::medibus::MedibusRequest* cur_low_alarm_limits_cp2_;
    ::medibus::MedibusRequest* cur_high_alarm_limits_cp2_;
    ::medibus::MedibusRequest* cur_alarms_cp2_;
    ::medibus::MedibusRequest* device_identification_;
    uint64_t sequence_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class DelimitedLoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.DelimitedLoopRequest) */ {
 public:
  inline DelimitedLoopRequest() : DelimitedLoopRequest(nullptr) {}
  ~DelimitedLoopRequest() override;
  explicit PROTOBUF_CONSTEXPR DelimitedLoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelimitedLoopRequest(const DelimitedLoopRequest& from);
  DelimitedLoopRequest(DelimitedLoopRequest&& from) noexcept
    : DelimitedLoopRequest() {
    *this = ::std::move(from);
  }

  inline DelimitedLoopRequest& operator=(const DelimitedLoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelimitedLoopRequest& operator=(DelimitedLoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelimitedLoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelimitedLoopRequest* internal_default_instance() {
    return reinterpret_cast<const DelimitedLoopRequest*>(
               &_DelimitedLoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DelimitedLoopRequest& a, DelimitedLoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DelimitedLoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelimitedLoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelimitedLoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelimitedLoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelimitedLoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelimitedLoopRequest& from) {
    DelimitedLoopRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelimitedLoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.DelimitedLoopRequest";
  }
  protected:
  explicit DelimitedLoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // optional bytes msg = 1;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:medibus.DelimitedLoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceIdentificationRequest_DeviceRespond

// optional string deviceid = 1;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_deviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_deviceid() const {
  return _internal_has_deviceid();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::deviceid() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_deviceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_deviceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_deviceid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_deviceid() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  if (!_internal_has_deviceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.deviceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
}

// optional string devicename = 2;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_devicename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_devicename() const {
  return _internal_has_devicename();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_devicename() {
  _impl_.devicename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::devicename() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_devicename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.devicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_devicename() const {
  return _impl_.devicename_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_devicename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.devicename_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_devicename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.devicename_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_devicename() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  if (!_internal_has_devicename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.devicename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.devicename_.SetAllocated(devicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
}

// optional string facility = 3;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_facility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_facility() const {
  return _internal_has_facility();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_facility() {
  _impl_.facility_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::facility() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  return _internal_facility();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_facility(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.facility_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_facility() {
  std::string* _s = _internal_mutable_facility();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_facility() const {
  return _impl_.facility_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_facility(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.facility_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_facility() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.facility_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_facility() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  if (!_internal_has_facility()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.facility_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facility_.IsDefault()) {
    _impl_.facility_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_facility(std::string* facility) {
  if (facility != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.facility_.SetAllocated(facility, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facility_.IsDefault()) {
    _impl_.facility_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
}

// optional string poc = 4;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_poc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_poc() const {
  return _internal_has_poc();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_poc() {
  _impl_.poc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::poc() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  return _internal_poc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_poc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.poc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_poc() {
  std::string* _s = _internal_mutable_poc();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_poc() const {
  return _impl_.poc_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_poc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.poc_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_poc() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.poc_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_poc() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  if (!_internal_has_poc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.poc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poc_.IsDefault()) {
    _impl_.poc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_poc(std::string* poc) {
  if (poc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.poc_.SetAllocated(poc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poc_.IsDefault()) {
    _impl_.poc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
}

// optional string bed = 5;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_bed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_bed() const {
  return _internal_has_bed();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_bed() {
  _impl_.bed_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::bed() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  return _internal_bed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_bed(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.bed_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_bed() {
  std::string* _s = _internal_mutable_bed();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_bed() const {
  return _impl_.bed_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_bed(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bed_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_bed() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bed_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_bed() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  if (!_internal_has_bed()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.bed_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bed_.IsDefault()) {
    _impl_.bed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_bed(std::string* bed) {
  if (bed != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bed_.SetAllocated(bed, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bed_.IsDefault()) {
    _impl_.bed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
}

// optional string room = 6;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_room() const {
  return _internal_has_room();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_room() {
  _impl_.room_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::room() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_room(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.room)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_room() const {
  return _impl_.room_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_room(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_room() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_room() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  if (!_internal_has_room()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.room_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.room)
}

// optional string building = 7;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_building() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_building() const {
  return _internal_has_building();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_building() {
  _impl_.building_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::building() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  return _internal_building();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_building(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.building_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.building)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_building() {
  std::string* _s = _internal_mutable_building();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_building() const {
  return _impl_.building_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_building(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.building_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_building() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.building_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_building() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  if (!_internal_has_building()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.building_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.building_.IsDefault()) {
    _impl_.building_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_building(std::string* building) {
  if (building != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.building_.SetAllocated(building, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.building_.IsDefault()) {
    _impl_.building_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.building)
}

// optional string floor = 8;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_floor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_floor() const {
  return _internal_has_floor();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_floor() {
  _impl_.floor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::floor() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  return _internal_floor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_floor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.floor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_floor() {
  std::string* _s = _internal_mutable_floor();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_floor() const {
  return _impl_.floor_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_floor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.floor_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_floor() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.floor_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_floor() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  if (!_internal_has_floor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.floor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.floor_.IsDefault()) {
    _impl_.floor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_floor(std::string* floor) {
  if (floor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.floor_.SetAllocated(floor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.floor_.IsDefault()) {
    _impl_.floor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
}

// -------------------------------------------------------------------

// DeviceIdentificationRequest

// optional string instance_id = 1;
inline bool DeviceIdentificationRequest::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void DeviceIdentificationRequest::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceIdentificationRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.instance_id)
}
inline std::string* DeviceIdentificationRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.instance_id)
  return _s;
}
inline const std::string& DeviceIdentificationRequest::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void DeviceIdentificationRequest::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.instance_id)
}

// optional fixed64 sequence_id = 2;
inline bool DeviceIdentificationRequest::_internal_has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void DeviceIdentificationRequest::clear_sequence_id() {
  _impl_.sequence_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DeviceIdentificationRequest::_internal_sequence_id() const {
  return _impl_.sequence_id_;
}
inline uint64_t DeviceIdentificationRequest::sequence_id() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.sequence_id)
  return _internal_sequence_id();
}
inline void DeviceIdentificationRequest::_internal_set_sequence_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_id_ = value;
}
inline void DeviceIdentificationRequest::set_sequence_id(uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.sequence_id)
}

// optional .medibus.DeviceIdentificationRequest.DeviceRespond deviceresponds = 3;
inline bool DeviceIdentificationRequest::_internal_has_deviceresponds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceresponds_ != nullptr);
  return value;
}
inline bool DeviceIdentificationRequest::has_deviceresponds() const {
  return _internal_has_deviceresponds();
}
inline void DeviceIdentificationRequest::clear_deviceresponds() {
  if (_impl_.deviceresponds_ != nullptr) _impl_.deviceresponds_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::medibus::DeviceIdentificationRequest_DeviceRespond& DeviceIdentificationRequest::_internal_deviceresponds() const {
  const ::medibus::DeviceIdentificationRequest_DeviceRespond* p = _impl_.deviceresponds_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::DeviceIdentificationRequest_DeviceRespond&>(
      ::medibus::_DeviceIdentificationRequest_DeviceRespond_default_instance_);
}
inline const ::medibus::DeviceIdentificationRequest_DeviceRespond& DeviceIdentificationRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.deviceresponds)
  return _internal_deviceresponds();
}
inline void DeviceIdentificationRequest::unsafe_arena_set_allocated_deviceresponds(
    ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceresponds_);
  }
  _impl_.deviceresponds_ = deviceresponds;
  if (deviceresponds) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.DeviceIdentificationRequest.deviceresponds)
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::release_deviceresponds() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* temp = _impl_.deviceresponds_;
  _impl_.deviceresponds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::unsafe_arena_release_deviceresponds() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.deviceresponds)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* temp = _impl_.deviceresponds_;
  _impl_.deviceresponds_ = nullptr;
  return temp;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::_internal_mutable_deviceresponds() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.deviceresponds_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::DeviceIdentificationRequest_DeviceRespond>(GetArenaForAllocation());
    _impl_.deviceresponds_ = p;
  }
  return _impl_.deviceresponds_;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::mutable_deviceresponds() {
  ::medibus::DeviceIdentificationRequest_DeviceRespond* _msg = _internal_mutable_deviceresponds();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.deviceresponds)
  return _msg;
}
inline void DeviceIdentificationRequest::set_allocated_deviceresponds(::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceresponds_;
  }
  if (deviceresponds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceresponds);
    if (message_arena != submessage_arena) {
      deviceresponds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceresponds, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deviceresponds_ = deviceresponds;
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.deviceresponds)
}

// -------------------------------------------------------------------

// MedibusRequest_DeviceRespond

// optional string code = 1;
inline bool MedibusRequest_DeviceRespond::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_code() const {
  return _internal_has_code();
}
inline void MedibusRequest_DeviceRespond::clear_code() {
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRequest_DeviceRespond::code() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.code)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.code)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_code() const {
  return _impl_.code_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_code() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.code)
}

// optional string value = 2;
inline bool MedibusRequest_DeviceRespond::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_value() const {
  return _internal_has_value();
}
inline void MedibusRequest_DeviceRespond::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRequest_DeviceRespond::value() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.value)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.value)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_value() const {
  return _impl_.value_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_value() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.value)
}

// optional string unit = 3;
inline bool MedibusRequest_DeviceRespond::_internal_has_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_unit() const {
  return _internal_has_unit();
}
inline void MedibusRequest_DeviceRespond::clear_unit() {
  _impl_.unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MedibusRequest_DeviceRespond::unit() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_unit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.unit)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.unit)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_unit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_unit() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_unit() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.unit)
  if (!_internal_has_unit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.unit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.unit)
}

// optional string description = 4;
inline bool MedibusRequest_DeviceRespond::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_description() const {
  return _internal_has_description();
}
inline void MedibusRequest_DeviceRespond::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MedibusRequest_DeviceRespond::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.description)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.description)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.description)
}

// -------------------------------------------------------------------

// MedibusRequest

// optional string instance_id = 1;
inline bool MedibusRequest::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRequest::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void MedibusRequest::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.instance_id)
}
inline std::string* MedibusRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.instance_id)
  return _s;
}
inline const std::string& MedibusRequest::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void MedibusRequest::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.instance_id)
}

// optional fixed64 sequence_id = 2;
inline bool MedibusRequest::_internal_has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRequest::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void MedibusRequest::clear_sequence_id() {
  _impl_.sequence_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t MedibusRequest::_internal_sequence_id() const {
  return _impl_.sequence_id_;
}
inline uint64_t MedibusRequest::sequence_id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.sequence_id)
  return _internal_sequence_id();
}
inline void MedibusRequest::_internal_set_sequence_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sequence_id_ = value;
}
inline void MedibusRequest::set_sequence_id(uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.sequence_id)
}

// repeated .medibus.MedibusRequest.DeviceRespond deviceresponds = 3;
inline int MedibusRequest::_internal_deviceresponds_size() const {
  return _impl_.deviceresponds_.size();
}
inline int MedibusRequest::deviceresponds_size() const {
  return _internal_deviceresponds_size();
}
inline void MedibusRequest::clear_deviceresponds() {
  _impl_.deviceresponds_.Clear();
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::mutable_deviceresponds(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.deviceresponds)
  return _impl_.deviceresponds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >*
MedibusRequest::mutable_deviceresponds() {
  // @@protoc_insertion_point(field_mutable_list:medibus.MedibusRequest.deviceresponds)
  return &_impl_.deviceresponds_;
}
inline const ::medibus::MedibusRequest_DeviceRespond& MedibusRequest::_internal_deviceresponds(int index) const {
  return _impl_.deviceresponds_.Get(index);
}
inline const ::medibus::MedibusRequest_DeviceRespond& MedibusRequest::deviceresponds(int index) const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.deviceresponds)
  return _internal_deviceresponds(index);
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::_internal_add_deviceresponds() {
  return _impl_.deviceresponds_.Add();
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::add_deviceresponds() {
  ::medibus::MedibusRequest_DeviceRespond* _add = _internal_add_deviceresponds();
  // @@protoc_insertion_point(field_add:medibus.MedibusRequest.deviceresponds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >&
MedibusRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_list:medibus.MedibusRequest.deviceresponds)
  return _impl_.deviceresponds_;
}

// -------------------------------------------------------------------

// MedibusReply

// optional string instance_id = 1;
inline bool MedibusReply::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusReply::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void MedibusReply::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusReply::instance_id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusReply.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusReply::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusReply.instance_id)
}
inline std::string* MedibusReply::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusReply.instance_id)
  return _s;
}
inline const std::string& MedibusReply::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void MedibusReply::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusReply::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusReply::release_instance_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusReply.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusReply::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusReply.instance_id)
}

// string message = 2;
inline void MedibusReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MedibusReply::message() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusReply.message)
}
inline std::string* MedibusReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusReply.message)
  return _s;
}
inline const std::string& MedibusReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MedibusReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusReply::release_message() {
  // @@protoc_insertion_point(field_release:medibus.MedibusReply.message)
  return _impl_.message_.Release();
}
inline void MedibusReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusReply.message)
}

// -------------------------------------------------------------------

// MedibusRealTimeRequest_DeviceRespond

// optional string min = 1;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_min() const {
  return _internal_has_min();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_min() {
  _impl_.min_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::min() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  return _internal_min();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_min(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.min_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.min)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_min() {
  std::string* _s = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_min() const {
  return _impl_.min_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_min(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_min() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.min_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_min() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  if (!_internal_has_min()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.min_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.min_.IsDefault()) {
    _impl_.min_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_min(std::string* min) {
  if (min != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.min_.SetAllocated(min, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.min_.IsDefault()) {
    _impl_.min_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.min)
}

// optional string max = 2;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_max() const {
  return _internal_has_max();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_max() {
  _impl_.max_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::max() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  return _internal_max();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_max(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.max_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.max)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_max() {
  std::string* _s = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_max() const {
  return _impl_.max_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_max(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_max() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.max_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_max() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  if (!_internal_has_max()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.max_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_.IsDefault()) {
    _impl_.max_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_max(std::string* max) {
  if (max != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.max_.SetAllocated(max, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_.IsDefault()) {
    _impl_.max_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.max)
}

// optional string maxbin = 3;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_maxbin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_maxbin() const {
  return _internal_has_maxbin();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_maxbin() {
  _impl_.maxbin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::maxbin() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  return _internal_maxbin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_maxbin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.maxbin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_maxbin() {
  std::string* _s = _internal_mutable_maxbin();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_maxbin() const {
  return _impl_.maxbin_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_maxbin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.maxbin_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_maxbin() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.maxbin_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_maxbin() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  if (!_internal_has_maxbin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.maxbin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maxbin_.IsDefault()) {
    _impl_.maxbin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_maxbin(std::string* maxbin) {
  if (maxbin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.maxbin_.SetAllocated(maxbin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maxbin_.IsDefault()) {
    _impl_.maxbin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
}

// optional string interval = 4;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_interval() const {
  return _internal_has_interval();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_interval() {
  _impl_.interval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::interval() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  return _internal_interval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_interval(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.interval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_interval() {
  std::string* _s = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_interval() const {
  return _impl_.interval_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_interval(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.interval_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.interval_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_interval() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  if (!_internal_has_interval()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.interval_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interval_.IsDefault()) {
    _impl_.interval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_interval(std::string* interval) {
  if (interval != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.interval_.SetAllocated(interval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interval_.IsDefault()) {
    _impl_.interval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
}

// optional string description = 5;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_description() const {
  return _internal_has_description();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.description)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.description)
}

// -------------------------------------------------------------------

// MedibusRealTimeRequest

// optional string instance_id = 1;
inline bool MedibusRealTimeRequest::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void MedibusRealTimeRequest::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRealTimeRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.instance_id)
}
inline std::string* MedibusRealTimeRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.instance_id)
  return _s;
}
inline const std::string& MedibusRealTimeRequest::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void MedibusRealTimeRequest::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.instance_id)
}

// optional fixed64 sequence_id = 2;
inline bool MedibusRealTimeRequest::_internal_has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void MedibusRealTimeRequest::clear_sequence_id() {
  _impl_.sequence_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t MedibusRealTimeRequest::_internal_sequence_id() const {
  return _impl_.sequence_id_;
}
inline uint64_t MedibusRealTimeRequest::sequence_id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.sequence_id)
  return _internal_sequence_id();
}
inline void MedibusRealTimeRequest::_internal_set_sequence_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_id_ = value;
}
inline void MedibusRealTimeRequest::set_sequence_id(uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.sequence_id)
}

// repeated .medibus.MedibusRealTimeRequest.DeviceRespond deviceresponds = 3;
inline int MedibusRealTimeRequest::_internal_deviceresponds_size() const {
  return _impl_.deviceresponds_.size();
}
inline int MedibusRealTimeRequest::deviceresponds_size() const {
  return _internal_deviceresponds_size();
}
inline void MedibusRealTimeRequest::clear_deviceresponds() {
  _impl_.deviceresponds_.Clear();
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::mutable_deviceresponds(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.deviceresponds)
  return _impl_.deviceresponds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >*
MedibusRealTimeRequest::mutable_deviceresponds() {
  // @@protoc_insertion_point(field_mutable_list:medibus.MedibusRealTimeRequest.deviceresponds)
  return &_impl_.deviceresponds_;
}
inline const ::medibus::MedibusRealTimeRequest_DeviceRespond& MedibusRealTimeRequest::_internal_deviceresponds(int index) const {
  return _impl_.deviceresponds_.Get(index);
}
inline const ::medibus::MedibusRealTimeRequest_DeviceRespond& MedibusRealTimeRequest::deviceresponds(int index) const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.deviceresponds)
  return _internal_deviceresponds(index);
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::_internal_add_deviceresponds() {
  return _impl_.deviceresponds_.Add();
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::add_deviceresponds() {
  ::medibus::MedibusRealTimeRequest_DeviceRespond* _add = _internal_add_deviceresponds();
  // @@protoc_insertion_point(field_add:medibus.MedibusRealTimeRequest.deviceresponds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >&
MedibusRealTimeRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_list:medibus.MedibusRealTimeRequest.deviceresponds)
  return _impl_.deviceresponds_;
}

// optional string description = 4;
inline bool MedibusRealTimeRequest::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest::has_description() const {
  return _internal_has_description();
}
inline void MedibusRealTimeRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRealTimeRequest::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.description)
}
inline std::string* MedibusRealTimeRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.description)
  return _s;
}
inline const std::string& MedibusRealTimeRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRealTimeRequest::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.description)
}

// -------------------------------------------------------------------

// LoopRequest

// optional string instance_id = 1;
inline bool LoopRequest::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoopRequest::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void LoopRequest::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoopRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoopRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.LoopRequest.instance_id)
}
inline std::string* LoopRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.instance_id)
  return _s;
}
inline const std::string& LoopRequest::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void LoopRequest::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoopRequest::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoopRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoopRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.instance_id)
}

// optional fixed64 sequence_id = 2;
inline bool LoopRequest::_internal_has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool LoopRequest::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void LoopRequest::clear_sequence_id() {
  _impl_.sequence_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint64_t LoopRequest::_internal_sequence_id() const {
  return _impl_.sequence_id_;
}
inline uint64_t LoopRequest::sequence_id() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.sequence_id)
  return _internal_sequence_id();
}
inline void LoopRequest::_internal_set_sequence_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.sequence_id_ = value;
}
inline void LoopRequest::set_sequence_id(uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:medibus.LoopRequest.sequence_id)
}

// optional .medibus.MedibusRequest cur_measured_data_cp1 = 3;
inline bool LoopRequest::_internal_has_cur_measured_data_cp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_measured_data_cp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_measured_data_cp1() const {
  return _internal_has_cur_measured_data_cp1();
}
inline void LoopRequest::clear_cur_measured_data_cp1() {
  if (_impl_.cur_measured_data_cp1_ != nullptr) _impl_.cur_measured_data_cp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_measured_data_cp1() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_measured_data_cp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_measured_data_cp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_measured_data_cp1)
  return _internal_cur_measured_data_cp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_measured_data_cp1(
    ::medibus::MedibusRequest* cur_measured_data_cp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_measured_data_cp1_);
  }
  _impl_.cur_measured_data_cp1_ = cur_measured_data_cp1;
  if (cur_measured_data_cp1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_measured_data_cp1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_measured_data_cp1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::MedibusRequest* temp = _impl_.cur_measured_data_cp1_;
  _impl_.cur_measured_data_cp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_measured_data_cp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_measured_data_cp1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::MedibusRequest* temp = _impl_.cur_measured_data_cp1_;
  _impl_.cur_measured_data_cp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_measured_data_cp1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cur_measured_data_cp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_measured_data_cp1_ = p;
  }
  return _impl_.cur_measured_data_cp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_measured_data_cp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_measured_data_cp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_measured_data_cp1)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_measured_data_cp1(::medibus::MedibusRequest* cur_measured_data_cp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_measured_data_cp1_;
  }
  if (cur_measured_data_cp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_measured_data_cp1);
    if (message_arena != submessage_arena) {
      cur_measured_data_cp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_measured_data_cp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cur_measured_data_cp1_ = cur_measured_data_cp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_measured_data_cp1)
}

// optional .medibus.MedibusRequest cur_low_alarm_limits_cp1 = 4;
inline bool LoopRequest::_internal_has_cur_low_alarm_limits_cp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_low_alarm_limits_cp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_low_alarm_limits_cp1() const {
  return _internal_has_cur_low_alarm_limits_cp1();
}
inline void LoopRequest::clear_cur_low_alarm_limits_cp1() {
  if (_impl_.cur_low_alarm_limits_cp1_ != nullptr) _impl_.cur_low_alarm_limits_cp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_low_alarm_limits_cp1() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_low_alarm_limits_cp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_low_alarm_limits_cp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_low_alarm_limits_cp1)
  return _internal_cur_low_alarm_limits_cp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_low_alarm_limits_cp1(
    ::medibus::MedibusRequest* cur_low_alarm_limits_cp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_low_alarm_limits_cp1_);
  }
  _impl_.cur_low_alarm_limits_cp1_ = cur_low_alarm_limits_cp1;
  if (cur_low_alarm_limits_cp1) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_low_alarm_limits_cp1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_low_alarm_limits_cp1() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::medibus::MedibusRequest* temp = _impl_.cur_low_alarm_limits_cp1_;
  _impl_.cur_low_alarm_limits_cp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_low_alarm_limits_cp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_low_alarm_limits_cp1)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::medibus::MedibusRequest* temp = _impl_.cur_low_alarm_limits_cp1_;
  _impl_.cur_low_alarm_limits_cp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_low_alarm_limits_cp1() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cur_low_alarm_limits_cp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_low_alarm_limits_cp1_ = p;
  }
  return _impl_.cur_low_alarm_limits_cp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_low_alarm_limits_cp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_low_alarm_limits_cp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_low_alarm_limits_cp1)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_low_alarm_limits_cp1(::medibus::MedibusRequest* cur_low_alarm_limits_cp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_low_alarm_limits_cp1_;
  }
  if (cur_low_alarm_limits_cp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_low_alarm_limits_cp1);
    if (message_arena != submessage_arena) {
      cur_low_alarm_limits_cp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_low_alarm_limits_cp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cur_low_alarm_limits_cp1_ = cur_low_alarm_limits_cp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_low_alarm_limits_cp1)
}

// optional .medibus.MedibusRequest cur_high_alarm_limits_cp1 = 5;
inline bool LoopRequest::_internal_has_cur_high_alarm_limits_cp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_high_alarm_limits_cp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_high_alarm_limits_cp1() const {
  return _internal_has_cur_high_alarm_limits_cp1();
}
inline void LoopRequest::clear_cur_high_alarm_limits_cp1() {
  if (_impl_.cur_high_alarm_limits_cp1_ != nullptr) _impl_.cur_high_alarm_limits_cp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_high_alarm_limits_cp1() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_high_alarm_limits_cp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_high_alarm_limits_cp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_high_alarm_limits_cp1)
  return _internal_cur_high_alarm_limits_cp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_high_alarm_limits_cp1(
    ::medibus::MedibusRequest* cur_high_alarm_limits_cp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_high_alarm_limits_cp1_);
  }
  _impl_.cur_high_alarm_limits_cp1_ = cur_high_alarm_limits_cp1;
  if (cur_high_alarm_limits_cp1) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_high_alarm_limits_cp1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_high_alarm_limits_cp1() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::medibus::MedibusRequest* temp = _impl_.cur_high_alarm_limits_cp1_;
  _impl_.cur_high_alarm_limits_cp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_high_alarm_limits_cp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_high_alarm_limits_cp1)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::medibus::MedibusRequest* temp = _impl_.cur_high_alarm_limits_cp1_;
  _impl_.cur_high_alarm_limits_cp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_high_alarm_limits_cp1() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.cur_high_alarm_limits_cp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_high_alarm_limits_cp1_ = p;
  }
  return _impl_.cur_high_alarm_limits_cp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_high_alarm_limits_cp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_high_alarm_limits_cp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_high_alarm_limits_cp1)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_high_alarm_limits_cp1(::medibus::MedibusRequest* cur_high_alarm_limits_cp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_high_alarm_limits_cp1_;
  }
  if (cur_high_alarm_limits_cp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_high_alarm_limits_cp1);
    if (message_arena != submessage_arena) {
      cur_high_alarm_limits_cp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_high_alarm_limits_cp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.cur_high_alarm_limits_cp1_ = cur_high_alarm_limits_cp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_high_alarm_limits_cp1)
}

// optional .medibus.MedibusRequest cur_alarms_cp1 = 6;
inline bool LoopRequest::_internal_has_cur_alarms_cp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_alarms_cp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_alarms_cp1() const {
  return _internal_has_cur_alarms_cp1();
}
inline void LoopRequest::clear_cur_alarms_cp1() {
  if (_impl_.cur_alarms_cp1_ != nullptr) _impl_.cur_alarms_cp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_alarms_cp1() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_alarms_cp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_alarms_cp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_alarms_cp1)
  return _internal_cur_alarms_cp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_alarms_cp1(
    ::medibus::MedibusRequest* cur_alarms_cp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_alarms_cp1_);
  }
  _impl_.cur_alarms_cp1_ = cur_alarms_cp1;
  if (cur_alarms_cp1) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_alarms_cp1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_alarms_cp1() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::medibus::MedibusRequest* temp = _impl_.cur_alarms_cp1_;
  _impl_.cur_alarms_cp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_alarms_cp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_alarms_cp1)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::medibus::MedibusRequest* temp = _impl_.cur_alarms_cp1_;
  _impl_.cur_alarms_cp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_alarms_cp1() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.cur_alarms_cp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_alarms_cp1_ = p;
  }
  return _impl_.cur_alarms_cp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_alarms_cp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_alarms_cp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_alarms_cp1)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_alarms_cp1(::medibus::MedibusRequest* cur_alarms_cp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_alarms_cp1_;
  }
  if (cur_alarms_cp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_alarms_cp1);
    if (message_arena != submessage_arena) {
      cur_alarms_cp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_alarms_cp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.cur_alarms_cp1_ = cur_alarms_cp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_alarms_cp1)
}

// optional .medibus.MedibusRequest cur_device_settings = 7;
inline bool LoopRequest::_internal_has_cur_device_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_device_settings_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_device_settings() const {
  return _internal_has_cur_device_settings();
}
inline void LoopRequest::clear_cur_device_settings() {
  if (_impl_.cur_device_settings_ != nullptr) _impl_.cur_device_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_device_settings() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_device_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_device_settings() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_device_settings)
  return _internal_cur_device_settings();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_device_settings(
    ::medibus::MedibusRequest* cur_device_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_device_settings_);
  }
  _impl_.cur_device_settings_ = cur_device_settings;
  if (cur_device_settings) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_device_settings)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_device_settings() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::medibus::MedibusRequest* temp = _impl_.cur_device_settings_;
  _impl_.cur_device_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_device_settings() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_device_settings)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::medibus::MedibusRequest* temp = _impl_.cur_device_settings_;
  _impl_.cur_device_settings_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_device_settings() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.cur_device_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_device_settings_ = p;
  }
  return _impl_.cur_device_settings_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_device_settings() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_device_settings();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_device_settings)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_device_settings(::medibus::MedibusRequest* cur_device_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_device_settings_;
  }
  if (cur_device_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_device_settings);
    if (message_arena != submessage_arena) {
      cur_device_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_device_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.cur_device_settings_ = cur_device_settings;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_device_settings)
}

// optional .medibus.MedibusRequest text_messages = 8;
inline bool LoopRequest::_internal_has_text_messages() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_messages_ != nullptr);
  return value;
}
inline bool LoopRequest::has_text_messages() const {
  return _internal_has_text_messages();
}
inline void LoopRequest::clear_text_messages() {
  if (_impl_.text_messages_ != nullptr) _impl_.text_messages_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_text_messages() const {
  const ::medibus::MedibusRequest* p = _impl_.text_messages_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::text_messages() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.text_messages)
  return _internal_text_messages();
}
inline void LoopRequest::unsafe_arena_set_allocated_text_messages(
    ::medibus::MedibusRequest* text_messages) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_messages_);
  }
  _impl_.text_messages_ = text_messages;
  if (text_messages) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.text_messages)
}
inline ::medibus::MedibusRequest* LoopRequest::release_text_messages() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::medibus::MedibusRequest* temp = _impl_.text_messages_;
  _impl_.text_messages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_text_messages() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.text_messages)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::medibus::MedibusRequest* temp = _impl_.text_messages_;
  _impl_.text_messages_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_text_messages() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.text_messages_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.text_messages_ = p;
  }
  return _impl_.text_messages_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_text_messages() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_text_messages();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.text_messages)
  return _msg;
}
inline void LoopRequest::set_allocated_text_messages(::medibus::MedibusRequest* text_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_messages_;
  }
  if (text_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_messages);
    if (message_arena != submessage_arena) {
      text_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_messages, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.text_messages_ = text_messages;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.text_messages)
}

// optional .medibus.MedibusRequest cur_measured_data_cp2 = 9;
inline bool LoopRequest::_internal_has_cur_measured_data_cp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_measured_data_cp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_measured_data_cp2() const {
  return _internal_has_cur_measured_data_cp2();
}
inline void LoopRequest::clear_cur_measured_data_cp2() {
  if (_impl_.cur_measured_data_cp2_ != nullptr) _impl_.cur_measured_data_cp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_measured_data_cp2() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_measured_data_cp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_measured_data_cp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_measured_data_cp2)
  return _internal_cur_measured_data_cp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_measured_data_cp2(
    ::medibus::MedibusRequest* cur_measured_data_cp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_measured_data_cp2_);
  }
  _impl_.cur_measured_data_cp2_ = cur_measured_data_cp2;
  if (cur_measured_data_cp2) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_measured_data_cp2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_measured_data_cp2() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::medibus::MedibusRequest* temp = _impl_.cur_measured_data_cp2_;
  _impl_.cur_measured_data_cp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_measured_data_cp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_measured_data_cp2)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::medibus::MedibusRequest* temp = _impl_.cur_measured_data_cp2_;
  _impl_.cur_measured_data_cp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_measured_data_cp2() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.cur_measured_data_cp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_measured_data_cp2_ = p;
  }
  return _impl_.cur_measured_data_cp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_measured_data_cp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_measured_data_cp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_measured_data_cp2)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_measured_data_cp2(::medibus::MedibusRequest* cur_measured_data_cp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_measured_data_cp2_;
  }
  if (cur_measured_data_cp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_measured_data_cp2);
    if (message_arena != submessage_arena) {
      cur_measured_data_cp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_measured_data_cp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.cur_measured_data_cp2_ = cur_measured_data_cp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_measured_data_cp2)
}

// optional .medibus.MedibusRequest cur_low_alarm_limits_cp2 = 10;
inline bool LoopRequest::_internal_has_cur_low_alarm_limits_cp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_low_alarm_limits_cp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_low_alarm_limits_cp2() const {
  return _internal_has_cur_low_alarm_limits_cp2();
}
inline void LoopRequest::clear_cur_low_alarm_limits_cp2() {
  if (_impl_.cur_low_alarm_limits_cp2_ != nullptr) _impl_.cur_low_alarm_limits_cp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_low_alarm_limits_cp2() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_low_alarm_limits_cp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_low_alarm_limits_cp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_low_alarm_limits_cp2)
  return _internal_cur_low_alarm_limits_cp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_low_alarm_limits_cp2(
    ::medibus::MedibusRequest* cur_low_alarm_limits_cp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_low_alarm_limits_cp2_);
  }
  _impl_.cur_low_alarm_limits_cp2_ = cur_low_alarm_limits_cp2;
  if (cur_low_alarm_limits_cp2) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_low_alarm_limits_cp2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_low_alarm_limits_cp2() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::medibus::MedibusRequest* temp = _impl_.cur_low_alarm_limits_cp2_;
  _impl_.cur_low_alarm_limits_cp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_low_alarm_limits_cp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_low_alarm_limits_cp2)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::medibus::MedibusRequest* temp = _impl_.cur_low_alarm_limits_cp2_;
  _impl_.cur_low_alarm_limits_cp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_low_alarm_limits_cp2() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.cur_low_alarm_limits_cp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_low_alarm_limits_cp2_ = p;
  }
  return _impl_.cur_low_alarm_limits_cp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_low_alarm_limits_cp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_low_alarm_limits_cp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_low_alarm_limits_cp2)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_low_alarm_limits_cp2(::medibus::MedibusRequest* cur_low_alarm_limits_cp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_low_alarm_limits_cp2_;
  }
  if (cur_low_alarm_limits_cp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_low_alarm_limits_cp2);
    if (message_arena != submessage_arena) {
      cur_low_alarm_limits_cp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_low_alarm_limits_cp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.cur_low_alarm_limits_cp2_ = cur_low_alarm_limits_cp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_low_alarm_limits_cp2)
}

// optional .medibus.MedibusRequest cur_high_alarm_limits_cp2 = 11;
inline bool LoopRequest::_internal_has_cur_high_alarm_limits_cp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_high_alarm_limits_cp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_high_alarm_limits_cp2() const {
  return _internal_has_cur_high_alarm_limits_cp2();
}
inline void LoopRequest::clear_cur_high_alarm_limits_cp2() {
  if (_impl_.cur_high_alarm_limits_cp2_ != nullptr) _impl_.cur_high_alarm_limits_cp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_high_alarm_limits_cp2() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_high_alarm_limits_cp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_high_alarm_limits_cp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_high_alarm_limits_cp2)
  return _internal_cur_high_alarm_limits_cp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_high_alarm_limits_cp2(
    ::medibus::MedibusRequest* cur_high_alarm_limits_cp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_high_alarm_limits_cp2_);
  }
  _impl_.cur_high_alarm_limits_cp2_ = cur_high_alarm_limits_cp2;
  if (cur_high_alarm_limits_cp2) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_high_alarm_limits_cp2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_high_alarm_limits_cp2() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::medibus::MedibusRequest* temp = _impl_.cur_high_alarm_limits_cp2_;
  _impl_.cur_high_alarm_limits_cp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_high_alarm_limits_cp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_high_alarm_limits_cp2)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::medibus::MedibusRequest* temp = _impl_.cur_high_alarm_limits_cp2_;
  _impl_.cur_high_alarm_limits_cp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_high_alarm_limits_cp2() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.cur_high_alarm_limits_cp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_high_alarm_limits_cp2_ = p;
  }
  return _impl_.cur_high_alarm_limits_cp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_high_alarm_limits_cp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_high_alarm_limits_cp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_high_alarm_limits_cp2)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_high_alarm_limits_cp2(::medibus::MedibusRequest* cur_high_alarm_limits_cp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_high_alarm_limits_cp2_;
  }
  if (cur_high_alarm_limits_cp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_high_alarm_limits_cp2);
    if (message_arena != submessage_arena) {
      cur_high_alarm_limits_cp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_high_alarm_limits_cp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.cur_high_alarm_limits_cp2_ = cur_high_alarm_limits_cp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_high_alarm_limits_cp2)
}

// optional .medibus.MedibusRequest cur_alarms_cp2 = 12;
inline bool LoopRequest::_internal_has_cur_alarms_cp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cur_alarms_cp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_cur_alarms_cp2() const {
  return _internal_has_cur_alarms_cp2();
}
inline void LoopRequest::clear_cur_alarms_cp2() {
  if (_impl_.cur_alarms_cp2_ != nullptr) _impl_.cur_alarms_cp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_cur_alarms_cp2() const {
  const ::medibus::MedibusRequest* p = _impl_.cur_alarms_cp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::cur_alarms_cp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.cur_alarms_cp2)
  return _internal_cur_alarms_cp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_cur_alarms_cp2(
    ::medibus::MedibusRequest* cur_alarms_cp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cur_alarms_cp2_);
  }
  _impl_.cur_alarms_cp2_ = cur_alarms_cp2;
  if (cur_alarms_cp2) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.cur_alarms_cp2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_cur_alarms_cp2() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::medibus::MedibusRequest* temp = _impl_.cur_alarms_cp2_;
  _impl_.cur_alarms_cp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_cur_alarms_cp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.cur_alarms_cp2)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::medibus::MedibusRequest* temp = _impl_.cur_alarms_cp2_;
  _impl_.cur_alarms_cp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_cur_alarms_cp2() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.cur_alarms_cp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.cur_alarms_cp2_ = p;
  }
  return _impl_.cur_alarms_cp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_cur_alarms_cp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_cur_alarms_cp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.cur_alarms_cp2)
  return _msg;
}
inline void LoopRequest::set_allocated_cur_alarms_cp2(::medibus::MedibusRequest* cur_alarms_cp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cur_alarms_cp2_;
  }
  if (cur_alarms_cp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cur_alarms_cp2);
    if (message_arena != submessage_arena) {
      cur_alarms_cp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_alarms_cp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.cur_alarms_cp2_ = cur_alarms_cp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.cur_alarms_cp2)
}

// optional .medibus.MedibusRequest device_identification = 13;
inline bool LoopRequest::_internal_has_device_identification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_identification_ != nullptr);
  return value;
}
inline bool LoopRequest::has_device_identification() const {
  return _internal_has_device_identification();
}
inline void LoopRequest::clear_device_identification() {
  if (_impl_.device_identification_ != nullptr) _impl_.device_identification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_device_identification() const {
  const ::medibus::MedibusRequest* p = _impl_.device_identification_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::device_identification() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.device_identification)
  return _internal_device_identification();
}
inline void LoopRequest::unsafe_arena_set_allocated_device_identification(
    ::medibus::MedibusRequest* device_identification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_identification_);
  }
  _impl_.device_identification_ = device_identification;
  if (device_identification) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.device_identification)
}
inline ::medibus::MedibusRequest* LoopRequest::release_device_identification() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::medibus::MedibusRequest* temp = _impl_.device_identification_;
  _impl_.device_identification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_device_identification() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.device_identification)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::medibus::MedibusRequest* temp = _impl_.device_identification_;
  _impl_.device_identification_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_device_identification() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.device_identification_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.device_identification_ = p;
  }
  return _impl_.device_identification_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_device_identification() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_device_identification();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.device_identification)
  return _msg;
}
inline void LoopRequest::set_allocated_device_identification(::medibus::MedibusRequest* device_identification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_identification_;
  }
  if (device_identification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_identification);
    if (message_arena != submessage_arena) {
      device_identification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_identification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.device_identification_ = device_identification;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.device_identification)
}

// repeated .medibus.MedibusRealTimeRequest real_time = 14;
inline int LoopRequest::_internal_real_time_size() const {
  return _impl_.real_time_.size();
}
inline int LoopRequest::real_time_size() const {
  return _internal_real_time_size();
}
inline void LoopRequest::clear_real_time() {
  _impl_.real_time_.Clear();
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::mutable_real_time(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.real_time)
  return _impl_.real_time_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >*
LoopRequest::mutable_real_time() {
  // @@protoc_insertion_point(field_mutable_list:medibus.LoopRequest.real_time)
  return &_impl_.real_time_;
}
inline const ::medibus::MedibusRealTimeRequest& LoopRequest::_internal_real_time(int index) const {
  return _impl_.real_time_.Get(index);
}
inline const ::medibus::MedibusRealTimeRequest& LoopRequest::real_time(int index) const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.real_time)
  return _internal_real_time(index);
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::_internal_add_real_time() {
  return _impl_.real_time_.Add();
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::add_real_time() {
  ::medibus::MedibusRealTimeRequest* _add = _internal_add_real_time();
  // @@protoc_insertion_point(field_add:medibus.LoopRequest.real_time)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >&
LoopRequest::real_time() const {
  // @@protoc_insertion_point(field_list:medibus.LoopRequest.real_time)
  return _impl_.real_time_;
}

// -------------------------------------------------------------------

// DelimitedLoopRequest

// optional bytes msg = 1;
inline bool DelimitedLoopRequest::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DelimitedLoopRequest::has_msg() const {
  return _internal_has_msg();
}
inline void DelimitedLoopRequest::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DelimitedLoopRequest::msg() const {
  // @@protoc_insertion_point(field_get:medibus.DelimitedLoopRequest.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelimitedLoopRequest::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DelimitedLoopRequest.msg)
}
inline std::string* DelimitedLoopRequest::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:medibus.DelimitedLoopRequest.msg)
  return _s;
}
inline const std::string& DelimitedLoopRequest::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void DelimitedLoopRequest::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* DelimitedLoopRequest::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* DelimitedLoopRequest::release_msg() {
  // @@protoc_insertion_point(field_release:medibus.DelimitedLoopRequest.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DelimitedLoopRequest::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DelimitedLoopRequest.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace medibus

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto
