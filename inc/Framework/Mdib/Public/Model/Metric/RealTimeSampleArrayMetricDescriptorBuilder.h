/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/RealTimeSampleArrayMetricDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref RealTimeSampleArrayMetricDescriptor
 * @ingroup Mdib
 */
class RealTimeSampleArrayMetricDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref RealTimeSampleArrayMetricDescriptor
        using BuiltType = RealTimeSampleArrayMetricDescriptor;

        /// @brief Builder based on given immutable @ref RealTimeSampleArrayMetricDescriptor
        explicit RealTimeSampleArrayMetricDescriptorBuilder(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor=RealTimeSampleArrayMetricDescriptor());

        /// @brief Builder based on given immutable @ref RealTimeSampleArrayMetricDescriptor
        explicit RealTimeSampleArrayMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<RealTimeSampleArrayMetricDescriptor>>& realTimeSampleArrayMetricDescriptor);

        /// @brief Overwrite all values with given immutable @ref RealTimeSampleArrayMetricDescriptor
        RealTimeSampleArrayMetricDescriptorBuilder& operator=(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor);

        /// @brief Explicit conversion to immutable @ref RealTimeSampleArrayMetricDescriptor
        RealTimeSampleArrayMetricDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref RealTimeSampleArrayMetricDescriptor
        bool isChanged(const RealTimeSampleArrayMetricDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& safetyClassification(SafetyClassification safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        RealTimeSampleArrayMetricDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for unit
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& unit(const Unit& unit);
        RealTimeSampleArrayMetricDescriptorBuilder& unit(Unit&& unit);
        /// @}

        /// @brief Setter for bodySites
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& bodySites(const BodySites& bodySites);
        RealTimeSampleArrayMetricDescriptorBuilder& bodySites(BodySites&& bodySites);
        /// @}

        /// @brief Setter for metricCategory
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& metricCategory(MetricCategory metricCategory);
        /// @}

        /// @brief Setter for derivationMethod
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& derivationMethod(boost::optional<DerivationMethod> derivationMethod);
        /// @}

        /// @brief Setter for metricAvailability
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& metricAvailability(MetricAvailability metricAvailability);
        /// @}

        /// @brief Setter for maxMeasurementTime
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime);
        RealTimeSampleArrayMetricDescriptorBuilder& maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime);
        /// @}

        /// @brief Setter for maxDelayTime
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& maxDelayTime(const boost::optional<Duration>& maxDelayTime);
        RealTimeSampleArrayMetricDescriptorBuilder& maxDelayTime(boost::optional<Duration>&& maxDelayTime);
        /// @}

        /// @brief Setter for determinationPeriod
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& determinationPeriod(const boost::optional<Duration>& determinationPeriod);
        RealTimeSampleArrayMetricDescriptorBuilder& determinationPeriod(boost::optional<Duration>&& determinationPeriod);
        /// @}

        /// @brief Setter for lifeTimePeriod
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod);
        RealTimeSampleArrayMetricDescriptorBuilder& lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod);
        /// @}

        /// @brief Setter for activationDuration
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& activationDuration(const boost::optional<Duration>& activationDuration);
        RealTimeSampleArrayMetricDescriptorBuilder& activationDuration(boost::optional<Duration>&& activationDuration);
        /// @}

        /// @brief Setter for relations
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& relations(const Relations& relations);
        RealTimeSampleArrayMetricDescriptorBuilder& relations(Relations&& relations);
        /// @}

        /// @brief Setter for resolution
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& resolution(Decimal resolution);
        /// @}

        /// @brief Setter for samplePeriod
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& samplePeriod(Duration samplePeriod);
        /// @}

        /// @brief Setter for technicalRanges
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& technicalRanges(const Ranges& technicalRanges);
        RealTimeSampleArrayMetricDescriptorBuilder& technicalRanges(Ranges&& technicalRanges);
        /// @}

        /// @brief Setter for extensions
        /// @{
        RealTimeSampleArrayMetricDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        RealTimeSampleArrayMetricDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        SafetyClassification& safetyClassification();
        SafetyClassification safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for unit
        /// @{
        Unit& unit();
        const Unit& unit() const;
        /// @}

        /// @brief Getter for bodySites
        /// @{
        BodySites& bodySites();
        const BodySites& bodySites() const;
        /// @}

        /// @brief Getter for metricCategory
        /// @{
        MetricCategory& metricCategory();
        MetricCategory metricCategory() const;
        /// @}

        /// @brief Getter for derivationMethod
        /// @{
        boost::optional<DerivationMethod>& derivationMethod();
        boost::optional<DerivationMethod> derivationMethod() const;
        /// @}

        /// @brief Getter for metricAvailability
        /// @{
        MetricAvailability& metricAvailability();
        MetricAvailability metricAvailability() const;
        /// @}

        /// @brief Getter for maxMeasurementTime
        /// @{
        boost::optional<Duration>& maxMeasurementTime();
        const boost::optional<Duration>& maxMeasurementTime() const;
        /// @}

        /// @brief Getter for maxDelayTime
        /// @{
        boost::optional<Duration>& maxDelayTime();
        const boost::optional<Duration>& maxDelayTime() const;
        /// @}

        /// @brief Getter for determinationPeriod
        /// @{
        boost::optional<Duration>& determinationPeriod();
        const boost::optional<Duration>& determinationPeriod() const;
        /// @}

        /// @brief Getter for lifeTimePeriod
        /// @{
        boost::optional<Duration>& lifeTimePeriod();
        const boost::optional<Duration>& lifeTimePeriod() const;
        /// @}

        /// @brief Getter for activationDuration
        /// @{
        boost::optional<Duration>& activationDuration();
        const boost::optional<Duration>& activationDuration() const;
        /// @}

        /// @brief Getter for relations
        /// @{
        Relations& relations();
        const Relations& relations() const;
        /// @}

        /// @brief Getter for resolution
        /// @{
        Decimal& resolution();
        Decimal resolution() const;
        /// @}

        /// @brief Getter for samplePeriod
        /// @{
        Duration& samplePeriod();
        Duration samplePeriod() const;
        /// @}

        /// @brief Getter for technicalRanges
        /// @{
        Ranges& technicalRanges();
        const Ranges& technicalRanges() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        SafetyClassification m_safetyClassification;
        boost::optional<CodedValue> m_type;
        Unit m_unit;
        BodySites m_bodySites;
        MetricCategory m_metricCategory;
        boost::optional<DerivationMethod> m_derivationMethod;
        MetricAvailability m_metricAvailability;
        boost::optional<Duration> m_maxMeasurementTime;
        boost::optional<Duration> m_maxDelayTime;
        boost::optional<Duration> m_determinationPeriod;
        boost::optional<Duration> m_lifeTimePeriod;
        boost::optional<Duration> m_activationDuration;
        Relations m_relations;
        Decimal m_resolution;
        Duration m_samplePeriod;
        Ranges m_technicalRanges;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptor& rhs);
bool operator==(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptor& rhs);
bool operator!=(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs);
bool operator!=(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs);
bool operator!=(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref RealTimeSampleArrayMetricDescriptor
 * @ingroup Mdib
 */
/// @{
RealTimeSampleArrayMetricDescriptorBuilder getBuilder(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor);
RealTimeSampleArrayMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<RealTimeSampleArrayMetricDescriptor>>& realTimeSampleArrayMetricDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptor& rhs);

inline RealTimeSampleArrayMetricDescriptorBuilder::RealTimeSampleArrayMetricDescriptorBuilder(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor) :
    m_safetyClassification(realTimeSampleArrayMetricDescriptor.safetyClassification()),
    m_type(realTimeSampleArrayMetricDescriptor.type()),
    m_unit(realTimeSampleArrayMetricDescriptor.unit()),
    m_bodySites(realTimeSampleArrayMetricDescriptor.bodySites()),
    m_metricCategory(realTimeSampleArrayMetricDescriptor.metricCategory()),
    m_derivationMethod(realTimeSampleArrayMetricDescriptor.derivationMethod()),
    m_metricAvailability(realTimeSampleArrayMetricDescriptor.metricAvailability()),
    m_maxMeasurementTime(realTimeSampleArrayMetricDescriptor.maxMeasurementTime()),
    m_maxDelayTime(realTimeSampleArrayMetricDescriptor.maxDelayTime()),
    m_determinationPeriod(realTimeSampleArrayMetricDescriptor.determinationPeriod()),
    m_lifeTimePeriod(realTimeSampleArrayMetricDescriptor.lifeTimePeriod()),
    m_activationDuration(realTimeSampleArrayMetricDescriptor.activationDuration()),
    m_relations(realTimeSampleArrayMetricDescriptor.relations()),
    m_resolution(realTimeSampleArrayMetricDescriptor.resolution()),
    m_samplePeriod(realTimeSampleArrayMetricDescriptor.samplePeriod()),
    m_technicalRanges(realTimeSampleArrayMetricDescriptor.technicalRanges()),
    m_extensions(realTimeSampleArrayMetricDescriptor.extensions())
{
}

inline RealTimeSampleArrayMetricDescriptorBuilder::RealTimeSampleArrayMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<RealTimeSampleArrayMetricDescriptor>>& realTimeSampleArrayMetricDescriptor) :
    m_safetyClassification(realTimeSampleArrayMetricDescriptor->safetyClassification()),
    m_type(realTimeSampleArrayMetricDescriptor->type()),
    m_unit(realTimeSampleArrayMetricDescriptor->unit()),
    m_bodySites(realTimeSampleArrayMetricDescriptor->bodySites()),
    m_metricCategory(realTimeSampleArrayMetricDescriptor->metricCategory()),
    m_derivationMethod(realTimeSampleArrayMetricDescriptor->derivationMethod()),
    m_metricAvailability(realTimeSampleArrayMetricDescriptor->metricAvailability()),
    m_maxMeasurementTime(realTimeSampleArrayMetricDescriptor->maxMeasurementTime()),
    m_maxDelayTime(realTimeSampleArrayMetricDescriptor->maxDelayTime()),
    m_determinationPeriod(realTimeSampleArrayMetricDescriptor->determinationPeriod()),
    m_lifeTimePeriod(realTimeSampleArrayMetricDescriptor->lifeTimePeriod()),
    m_activationDuration(realTimeSampleArrayMetricDescriptor->activationDuration()),
    m_relations(realTimeSampleArrayMetricDescriptor->relations()),
    m_resolution(realTimeSampleArrayMetricDescriptor->resolution()),
    m_samplePeriod(realTimeSampleArrayMetricDescriptor->samplePeriod()),
    m_technicalRanges(realTimeSampleArrayMetricDescriptor->technicalRanges()),
    m_extensions(realTimeSampleArrayMetricDescriptor->extensions())
{
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::operator=(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor)
{
    m_safetyClassification = realTimeSampleArrayMetricDescriptor.safetyClassification();
    m_type = realTimeSampleArrayMetricDescriptor.type();
    m_unit = realTimeSampleArrayMetricDescriptor.unit();
    m_bodySites = realTimeSampleArrayMetricDescriptor.bodySites();
    m_metricCategory = realTimeSampleArrayMetricDescriptor.metricCategory();
    m_derivationMethod = realTimeSampleArrayMetricDescriptor.derivationMethod();
    m_metricAvailability = realTimeSampleArrayMetricDescriptor.metricAvailability();
    m_maxMeasurementTime = realTimeSampleArrayMetricDescriptor.maxMeasurementTime();
    m_maxDelayTime = realTimeSampleArrayMetricDescriptor.maxDelayTime();
    m_determinationPeriod = realTimeSampleArrayMetricDescriptor.determinationPeriod();
    m_lifeTimePeriod = realTimeSampleArrayMetricDescriptor.lifeTimePeriod();
    m_activationDuration = realTimeSampleArrayMetricDescriptor.activationDuration();
    m_relations = realTimeSampleArrayMetricDescriptor.relations();
    m_resolution = realTimeSampleArrayMetricDescriptor.resolution();
    m_samplePeriod = realTimeSampleArrayMetricDescriptor.samplePeriod();
    m_technicalRanges = realTimeSampleArrayMetricDescriptor.technicalRanges();
    m_extensions = realTimeSampleArrayMetricDescriptor.extensions();
    return *this;
}

inline RealTimeSampleArrayMetricDescriptor RealTimeSampleArrayMetricDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return RealTimeSampleArrayMetricDescriptor(m_safetyClassification, m_type, m_unit, m_bodySites, m_metricCategory, m_derivationMethod, m_metricAvailability, m_maxMeasurementTime, m_maxDelayTime, m_determinationPeriod, m_lifeTimePeriod, m_activationDuration, m_relations, m_resolution, m_samplePeriod, m_technicalRanges, m_extensions);
}

inline bool RealTimeSampleArrayMetricDescriptorBuilder::isChanged(const RealTimeSampleArrayMetricDescriptor& base) const
{
    return *this != base;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::safetyClassification(SafetyClassification safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline SafetyClassification& RealTimeSampleArrayMetricDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline SafetyClassification RealTimeSampleArrayMetricDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& RealTimeSampleArrayMetricDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& RealTimeSampleArrayMetricDescriptorBuilder::type() const
{
    return m_type;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::unit(const Unit& unit)
{
    m_unit = unit;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::unit(Unit&& unit)
{
    m_unit = std::move(unit);
    return *this;
}

inline Unit& RealTimeSampleArrayMetricDescriptorBuilder::unit()
{
    return m_unit;
}

inline const Unit& RealTimeSampleArrayMetricDescriptorBuilder::unit() const
{
    return m_unit;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::bodySites(const BodySites& bodySites)
{
    m_bodySites = bodySites;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::bodySites(BodySites&& bodySites)
{
    m_bodySites = std::move(bodySites);
    return *this;
}

inline BodySites& RealTimeSampleArrayMetricDescriptorBuilder::bodySites()
{
    return m_bodySites;
}

inline const BodySites& RealTimeSampleArrayMetricDescriptorBuilder::bodySites() const
{
    return m_bodySites;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::metricCategory(MetricCategory metricCategory)
{
    m_metricCategory = metricCategory;
    return *this;
}

inline MetricCategory& RealTimeSampleArrayMetricDescriptorBuilder::metricCategory()
{
    return m_metricCategory;
}

inline MetricCategory RealTimeSampleArrayMetricDescriptorBuilder::metricCategory() const
{
    return m_metricCategory;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::derivationMethod(boost::optional<DerivationMethod> derivationMethod)
{
    m_derivationMethod = derivationMethod;
    return *this;
}

inline boost::optional<DerivationMethod>& RealTimeSampleArrayMetricDescriptorBuilder::derivationMethod()
{
    return m_derivationMethod;
}

inline boost::optional<DerivationMethod> RealTimeSampleArrayMetricDescriptorBuilder::derivationMethod() const
{
    return m_derivationMethod;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::metricAvailability(MetricAvailability metricAvailability)
{
    m_metricAvailability = metricAvailability;
    return *this;
}

inline MetricAvailability& RealTimeSampleArrayMetricDescriptorBuilder::metricAvailability()
{
    return m_metricAvailability;
}

inline MetricAvailability RealTimeSampleArrayMetricDescriptorBuilder::metricAvailability() const
{
    return m_metricAvailability;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime)
{
    m_maxMeasurementTime = maxMeasurementTime;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime)
{
    m_maxMeasurementTime = std::move(maxMeasurementTime);
    return *this;
}

inline boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::maxMeasurementTime()
{
    return m_maxMeasurementTime;
}

inline const boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::maxMeasurementTime() const
{
    return m_maxMeasurementTime;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::maxDelayTime(const boost::optional<Duration>& maxDelayTime)
{
    m_maxDelayTime = maxDelayTime;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::maxDelayTime(boost::optional<Duration>&& maxDelayTime)
{
    m_maxDelayTime = std::move(maxDelayTime);
    return *this;
}

inline boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::maxDelayTime()
{
    return m_maxDelayTime;
}

inline const boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::maxDelayTime() const
{
    return m_maxDelayTime;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::determinationPeriod(const boost::optional<Duration>& determinationPeriod)
{
    m_determinationPeriod = determinationPeriod;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::determinationPeriod(boost::optional<Duration>&& determinationPeriod)
{
    m_determinationPeriod = std::move(determinationPeriod);
    return *this;
}

inline boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::determinationPeriod()
{
    return m_determinationPeriod;
}

inline const boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::determinationPeriod() const
{
    return m_determinationPeriod;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod)
{
    m_lifeTimePeriod = lifeTimePeriod;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod)
{
    m_lifeTimePeriod = std::move(lifeTimePeriod);
    return *this;
}

inline boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::lifeTimePeriod()
{
    return m_lifeTimePeriod;
}

inline const boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::lifeTimePeriod() const
{
    return m_lifeTimePeriod;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::activationDuration(const boost::optional<Duration>& activationDuration)
{
    m_activationDuration = activationDuration;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::activationDuration(boost::optional<Duration>&& activationDuration)
{
    m_activationDuration = std::move(activationDuration);
    return *this;
}

inline boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::activationDuration()
{
    return m_activationDuration;
}

inline const boost::optional<Duration>& RealTimeSampleArrayMetricDescriptorBuilder::activationDuration() const
{
    return m_activationDuration;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::relations(const Relations& relations)
{
    m_relations = relations;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::relations(Relations&& relations)
{
    m_relations = std::move(relations);
    return *this;
}

inline Relations& RealTimeSampleArrayMetricDescriptorBuilder::relations()
{
    return m_relations;
}

inline const Relations& RealTimeSampleArrayMetricDescriptorBuilder::relations() const
{
    return m_relations;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::resolution(Decimal resolution)
{
    m_resolution = resolution;
    return *this;
}

inline Decimal& RealTimeSampleArrayMetricDescriptorBuilder::resolution()
{
    return m_resolution;
}

inline Decimal RealTimeSampleArrayMetricDescriptorBuilder::resolution() const
{
    return m_resolution;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::samplePeriod(Duration samplePeriod)
{
    m_samplePeriod = samplePeriod;
    return *this;
}

inline Duration& RealTimeSampleArrayMetricDescriptorBuilder::samplePeriod()
{
    return m_samplePeriod;
}

inline Duration RealTimeSampleArrayMetricDescriptorBuilder::samplePeriod() const
{
    return m_samplePeriod;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::technicalRanges(const Ranges& technicalRanges)
{
    m_technicalRanges = technicalRanges;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::technicalRanges(Ranges&& technicalRanges)
{
    m_technicalRanges = std::move(technicalRanges);
    return *this;
}

inline Ranges& RealTimeSampleArrayMetricDescriptorBuilder::technicalRanges()
{
    return m_technicalRanges;
}

inline const Ranges& RealTimeSampleArrayMetricDescriptorBuilder::technicalRanges() const
{
    return m_technicalRanges;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline RealTimeSampleArrayMetricDescriptorBuilder& RealTimeSampleArrayMetricDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& RealTimeSampleArrayMetricDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& RealTimeSampleArrayMetricDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const RealTimeSampleArrayMetricDescriptor& lhs, const RealTimeSampleArrayMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const RealTimeSampleArrayMetricDescriptorBuilder& lhs, const RealTimeSampleArrayMetricDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline RealTimeSampleArrayMetricDescriptorBuilder getBuilder(const RealTimeSampleArrayMetricDescriptor& realTimeSampleArrayMetricDescriptor)
{
    return RealTimeSampleArrayMetricDescriptorBuilder(realTimeSampleArrayMetricDescriptor);
}

inline RealTimeSampleArrayMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<RealTimeSampleArrayMetricDescriptor>>& realTimeSampleArrayMetricDescriptor)
{
    return RealTimeSampleArrayMetricDescriptorBuilder(realTimeSampleArrayMetricDescriptor);
}

}
}
