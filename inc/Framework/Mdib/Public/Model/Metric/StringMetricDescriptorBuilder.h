/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/StringMetricDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref StringMetricDescriptor
 * @ingroup Mdib
 */
class StringMetricDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref StringMetricDescriptor
        using BuiltType = StringMetricDescriptor;

        /// @brief Builder based on given immutable @ref StringMetricDescriptor
        explicit StringMetricDescriptorBuilder(const StringMetricDescriptor& stringMetricDescriptor=StringMetricDescriptor());

        /// @brief Builder based on given immutable @ref StringMetricDescriptor
        explicit StringMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<StringMetricDescriptor>>& stringMetricDescriptor);

        /// @brief Overwrite all values with given immutable @ref StringMetricDescriptor
        StringMetricDescriptorBuilder& operator=(const StringMetricDescriptor& stringMetricDescriptor);

        /// @brief Explicit conversion to immutable @ref StringMetricDescriptor
        StringMetricDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref StringMetricDescriptor
        bool isChanged(const StringMetricDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        StringMetricDescriptorBuilder& safetyClassification(SafetyClassification safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        StringMetricDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        StringMetricDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for unit
        /// @{
        StringMetricDescriptorBuilder& unit(const Unit& unit);
        StringMetricDescriptorBuilder& unit(Unit&& unit);
        /// @}

        /// @brief Setter for bodySites
        /// @{
        StringMetricDescriptorBuilder& bodySites(const BodySites& bodySites);
        StringMetricDescriptorBuilder& bodySites(BodySites&& bodySites);
        /// @}

        /// @brief Setter for metricCategory
        /// @{
        StringMetricDescriptorBuilder& metricCategory(MetricCategory metricCategory);
        /// @}

        /// @brief Setter for derivationMethod
        /// @{
        StringMetricDescriptorBuilder& derivationMethod(boost::optional<DerivationMethod> derivationMethod);
        /// @}

        /// @brief Setter for metricAvailability
        /// @{
        StringMetricDescriptorBuilder& metricAvailability(MetricAvailability metricAvailability);
        /// @}

        /// @brief Setter for maxMeasurementTime
        /// @{
        StringMetricDescriptorBuilder& maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime);
        StringMetricDescriptorBuilder& maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime);
        /// @}

        /// @brief Setter for maxDelayTime
        /// @{
        StringMetricDescriptorBuilder& maxDelayTime(const boost::optional<Duration>& maxDelayTime);
        StringMetricDescriptorBuilder& maxDelayTime(boost::optional<Duration>&& maxDelayTime);
        /// @}

        /// @brief Setter for determinationPeriod
        /// @{
        StringMetricDescriptorBuilder& determinationPeriod(const boost::optional<Duration>& determinationPeriod);
        StringMetricDescriptorBuilder& determinationPeriod(boost::optional<Duration>&& determinationPeriod);
        /// @}

        /// @brief Setter for lifeTimePeriod
        /// @{
        StringMetricDescriptorBuilder& lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod);
        StringMetricDescriptorBuilder& lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod);
        /// @}

        /// @brief Setter for activationDuration
        /// @{
        StringMetricDescriptorBuilder& activationDuration(const boost::optional<Duration>& activationDuration);
        StringMetricDescriptorBuilder& activationDuration(boost::optional<Duration>&& activationDuration);
        /// @}

        /// @brief Setter for relations
        /// @{
        StringMetricDescriptorBuilder& relations(const Relations& relations);
        StringMetricDescriptorBuilder& relations(Relations&& relations);
        /// @}

        /// @brief Setter for extensions
        /// @{
        StringMetricDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        StringMetricDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        SafetyClassification& safetyClassification();
        SafetyClassification safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for unit
        /// @{
        Unit& unit();
        const Unit& unit() const;
        /// @}

        /// @brief Getter for bodySites
        /// @{
        BodySites& bodySites();
        const BodySites& bodySites() const;
        /// @}

        /// @brief Getter for metricCategory
        /// @{
        MetricCategory& metricCategory();
        MetricCategory metricCategory() const;
        /// @}

        /// @brief Getter for derivationMethod
        /// @{
        boost::optional<DerivationMethod>& derivationMethod();
        boost::optional<DerivationMethod> derivationMethod() const;
        /// @}

        /// @brief Getter for metricAvailability
        /// @{
        MetricAvailability& metricAvailability();
        MetricAvailability metricAvailability() const;
        /// @}

        /// @brief Getter for maxMeasurementTime
        /// @{
        boost::optional<Duration>& maxMeasurementTime();
        const boost::optional<Duration>& maxMeasurementTime() const;
        /// @}

        /// @brief Getter for maxDelayTime
        /// @{
        boost::optional<Duration>& maxDelayTime();
        const boost::optional<Duration>& maxDelayTime() const;
        /// @}

        /// @brief Getter for determinationPeriod
        /// @{
        boost::optional<Duration>& determinationPeriod();
        const boost::optional<Duration>& determinationPeriod() const;
        /// @}

        /// @brief Getter for lifeTimePeriod
        /// @{
        boost::optional<Duration>& lifeTimePeriod();
        const boost::optional<Duration>& lifeTimePeriod() const;
        /// @}

        /// @brief Getter for activationDuration
        /// @{
        boost::optional<Duration>& activationDuration();
        const boost::optional<Duration>& activationDuration() const;
        /// @}

        /// @brief Getter for relations
        /// @{
        Relations& relations();
        const Relations& relations() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        SafetyClassification m_safetyClassification;
        boost::optional<CodedValue> m_type;
        Unit m_unit;
        BodySites m_bodySites;
        MetricCategory m_metricCategory;
        boost::optional<DerivationMethod> m_derivationMethod;
        MetricAvailability m_metricAvailability;
        boost::optional<Duration> m_maxMeasurementTime;
        boost::optional<Duration> m_maxDelayTime;
        boost::optional<Duration> m_determinationPeriod;
        boost::optional<Duration> m_lifeTimePeriod;
        boost::optional<Duration> m_activationDuration;
        Relations m_relations;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const StringMetricDescriptor& lhs, const StringMetricDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptor& rhs);
bool operator==(const StringMetricDescriptor& lhs, const StringMetricDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const StringMetricDescriptor& lhs, const StringMetricDescriptor& rhs);
bool operator!=(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptorBuilder& rhs);
bool operator!=(const StringMetricDescriptor& lhs, const StringMetricDescriptorBuilder& rhs);
bool operator!=(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref StringMetricDescriptor
 * @ingroup Mdib
 */
/// @{
StringMetricDescriptorBuilder getBuilder(const StringMetricDescriptor& stringMetricDescriptor);
StringMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<StringMetricDescriptor>>& stringMetricDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const StringMetricDescriptor& lhs, const StringMetricDescriptor& rhs);

inline StringMetricDescriptorBuilder::StringMetricDescriptorBuilder(const StringMetricDescriptor& stringMetricDescriptor) :
    m_safetyClassification(stringMetricDescriptor.safetyClassification()),
    m_type(stringMetricDescriptor.type()),
    m_unit(stringMetricDescriptor.unit()),
    m_bodySites(stringMetricDescriptor.bodySites()),
    m_metricCategory(stringMetricDescriptor.metricCategory()),
    m_derivationMethod(stringMetricDescriptor.derivationMethod()),
    m_metricAvailability(stringMetricDescriptor.metricAvailability()),
    m_maxMeasurementTime(stringMetricDescriptor.maxMeasurementTime()),
    m_maxDelayTime(stringMetricDescriptor.maxDelayTime()),
    m_determinationPeriod(stringMetricDescriptor.determinationPeriod()),
    m_lifeTimePeriod(stringMetricDescriptor.lifeTimePeriod()),
    m_activationDuration(stringMetricDescriptor.activationDuration()),
    m_relations(stringMetricDescriptor.relations()),
    m_extensions(stringMetricDescriptor.extensions())
{
}

inline StringMetricDescriptorBuilder::StringMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<StringMetricDescriptor>>& stringMetricDescriptor) :
    m_safetyClassification(stringMetricDescriptor->safetyClassification()),
    m_type(stringMetricDescriptor->type()),
    m_unit(stringMetricDescriptor->unit()),
    m_bodySites(stringMetricDescriptor->bodySites()),
    m_metricCategory(stringMetricDescriptor->metricCategory()),
    m_derivationMethod(stringMetricDescriptor->derivationMethod()),
    m_metricAvailability(stringMetricDescriptor->metricAvailability()),
    m_maxMeasurementTime(stringMetricDescriptor->maxMeasurementTime()),
    m_maxDelayTime(stringMetricDescriptor->maxDelayTime()),
    m_determinationPeriod(stringMetricDescriptor->determinationPeriod()),
    m_lifeTimePeriod(stringMetricDescriptor->lifeTimePeriod()),
    m_activationDuration(stringMetricDescriptor->activationDuration()),
    m_relations(stringMetricDescriptor->relations()),
    m_extensions(stringMetricDescriptor->extensions())
{
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::operator=(const StringMetricDescriptor& stringMetricDescriptor)
{
    m_safetyClassification = stringMetricDescriptor.safetyClassification();
    m_type = stringMetricDescriptor.type();
    m_unit = stringMetricDescriptor.unit();
    m_bodySites = stringMetricDescriptor.bodySites();
    m_metricCategory = stringMetricDescriptor.metricCategory();
    m_derivationMethod = stringMetricDescriptor.derivationMethod();
    m_metricAvailability = stringMetricDescriptor.metricAvailability();
    m_maxMeasurementTime = stringMetricDescriptor.maxMeasurementTime();
    m_maxDelayTime = stringMetricDescriptor.maxDelayTime();
    m_determinationPeriod = stringMetricDescriptor.determinationPeriod();
    m_lifeTimePeriod = stringMetricDescriptor.lifeTimePeriod();
    m_activationDuration = stringMetricDescriptor.activationDuration();
    m_relations = stringMetricDescriptor.relations();
    m_extensions = stringMetricDescriptor.extensions();
    return *this;
}

inline StringMetricDescriptor StringMetricDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return StringMetricDescriptor(m_safetyClassification, m_type, m_unit, m_bodySites, m_metricCategory, m_derivationMethod, m_metricAvailability, m_maxMeasurementTime, m_maxDelayTime, m_determinationPeriod, m_lifeTimePeriod, m_activationDuration, m_relations, m_extensions);
}

inline bool StringMetricDescriptorBuilder::isChanged(const StringMetricDescriptor& base) const
{
    return *this != base;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::safetyClassification(SafetyClassification safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline SafetyClassification& StringMetricDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline SafetyClassification StringMetricDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& StringMetricDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& StringMetricDescriptorBuilder::type() const
{
    return m_type;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::unit(const Unit& unit)
{
    m_unit = unit;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::unit(Unit&& unit)
{
    m_unit = std::move(unit);
    return *this;
}

inline Unit& StringMetricDescriptorBuilder::unit()
{
    return m_unit;
}

inline const Unit& StringMetricDescriptorBuilder::unit() const
{
    return m_unit;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::bodySites(const BodySites& bodySites)
{
    m_bodySites = bodySites;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::bodySites(BodySites&& bodySites)
{
    m_bodySites = std::move(bodySites);
    return *this;
}

inline BodySites& StringMetricDescriptorBuilder::bodySites()
{
    return m_bodySites;
}

inline const BodySites& StringMetricDescriptorBuilder::bodySites() const
{
    return m_bodySites;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::metricCategory(MetricCategory metricCategory)
{
    m_metricCategory = metricCategory;
    return *this;
}

inline MetricCategory& StringMetricDescriptorBuilder::metricCategory()
{
    return m_metricCategory;
}

inline MetricCategory StringMetricDescriptorBuilder::metricCategory() const
{
    return m_metricCategory;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::derivationMethod(boost::optional<DerivationMethod> derivationMethod)
{
    m_derivationMethod = derivationMethod;
    return *this;
}

inline boost::optional<DerivationMethod>& StringMetricDescriptorBuilder::derivationMethod()
{
    return m_derivationMethod;
}

inline boost::optional<DerivationMethod> StringMetricDescriptorBuilder::derivationMethod() const
{
    return m_derivationMethod;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::metricAvailability(MetricAvailability metricAvailability)
{
    m_metricAvailability = metricAvailability;
    return *this;
}

inline MetricAvailability& StringMetricDescriptorBuilder::metricAvailability()
{
    return m_metricAvailability;
}

inline MetricAvailability StringMetricDescriptorBuilder::metricAvailability() const
{
    return m_metricAvailability;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime)
{
    m_maxMeasurementTime = maxMeasurementTime;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime)
{
    m_maxMeasurementTime = std::move(maxMeasurementTime);
    return *this;
}

inline boost::optional<Duration>& StringMetricDescriptorBuilder::maxMeasurementTime()
{
    return m_maxMeasurementTime;
}

inline const boost::optional<Duration>& StringMetricDescriptorBuilder::maxMeasurementTime() const
{
    return m_maxMeasurementTime;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::maxDelayTime(const boost::optional<Duration>& maxDelayTime)
{
    m_maxDelayTime = maxDelayTime;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::maxDelayTime(boost::optional<Duration>&& maxDelayTime)
{
    m_maxDelayTime = std::move(maxDelayTime);
    return *this;
}

inline boost::optional<Duration>& StringMetricDescriptorBuilder::maxDelayTime()
{
    return m_maxDelayTime;
}

inline const boost::optional<Duration>& StringMetricDescriptorBuilder::maxDelayTime() const
{
    return m_maxDelayTime;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::determinationPeriod(const boost::optional<Duration>& determinationPeriod)
{
    m_determinationPeriod = determinationPeriod;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::determinationPeriod(boost::optional<Duration>&& determinationPeriod)
{
    m_determinationPeriod = std::move(determinationPeriod);
    return *this;
}

inline boost::optional<Duration>& StringMetricDescriptorBuilder::determinationPeriod()
{
    return m_determinationPeriod;
}

inline const boost::optional<Duration>& StringMetricDescriptorBuilder::determinationPeriod() const
{
    return m_determinationPeriod;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod)
{
    m_lifeTimePeriod = lifeTimePeriod;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod)
{
    m_lifeTimePeriod = std::move(lifeTimePeriod);
    return *this;
}

inline boost::optional<Duration>& StringMetricDescriptorBuilder::lifeTimePeriod()
{
    return m_lifeTimePeriod;
}

inline const boost::optional<Duration>& StringMetricDescriptorBuilder::lifeTimePeriod() const
{
    return m_lifeTimePeriod;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::activationDuration(const boost::optional<Duration>& activationDuration)
{
    m_activationDuration = activationDuration;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::activationDuration(boost::optional<Duration>&& activationDuration)
{
    m_activationDuration = std::move(activationDuration);
    return *this;
}

inline boost::optional<Duration>& StringMetricDescriptorBuilder::activationDuration()
{
    return m_activationDuration;
}

inline const boost::optional<Duration>& StringMetricDescriptorBuilder::activationDuration() const
{
    return m_activationDuration;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::relations(const Relations& relations)
{
    m_relations = relations;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::relations(Relations&& relations)
{
    m_relations = std::move(relations);
    return *this;
}

inline Relations& StringMetricDescriptorBuilder::relations()
{
    return m_relations;
}

inline const Relations& StringMetricDescriptorBuilder::relations() const
{
    return m_relations;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline StringMetricDescriptorBuilder& StringMetricDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& StringMetricDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& StringMetricDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const StringMetricDescriptor& lhs, const StringMetricDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const StringMetricDescriptor& lhs, const StringMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const StringMetricDescriptorBuilder& lhs, const StringMetricDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline StringMetricDescriptorBuilder getBuilder(const StringMetricDescriptor& stringMetricDescriptor)
{
    return StringMetricDescriptorBuilder(stringMetricDescriptor);
}

inline StringMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<StringMetricDescriptor>>& stringMetricDescriptor)
{
    return StringMetricDescriptorBuilder(stringMetricDescriptor);
}

}
}
