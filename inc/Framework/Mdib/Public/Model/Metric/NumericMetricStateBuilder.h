/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/NumericMetricState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref NumericMetricState
 * @ingroup Mdib
 */
class NumericMetricStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref NumericMetricState
        using BuiltType = NumericMetricState;

        /// @brief Builder based on given immutable @ref NumericMetricState
        explicit NumericMetricStateBuilder(const NumericMetricState& numericMetricState=NumericMetricState());

        /// @brief Builder based on given immutable @ref NumericMetricState
        explicit NumericMetricStateBuilder(const DFL::NotNull<SharedPtr<NumericMetricState>>& numericMetricState);

        /// @brief Overwrite all values with given immutable @ref NumericMetricState
        NumericMetricStateBuilder& operator=(const NumericMetricState& numericMetricState);

        /// @brief Explicit conversion to immutable @ref NumericMetricState
        NumericMetricState build() const;

        /// @brief Test whether the builder differs from the immutable @ref NumericMetricState
        bool isChanged(const NumericMetricState& base) const;

        /// @brief Setter for activationState
        /// @{
        NumericMetricStateBuilder& activationState(ComponentActivation activationState);
        /// @}

        /// @brief Setter for activeDeterminationPeriod
        /// @{
        NumericMetricStateBuilder& activeDeterminationPeriod(const boost::optional<Duration>& activeDeterminationPeriod);
        NumericMetricStateBuilder& activeDeterminationPeriod(boost::optional<Duration>&& activeDeterminationPeriod);
        /// @}

        /// @brief Setter for lifeTimePeriod
        /// @{
        NumericMetricStateBuilder& lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod);
        NumericMetricStateBuilder& lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod);
        /// @}

        /// @brief Setter for bodySites
        /// @{
        NumericMetricStateBuilder& bodySites(const BodySites& bodySites);
        NumericMetricStateBuilder& bodySites(BodySites&& bodySites);
        /// @}

        /// @brief Setter for physicalConnector
        /// @{
        NumericMetricStateBuilder& physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector);
        NumericMetricStateBuilder& physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector);
        /// @}

        /// @brief Setter for activeAveragingPeriod
        /// @{
        NumericMetricStateBuilder& activeAveragingPeriod(const boost::optional<Duration>& activeAveragingPeriod);
        NumericMetricStateBuilder& activeAveragingPeriod(boost::optional<Duration>&& activeAveragingPeriod);
        /// @}

        /// @brief Setter for metricValue
        /// @{
        NumericMetricStateBuilder& metricValue(const boost::optional<NumericMetricValue>& metricValue);
        NumericMetricStateBuilder& metricValue(boost::optional<NumericMetricValue>&& metricValue);
        /// @}

        /// @brief Setter for physiologicalRanges
        /// @{
        NumericMetricStateBuilder& physiologicalRanges(const Ranges& physiologicalRanges);
        NumericMetricStateBuilder& physiologicalRanges(Ranges&& physiologicalRanges);
        /// @}

        /// @brief Setter for extensions
        /// @{
        NumericMetricStateBuilder& extensions(const ExtensionTypes& extensions);
        NumericMetricStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        ComponentActivation& activationState();
        ComponentActivation activationState() const;
        /// @}

        /// @brief Getter for activeDeterminationPeriod
        /// @{
        boost::optional<Duration>& activeDeterminationPeriod();
        const boost::optional<Duration>& activeDeterminationPeriod() const;
        /// @}

        /// @brief Getter for lifeTimePeriod
        /// @{
        boost::optional<Duration>& lifeTimePeriod();
        const boost::optional<Duration>& lifeTimePeriod() const;
        /// @}

        /// @brief Getter for bodySites
        /// @{
        BodySites& bodySites();
        const BodySites& bodySites() const;
        /// @}

        /// @brief Getter for physicalConnector
        /// @{
        boost::optional<PhysicalConnectorInfo>& physicalConnector();
        const boost::optional<PhysicalConnectorInfo>& physicalConnector() const;
        /// @}

        /// @brief Getter for activeAveragingPeriod
        /// @{
        boost::optional<Duration>& activeAveragingPeriod();
        const boost::optional<Duration>& activeAveragingPeriod() const;
        /// @}

        /// @brief Getter for metricValue
        /// @{
        boost::optional<NumericMetricValue>& metricValue();
        const boost::optional<NumericMetricValue>& metricValue() const;
        /// @}

        /// @brief Getter for physiologicalRanges
        /// @{
        Ranges& physiologicalRanges();
        const Ranges& physiologicalRanges() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        ComponentActivation m_activationState;
        boost::optional<Duration> m_activeDeterminationPeriod;
        boost::optional<Duration> m_lifeTimePeriod;
        BodySites m_bodySites;
        boost::optional<PhysicalConnectorInfo> m_physicalConnector;
        boost::optional<Duration> m_activeAveragingPeriod;
        boost::optional<NumericMetricValue> m_metricValue;
        Ranges m_physiologicalRanges;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const NumericMetricState& lhs, const NumericMetricState& rhs);
DFL_MDIB_EXPIMP bool operator==(const NumericMetricStateBuilder& lhs, const NumericMetricStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const NumericMetricStateBuilder& lhs, const NumericMetricState& rhs);
bool operator==(const NumericMetricState& lhs, const NumericMetricStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const NumericMetricState& lhs, const NumericMetricState& rhs);
bool operator!=(const NumericMetricStateBuilder& lhs, const NumericMetricStateBuilder& rhs);
bool operator!=(const NumericMetricState& lhs, const NumericMetricStateBuilder& rhs);
bool operator!=(const NumericMetricStateBuilder& lhs, const NumericMetricState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref NumericMetricState
 * @ingroup Mdib
 */
/// @{
NumericMetricStateBuilder getBuilder(const NumericMetricState& numericMetricState);
NumericMetricStateBuilder getBuilder(const DFL::NotNull<SharedPtr<NumericMetricState>>& numericMetricState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const NumericMetricState& lhs, const NumericMetricState& rhs);

inline NumericMetricStateBuilder::NumericMetricStateBuilder(const NumericMetricState& numericMetricState) :
    m_activationState(numericMetricState.activationState()),
    m_activeDeterminationPeriod(numericMetricState.activeDeterminationPeriod()),
    m_lifeTimePeriod(numericMetricState.lifeTimePeriod()),
    m_bodySites(numericMetricState.bodySites()),
    m_physicalConnector(numericMetricState.physicalConnector()),
    m_activeAveragingPeriod(numericMetricState.activeAveragingPeriod()),
    m_metricValue(numericMetricState.metricValue()),
    m_physiologicalRanges(numericMetricState.physiologicalRanges()),
    m_extensions(numericMetricState.extensions())
{
}

inline NumericMetricStateBuilder::NumericMetricStateBuilder(const DFL::NotNull<SharedPtr<NumericMetricState>>& numericMetricState) :
    m_activationState(numericMetricState->activationState()),
    m_activeDeterminationPeriod(numericMetricState->activeDeterminationPeriod()),
    m_lifeTimePeriod(numericMetricState->lifeTimePeriod()),
    m_bodySites(numericMetricState->bodySites()),
    m_physicalConnector(numericMetricState->physicalConnector()),
    m_activeAveragingPeriod(numericMetricState->activeAveragingPeriod()),
    m_metricValue(numericMetricState->metricValue()),
    m_physiologicalRanges(numericMetricState->physiologicalRanges()),
    m_extensions(numericMetricState->extensions())
{
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::operator=(const NumericMetricState& numericMetricState)
{
    m_activationState = numericMetricState.activationState();
    m_activeDeterminationPeriod = numericMetricState.activeDeterminationPeriod();
    m_lifeTimePeriod = numericMetricState.lifeTimePeriod();
    m_bodySites = numericMetricState.bodySites();
    m_physicalConnector = numericMetricState.physicalConnector();
    m_activeAveragingPeriod = numericMetricState.activeAveragingPeriod();
    m_metricValue = numericMetricState.metricValue();
    m_physiologicalRanges = numericMetricState.physiologicalRanges();
    m_extensions = numericMetricState.extensions();
    return *this;
}

inline NumericMetricState NumericMetricStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return NumericMetricState(m_activationState, m_activeDeterminationPeriod, m_lifeTimePeriod, m_bodySites, m_physicalConnector, m_activeAveragingPeriod, m_metricValue, m_physiologicalRanges, m_extensions);
}

inline bool NumericMetricStateBuilder::isChanged(const NumericMetricState& base) const
{
    return *this != base;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::activationState(ComponentActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline ComponentActivation& NumericMetricStateBuilder::activationState()
{
    return m_activationState;
}

inline ComponentActivation NumericMetricStateBuilder::activationState() const
{
    return m_activationState;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::activeDeterminationPeriod(const boost::optional<Duration>& activeDeterminationPeriod)
{
    m_activeDeterminationPeriod = activeDeterminationPeriod;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::activeDeterminationPeriod(boost::optional<Duration>&& activeDeterminationPeriod)
{
    m_activeDeterminationPeriod = std::move(activeDeterminationPeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricStateBuilder::activeDeterminationPeriod()
{
    return m_activeDeterminationPeriod;
}

inline const boost::optional<Duration>& NumericMetricStateBuilder::activeDeterminationPeriod() const
{
    return m_activeDeterminationPeriod;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod)
{
    m_lifeTimePeriod = lifeTimePeriod;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod)
{
    m_lifeTimePeriod = std::move(lifeTimePeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricStateBuilder::lifeTimePeriod()
{
    return m_lifeTimePeriod;
}

inline const boost::optional<Duration>& NumericMetricStateBuilder::lifeTimePeriod() const
{
    return m_lifeTimePeriod;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::bodySites(const BodySites& bodySites)
{
    m_bodySites = bodySites;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::bodySites(BodySites&& bodySites)
{
    m_bodySites = std::move(bodySites);
    return *this;
}

inline BodySites& NumericMetricStateBuilder::bodySites()
{
    return m_bodySites;
}

inline const BodySites& NumericMetricStateBuilder::bodySites() const
{
    return m_bodySites;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector)
{
    m_physicalConnector = physicalConnector;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector)
{
    m_physicalConnector = std::move(physicalConnector);
    return *this;
}

inline boost::optional<PhysicalConnectorInfo>& NumericMetricStateBuilder::physicalConnector()
{
    return m_physicalConnector;
}

inline const boost::optional<PhysicalConnectorInfo>& NumericMetricStateBuilder::physicalConnector() const
{
    return m_physicalConnector;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::activeAveragingPeriod(const boost::optional<Duration>& activeAveragingPeriod)
{
    m_activeAveragingPeriod = activeAveragingPeriod;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::activeAveragingPeriod(boost::optional<Duration>&& activeAveragingPeriod)
{
    m_activeAveragingPeriod = std::move(activeAveragingPeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricStateBuilder::activeAveragingPeriod()
{
    return m_activeAveragingPeriod;
}

inline const boost::optional<Duration>& NumericMetricStateBuilder::activeAveragingPeriod() const
{
    return m_activeAveragingPeriod;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::metricValue(const boost::optional<NumericMetricValue>& metricValue)
{
    m_metricValue = metricValue;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::metricValue(boost::optional<NumericMetricValue>&& metricValue)
{
    m_metricValue = std::move(metricValue);
    return *this;
}

inline boost::optional<NumericMetricValue>& NumericMetricStateBuilder::metricValue()
{
    return m_metricValue;
}

inline const boost::optional<NumericMetricValue>& NumericMetricStateBuilder::metricValue() const
{
    return m_metricValue;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::physiologicalRanges(const Ranges& physiologicalRanges)
{
    m_physiologicalRanges = physiologicalRanges;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::physiologicalRanges(Ranges&& physiologicalRanges)
{
    m_physiologicalRanges = std::move(physiologicalRanges);
    return *this;
}

inline Ranges& NumericMetricStateBuilder::physiologicalRanges()
{
    return m_physiologicalRanges;
}

inline const Ranges& NumericMetricStateBuilder::physiologicalRanges() const
{
    return m_physiologicalRanges;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline NumericMetricStateBuilder& NumericMetricStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& NumericMetricStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& NumericMetricStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const NumericMetricState& lhs, const NumericMetricStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const NumericMetricStateBuilder& lhs, const NumericMetricStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const NumericMetricState& lhs, const NumericMetricStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const NumericMetricStateBuilder& lhs, const NumericMetricState& rhs)
{
    return !(lhs == rhs);
}

inline NumericMetricStateBuilder getBuilder(const NumericMetricState& numericMetricState)
{
    return NumericMetricStateBuilder(numericMetricState);
}

inline NumericMetricStateBuilder getBuilder(const DFL::NotNull<SharedPtr<NumericMetricState>>& numericMetricState)
{
    return NumericMetricStateBuilder(numericMetricState);
}

}
}
