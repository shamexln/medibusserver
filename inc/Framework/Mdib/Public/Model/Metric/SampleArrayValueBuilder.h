/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/SampleArrayValue.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref SampleArrayValue
 * @ingroup Mdib
 */
class SampleArrayValueBuilder
{
    public:
        /// @brief Typedef to the immutable @ref SampleArrayValue
        using BuiltType = SampleArrayValue;

        /// @brief Builder based on given immutable @ref SampleArrayValue
        explicit SampleArrayValueBuilder(const SampleArrayValue& sampleArrayValue=SampleArrayValue());

        /// @brief Builder based on given immutable @ref SampleArrayValue
        explicit SampleArrayValueBuilder(const DFL::NotNull<SharedPtr<SampleArrayValue>>& sampleArrayValue);

        /// @brief Overwrite all values with given immutable @ref SampleArrayValue
        SampleArrayValueBuilder& operator=(const SampleArrayValue& sampleArrayValue);

        /// @brief Explicit conversion to immutable @ref SampleArrayValue
        SampleArrayValue build() const;

        /// @brief Test whether the builder differs from the immutable @ref SampleArrayValue
        bool isChanged(const SampleArrayValue& base) const;

        /// @brief Setter for metricQuality
        /// @{
        SampleArrayValueBuilder& metricQuality(const MetricQuality& metricQuality);
        SampleArrayValueBuilder& metricQuality(MetricQuality&& metricQuality);
        /// @}

        /// @brief Setter for annotations
        /// @{
        SampleArrayValueBuilder& annotations(const Annotations& annotations);
        SampleArrayValueBuilder& annotations(Annotations&& annotations);
        /// @}

        /// @brief Setter for startTime
        /// @{
        SampleArrayValueBuilder& startTime(const boost::optional<Timestamp>& startTime);
        SampleArrayValueBuilder& startTime(boost::optional<Timestamp>&& startTime);
        /// @}

        /// @brief Setter for stopTime
        /// @{
        SampleArrayValueBuilder& stopTime(const boost::optional<Timestamp>& stopTime);
        SampleArrayValueBuilder& stopTime(boost::optional<Timestamp>&& stopTime);
        /// @}

        /// @brief Setter for determinationTime
        /// @{
        SampleArrayValueBuilder& determinationTime(const boost::optional<Timestamp>& determinationTime);
        SampleArrayValueBuilder& determinationTime(boost::optional<Timestamp>&& determinationTime);
        /// @}

        /// @brief Setter for samples
        /// @{
        SampleArrayValueBuilder& samples(const Samples& samples);
        SampleArrayValueBuilder& samples(Samples&& samples);
        /// @}

        /// @brief Setter for extensions
        /// @{
        SampleArrayValueBuilder& extensions(const ExtensionTypes& extensions);
        SampleArrayValueBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for metricQuality
        /// @{
        MetricQuality& metricQuality();
        const MetricQuality& metricQuality() const;
        /// @}

        /// @brief Getter for annotations
        /// @{
        Annotations& annotations();
        const Annotations& annotations() const;
        /// @}

        /// @brief Getter for startTime
        /// @{
        boost::optional<Timestamp>& startTime();
        const boost::optional<Timestamp>& startTime() const;
        /// @}

        /// @brief Getter for stopTime
        /// @{
        boost::optional<Timestamp>& stopTime();
        const boost::optional<Timestamp>& stopTime() const;
        /// @}

        /// @brief Getter for determinationTime
        /// @{
        boost::optional<Timestamp>& determinationTime();
        const boost::optional<Timestamp>& determinationTime() const;
        /// @}

        /// @brief Getter for samples
        /// @{
        Samples& samples();
        const Samples& samples() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        MetricQuality m_metricQuality;
        Annotations m_annotations;
        boost::optional<Timestamp> m_startTime;
        boost::optional<Timestamp> m_stopTime;
        boost::optional<Timestamp> m_determinationTime;
        Samples m_samples;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const SampleArrayValue& lhs, const SampleArrayValue& rhs);
DFL_MDIB_EXPIMP bool operator==(const SampleArrayValueBuilder& lhs, const SampleArrayValueBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const SampleArrayValueBuilder& lhs, const SampleArrayValue& rhs);
bool operator==(const SampleArrayValue& lhs, const SampleArrayValueBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const SampleArrayValue& lhs, const SampleArrayValue& rhs);
bool operator!=(const SampleArrayValueBuilder& lhs, const SampleArrayValueBuilder& rhs);
bool operator!=(const SampleArrayValue& lhs, const SampleArrayValueBuilder& rhs);
bool operator!=(const SampleArrayValueBuilder& lhs, const SampleArrayValue& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref SampleArrayValue
 * @ingroup Mdib
 */
/// @{
SampleArrayValueBuilder getBuilder(const SampleArrayValue& sampleArrayValue);
SampleArrayValueBuilder getBuilder(const DFL::NotNull<SharedPtr<SampleArrayValue>>& sampleArrayValue);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const SampleArrayValue& lhs, const SampleArrayValue& rhs);

inline SampleArrayValueBuilder::SampleArrayValueBuilder(const SampleArrayValue& sampleArrayValue) :
    m_metricQuality(sampleArrayValue.metricQuality()),
    m_annotations(sampleArrayValue.annotations()),
    m_startTime(sampleArrayValue.startTime()),
    m_stopTime(sampleArrayValue.stopTime()),
    m_determinationTime(sampleArrayValue.determinationTime()),
    m_samples(sampleArrayValue.samples()),
    m_extensions(sampleArrayValue.extensions())
{
}

inline SampleArrayValueBuilder::SampleArrayValueBuilder(const DFL::NotNull<SharedPtr<SampleArrayValue>>& sampleArrayValue) :
    m_metricQuality(sampleArrayValue->metricQuality()),
    m_annotations(sampleArrayValue->annotations()),
    m_startTime(sampleArrayValue->startTime()),
    m_stopTime(sampleArrayValue->stopTime()),
    m_determinationTime(sampleArrayValue->determinationTime()),
    m_samples(sampleArrayValue->samples()),
    m_extensions(sampleArrayValue->extensions())
{
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::operator=(const SampleArrayValue& sampleArrayValue)
{
    m_metricQuality = sampleArrayValue.metricQuality();
    m_annotations = sampleArrayValue.annotations();
    m_startTime = sampleArrayValue.startTime();
    m_stopTime = sampleArrayValue.stopTime();
    m_determinationTime = sampleArrayValue.determinationTime();
    m_samples = sampleArrayValue.samples();
    m_extensions = sampleArrayValue.extensions();
    return *this;
}

inline SampleArrayValue SampleArrayValueBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return SampleArrayValue(m_metricQuality, m_annotations, m_startTime, m_stopTime, m_determinationTime, m_samples, m_extensions);
}

inline bool SampleArrayValueBuilder::isChanged(const SampleArrayValue& base) const
{
    return *this != base;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::metricQuality(const MetricQuality& metricQuality)
{
    m_metricQuality = metricQuality;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::metricQuality(MetricQuality&& metricQuality)
{
    m_metricQuality = std::move(metricQuality);
    return *this;
}

inline MetricQuality& SampleArrayValueBuilder::metricQuality()
{
    return m_metricQuality;
}

inline const MetricQuality& SampleArrayValueBuilder::metricQuality() const
{
    return m_metricQuality;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::annotations(const Annotations& annotations)
{
    m_annotations = annotations;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::annotations(Annotations&& annotations)
{
    m_annotations = std::move(annotations);
    return *this;
}

inline Annotations& SampleArrayValueBuilder::annotations()
{
    return m_annotations;
}

inline const Annotations& SampleArrayValueBuilder::annotations() const
{
    return m_annotations;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::startTime(const boost::optional<Timestamp>& startTime)
{
    m_startTime = startTime;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::startTime(boost::optional<Timestamp>&& startTime)
{
    m_startTime = std::move(startTime);
    return *this;
}

inline boost::optional<Timestamp>& SampleArrayValueBuilder::startTime()
{
    return m_startTime;
}

inline const boost::optional<Timestamp>& SampleArrayValueBuilder::startTime() const
{
    return m_startTime;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::stopTime(const boost::optional<Timestamp>& stopTime)
{
    m_stopTime = stopTime;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::stopTime(boost::optional<Timestamp>&& stopTime)
{
    m_stopTime = std::move(stopTime);
    return *this;
}

inline boost::optional<Timestamp>& SampleArrayValueBuilder::stopTime()
{
    return m_stopTime;
}

inline const boost::optional<Timestamp>& SampleArrayValueBuilder::stopTime() const
{
    return m_stopTime;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::determinationTime(const boost::optional<Timestamp>& determinationTime)
{
    m_determinationTime = determinationTime;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::determinationTime(boost::optional<Timestamp>&& determinationTime)
{
    m_determinationTime = std::move(determinationTime);
    return *this;
}

inline boost::optional<Timestamp>& SampleArrayValueBuilder::determinationTime()
{
    return m_determinationTime;
}

inline const boost::optional<Timestamp>& SampleArrayValueBuilder::determinationTime() const
{
    return m_determinationTime;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::samples(const Samples& samples)
{
    m_samples = samples;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::samples(Samples&& samples)
{
    m_samples = std::move(samples);
    return *this;
}

inline Samples& SampleArrayValueBuilder::samples()
{
    return m_samples;
}

inline const Samples& SampleArrayValueBuilder::samples() const
{
    return m_samples;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline SampleArrayValueBuilder& SampleArrayValueBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& SampleArrayValueBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& SampleArrayValueBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const SampleArrayValue& lhs, const SampleArrayValueBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const SampleArrayValueBuilder& lhs, const SampleArrayValueBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const SampleArrayValue& lhs, const SampleArrayValueBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const SampleArrayValueBuilder& lhs, const SampleArrayValue& rhs)
{
    return !(lhs == rhs);
}

inline SampleArrayValueBuilder getBuilder(const SampleArrayValue& sampleArrayValue)
{
    return SampleArrayValueBuilder(sampleArrayValue);
}

inline SampleArrayValueBuilder getBuilder(const DFL::NotNull<SharedPtr<SampleArrayValue>>& sampleArrayValue)
{
    return SampleArrayValueBuilder(sampleArrayValue);
}

}
}
