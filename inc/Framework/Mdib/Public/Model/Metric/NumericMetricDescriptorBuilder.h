/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/NumericMetricDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref NumericMetricDescriptor
 * @ingroup Mdib
 */
class NumericMetricDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref NumericMetricDescriptor
        using BuiltType = NumericMetricDescriptor;

        /// @brief Builder based on given immutable @ref NumericMetricDescriptor
        explicit NumericMetricDescriptorBuilder(const NumericMetricDescriptor& numericMetricDescriptor=NumericMetricDescriptor());

        /// @brief Builder based on given immutable @ref NumericMetricDescriptor
        explicit NumericMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<NumericMetricDescriptor>>& numericMetricDescriptor);

        /// @brief Overwrite all values with given immutable @ref NumericMetricDescriptor
        NumericMetricDescriptorBuilder& operator=(const NumericMetricDescriptor& numericMetricDescriptor);

        /// @brief Explicit conversion to immutable @ref NumericMetricDescriptor
        NumericMetricDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref NumericMetricDescriptor
        bool isChanged(const NumericMetricDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        NumericMetricDescriptorBuilder& safetyClassification(SafetyClassification safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        NumericMetricDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        NumericMetricDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for unit
        /// @{
        NumericMetricDescriptorBuilder& unit(const Unit& unit);
        NumericMetricDescriptorBuilder& unit(Unit&& unit);
        /// @}

        /// @brief Setter for bodySites
        /// @{
        NumericMetricDescriptorBuilder& bodySites(const BodySites& bodySites);
        NumericMetricDescriptorBuilder& bodySites(BodySites&& bodySites);
        /// @}

        /// @brief Setter for metricCategory
        /// @{
        NumericMetricDescriptorBuilder& metricCategory(MetricCategory metricCategory);
        /// @}

        /// @brief Setter for derivationMethod
        /// @{
        NumericMetricDescriptorBuilder& derivationMethod(boost::optional<DerivationMethod> derivationMethod);
        /// @}

        /// @brief Setter for metricAvailability
        /// @{
        NumericMetricDescriptorBuilder& metricAvailability(MetricAvailability metricAvailability);
        /// @}

        /// @brief Setter for maxMeasurementTime
        /// @{
        NumericMetricDescriptorBuilder& maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime);
        NumericMetricDescriptorBuilder& maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime);
        /// @}

        /// @brief Setter for maxDelayTime
        /// @{
        NumericMetricDescriptorBuilder& maxDelayTime(const boost::optional<Duration>& maxDelayTime);
        NumericMetricDescriptorBuilder& maxDelayTime(boost::optional<Duration>&& maxDelayTime);
        /// @}

        /// @brief Setter for determinationPeriod
        /// @{
        NumericMetricDescriptorBuilder& determinationPeriod(const boost::optional<Duration>& determinationPeriod);
        NumericMetricDescriptorBuilder& determinationPeriod(boost::optional<Duration>&& determinationPeriod);
        /// @}

        /// @brief Setter for lifeTimePeriod
        /// @{
        NumericMetricDescriptorBuilder& lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod);
        NumericMetricDescriptorBuilder& lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod);
        /// @}

        /// @brief Setter for activationDuration
        /// @{
        NumericMetricDescriptorBuilder& activationDuration(const boost::optional<Duration>& activationDuration);
        NumericMetricDescriptorBuilder& activationDuration(boost::optional<Duration>&& activationDuration);
        /// @}

        /// @brief Setter for relations
        /// @{
        NumericMetricDescriptorBuilder& relations(const Relations& relations);
        NumericMetricDescriptorBuilder& relations(Relations&& relations);
        /// @}

        /// @brief Setter for resolution
        /// @{
        NumericMetricDescriptorBuilder& resolution(Decimal resolution);
        /// @}

        /// @brief Setter for averagingPeriod
        /// @{
        NumericMetricDescriptorBuilder& averagingPeriod(const boost::optional<Duration>& averagingPeriod);
        NumericMetricDescriptorBuilder& averagingPeriod(boost::optional<Duration>&& averagingPeriod);
        /// @}

        /// @brief Setter for technicalRanges
        /// @{
        NumericMetricDescriptorBuilder& technicalRanges(const Ranges& technicalRanges);
        NumericMetricDescriptorBuilder& technicalRanges(Ranges&& technicalRanges);
        /// @}

        /// @brief Setter for extensions
        /// @{
        NumericMetricDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        NumericMetricDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        SafetyClassification& safetyClassification();
        SafetyClassification safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for unit
        /// @{
        Unit& unit();
        const Unit& unit() const;
        /// @}

        /// @brief Getter for bodySites
        /// @{
        BodySites& bodySites();
        const BodySites& bodySites() const;
        /// @}

        /// @brief Getter for metricCategory
        /// @{
        MetricCategory& metricCategory();
        MetricCategory metricCategory() const;
        /// @}

        /// @brief Getter for derivationMethod
        /// @{
        boost::optional<DerivationMethod>& derivationMethod();
        boost::optional<DerivationMethod> derivationMethod() const;
        /// @}

        /// @brief Getter for metricAvailability
        /// @{
        MetricAvailability& metricAvailability();
        MetricAvailability metricAvailability() const;
        /// @}

        /// @brief Getter for maxMeasurementTime
        /// @{
        boost::optional<Duration>& maxMeasurementTime();
        const boost::optional<Duration>& maxMeasurementTime() const;
        /// @}

        /// @brief Getter for maxDelayTime
        /// @{
        boost::optional<Duration>& maxDelayTime();
        const boost::optional<Duration>& maxDelayTime() const;
        /// @}

        /// @brief Getter for determinationPeriod
        /// @{
        boost::optional<Duration>& determinationPeriod();
        const boost::optional<Duration>& determinationPeriod() const;
        /// @}

        /// @brief Getter for lifeTimePeriod
        /// @{
        boost::optional<Duration>& lifeTimePeriod();
        const boost::optional<Duration>& lifeTimePeriod() const;
        /// @}

        /// @brief Getter for activationDuration
        /// @{
        boost::optional<Duration>& activationDuration();
        const boost::optional<Duration>& activationDuration() const;
        /// @}

        /// @brief Getter for relations
        /// @{
        Relations& relations();
        const Relations& relations() const;
        /// @}

        /// @brief Getter for resolution
        /// @{
        Decimal& resolution();
        Decimal resolution() const;
        /// @}

        /// @brief Getter for averagingPeriod
        /// @{
        boost::optional<Duration>& averagingPeriod();
        const boost::optional<Duration>& averagingPeriod() const;
        /// @}

        /// @brief Getter for technicalRanges
        /// @{
        Ranges& technicalRanges();
        const Ranges& technicalRanges() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        SafetyClassification m_safetyClassification;
        boost::optional<CodedValue> m_type;
        Unit m_unit;
        BodySites m_bodySites;
        MetricCategory m_metricCategory;
        boost::optional<DerivationMethod> m_derivationMethod;
        MetricAvailability m_metricAvailability;
        boost::optional<Duration> m_maxMeasurementTime;
        boost::optional<Duration> m_maxDelayTime;
        boost::optional<Duration> m_determinationPeriod;
        boost::optional<Duration> m_lifeTimePeriod;
        boost::optional<Duration> m_activationDuration;
        Relations m_relations;
        Decimal m_resolution;
        boost::optional<Duration> m_averagingPeriod;
        Ranges m_technicalRanges;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const NumericMetricDescriptor& lhs, const NumericMetricDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptor& rhs);
bool operator==(const NumericMetricDescriptor& lhs, const NumericMetricDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const NumericMetricDescriptor& lhs, const NumericMetricDescriptor& rhs);
bool operator!=(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptorBuilder& rhs);
bool operator!=(const NumericMetricDescriptor& lhs, const NumericMetricDescriptorBuilder& rhs);
bool operator!=(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref NumericMetricDescriptor
 * @ingroup Mdib
 */
/// @{
NumericMetricDescriptorBuilder getBuilder(const NumericMetricDescriptor& numericMetricDescriptor);
NumericMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<NumericMetricDescriptor>>& numericMetricDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const NumericMetricDescriptor& lhs, const NumericMetricDescriptor& rhs);

inline NumericMetricDescriptorBuilder::NumericMetricDescriptorBuilder(const NumericMetricDescriptor& numericMetricDescriptor) :
    m_safetyClassification(numericMetricDescriptor.safetyClassification()),
    m_type(numericMetricDescriptor.type()),
    m_unit(numericMetricDescriptor.unit()),
    m_bodySites(numericMetricDescriptor.bodySites()),
    m_metricCategory(numericMetricDescriptor.metricCategory()),
    m_derivationMethod(numericMetricDescriptor.derivationMethod()),
    m_metricAvailability(numericMetricDescriptor.metricAvailability()),
    m_maxMeasurementTime(numericMetricDescriptor.maxMeasurementTime()),
    m_maxDelayTime(numericMetricDescriptor.maxDelayTime()),
    m_determinationPeriod(numericMetricDescriptor.determinationPeriod()),
    m_lifeTimePeriod(numericMetricDescriptor.lifeTimePeriod()),
    m_activationDuration(numericMetricDescriptor.activationDuration()),
    m_relations(numericMetricDescriptor.relations()),
    m_resolution(numericMetricDescriptor.resolution()),
    m_averagingPeriod(numericMetricDescriptor.averagingPeriod()),
    m_technicalRanges(numericMetricDescriptor.technicalRanges()),
    m_extensions(numericMetricDescriptor.extensions())
{
}

inline NumericMetricDescriptorBuilder::NumericMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<NumericMetricDescriptor>>& numericMetricDescriptor) :
    m_safetyClassification(numericMetricDescriptor->safetyClassification()),
    m_type(numericMetricDescriptor->type()),
    m_unit(numericMetricDescriptor->unit()),
    m_bodySites(numericMetricDescriptor->bodySites()),
    m_metricCategory(numericMetricDescriptor->metricCategory()),
    m_derivationMethod(numericMetricDescriptor->derivationMethod()),
    m_metricAvailability(numericMetricDescriptor->metricAvailability()),
    m_maxMeasurementTime(numericMetricDescriptor->maxMeasurementTime()),
    m_maxDelayTime(numericMetricDescriptor->maxDelayTime()),
    m_determinationPeriod(numericMetricDescriptor->determinationPeriod()),
    m_lifeTimePeriod(numericMetricDescriptor->lifeTimePeriod()),
    m_activationDuration(numericMetricDescriptor->activationDuration()),
    m_relations(numericMetricDescriptor->relations()),
    m_resolution(numericMetricDescriptor->resolution()),
    m_averagingPeriod(numericMetricDescriptor->averagingPeriod()),
    m_technicalRanges(numericMetricDescriptor->technicalRanges()),
    m_extensions(numericMetricDescriptor->extensions())
{
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::operator=(const NumericMetricDescriptor& numericMetricDescriptor)
{
    m_safetyClassification = numericMetricDescriptor.safetyClassification();
    m_type = numericMetricDescriptor.type();
    m_unit = numericMetricDescriptor.unit();
    m_bodySites = numericMetricDescriptor.bodySites();
    m_metricCategory = numericMetricDescriptor.metricCategory();
    m_derivationMethod = numericMetricDescriptor.derivationMethod();
    m_metricAvailability = numericMetricDescriptor.metricAvailability();
    m_maxMeasurementTime = numericMetricDescriptor.maxMeasurementTime();
    m_maxDelayTime = numericMetricDescriptor.maxDelayTime();
    m_determinationPeriod = numericMetricDescriptor.determinationPeriod();
    m_lifeTimePeriod = numericMetricDescriptor.lifeTimePeriod();
    m_activationDuration = numericMetricDescriptor.activationDuration();
    m_relations = numericMetricDescriptor.relations();
    m_resolution = numericMetricDescriptor.resolution();
    m_averagingPeriod = numericMetricDescriptor.averagingPeriod();
    m_technicalRanges = numericMetricDescriptor.technicalRanges();
    m_extensions = numericMetricDescriptor.extensions();
    return *this;
}

inline NumericMetricDescriptor NumericMetricDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return NumericMetricDescriptor(m_safetyClassification, m_type, m_unit, m_bodySites, m_metricCategory, m_derivationMethod, m_metricAvailability, m_maxMeasurementTime, m_maxDelayTime, m_determinationPeriod, m_lifeTimePeriod, m_activationDuration, m_relations, m_resolution, m_averagingPeriod, m_technicalRanges, m_extensions);
}

inline bool NumericMetricDescriptorBuilder::isChanged(const NumericMetricDescriptor& base) const
{
    return *this != base;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::safetyClassification(SafetyClassification safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline SafetyClassification& NumericMetricDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline SafetyClassification NumericMetricDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& NumericMetricDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& NumericMetricDescriptorBuilder::type() const
{
    return m_type;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::unit(const Unit& unit)
{
    m_unit = unit;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::unit(Unit&& unit)
{
    m_unit = std::move(unit);
    return *this;
}

inline Unit& NumericMetricDescriptorBuilder::unit()
{
    return m_unit;
}

inline const Unit& NumericMetricDescriptorBuilder::unit() const
{
    return m_unit;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::bodySites(const BodySites& bodySites)
{
    m_bodySites = bodySites;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::bodySites(BodySites&& bodySites)
{
    m_bodySites = std::move(bodySites);
    return *this;
}

inline BodySites& NumericMetricDescriptorBuilder::bodySites()
{
    return m_bodySites;
}

inline const BodySites& NumericMetricDescriptorBuilder::bodySites() const
{
    return m_bodySites;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::metricCategory(MetricCategory metricCategory)
{
    m_metricCategory = metricCategory;
    return *this;
}

inline MetricCategory& NumericMetricDescriptorBuilder::metricCategory()
{
    return m_metricCategory;
}

inline MetricCategory NumericMetricDescriptorBuilder::metricCategory() const
{
    return m_metricCategory;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::derivationMethod(boost::optional<DerivationMethod> derivationMethod)
{
    m_derivationMethod = derivationMethod;
    return *this;
}

inline boost::optional<DerivationMethod>& NumericMetricDescriptorBuilder::derivationMethod()
{
    return m_derivationMethod;
}

inline boost::optional<DerivationMethod> NumericMetricDescriptorBuilder::derivationMethod() const
{
    return m_derivationMethod;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::metricAvailability(MetricAvailability metricAvailability)
{
    m_metricAvailability = metricAvailability;
    return *this;
}

inline MetricAvailability& NumericMetricDescriptorBuilder::metricAvailability()
{
    return m_metricAvailability;
}

inline MetricAvailability NumericMetricDescriptorBuilder::metricAvailability() const
{
    return m_metricAvailability;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime)
{
    m_maxMeasurementTime = maxMeasurementTime;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime)
{
    m_maxMeasurementTime = std::move(maxMeasurementTime);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::maxMeasurementTime()
{
    return m_maxMeasurementTime;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::maxMeasurementTime() const
{
    return m_maxMeasurementTime;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::maxDelayTime(const boost::optional<Duration>& maxDelayTime)
{
    m_maxDelayTime = maxDelayTime;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::maxDelayTime(boost::optional<Duration>&& maxDelayTime)
{
    m_maxDelayTime = std::move(maxDelayTime);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::maxDelayTime()
{
    return m_maxDelayTime;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::maxDelayTime() const
{
    return m_maxDelayTime;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::determinationPeriod(const boost::optional<Duration>& determinationPeriod)
{
    m_determinationPeriod = determinationPeriod;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::determinationPeriod(boost::optional<Duration>&& determinationPeriod)
{
    m_determinationPeriod = std::move(determinationPeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::determinationPeriod()
{
    return m_determinationPeriod;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::determinationPeriod() const
{
    return m_determinationPeriod;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod)
{
    m_lifeTimePeriod = lifeTimePeriod;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod)
{
    m_lifeTimePeriod = std::move(lifeTimePeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::lifeTimePeriod()
{
    return m_lifeTimePeriod;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::lifeTimePeriod() const
{
    return m_lifeTimePeriod;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::activationDuration(const boost::optional<Duration>& activationDuration)
{
    m_activationDuration = activationDuration;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::activationDuration(boost::optional<Duration>&& activationDuration)
{
    m_activationDuration = std::move(activationDuration);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::activationDuration()
{
    return m_activationDuration;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::activationDuration() const
{
    return m_activationDuration;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::relations(const Relations& relations)
{
    m_relations = relations;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::relations(Relations&& relations)
{
    m_relations = std::move(relations);
    return *this;
}

inline Relations& NumericMetricDescriptorBuilder::relations()
{
    return m_relations;
}

inline const Relations& NumericMetricDescriptorBuilder::relations() const
{
    return m_relations;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::resolution(Decimal resolution)
{
    m_resolution = resolution;
    return *this;
}

inline Decimal& NumericMetricDescriptorBuilder::resolution()
{
    return m_resolution;
}

inline Decimal NumericMetricDescriptorBuilder::resolution() const
{
    return m_resolution;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::averagingPeriod(const boost::optional<Duration>& averagingPeriod)
{
    m_averagingPeriod = averagingPeriod;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::averagingPeriod(boost::optional<Duration>&& averagingPeriod)
{
    m_averagingPeriod = std::move(averagingPeriod);
    return *this;
}

inline boost::optional<Duration>& NumericMetricDescriptorBuilder::averagingPeriod()
{
    return m_averagingPeriod;
}

inline const boost::optional<Duration>& NumericMetricDescriptorBuilder::averagingPeriod() const
{
    return m_averagingPeriod;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::technicalRanges(const Ranges& technicalRanges)
{
    m_technicalRanges = technicalRanges;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::technicalRanges(Ranges&& technicalRanges)
{
    m_technicalRanges = std::move(technicalRanges);
    return *this;
}

inline Ranges& NumericMetricDescriptorBuilder::technicalRanges()
{
    return m_technicalRanges;
}

inline const Ranges& NumericMetricDescriptorBuilder::technicalRanges() const
{
    return m_technicalRanges;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline NumericMetricDescriptorBuilder& NumericMetricDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& NumericMetricDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& NumericMetricDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const NumericMetricDescriptor& lhs, const NumericMetricDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const NumericMetricDescriptor& lhs, const NumericMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const NumericMetricDescriptorBuilder& lhs, const NumericMetricDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline NumericMetricDescriptorBuilder getBuilder(const NumericMetricDescriptor& numericMetricDescriptor)
{
    return NumericMetricDescriptorBuilder(numericMetricDescriptor);
}

inline NumericMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<NumericMetricDescriptor>>& numericMetricDescriptor)
{
    return NumericMetricDescriptorBuilder(numericMetricDescriptor);
}

}
}
