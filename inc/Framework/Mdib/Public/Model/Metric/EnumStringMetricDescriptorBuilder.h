/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Metric/EnumStringMetricDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref EnumStringMetricDescriptor
 * @ingroup Mdib
 */
class EnumStringMetricDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref EnumStringMetricDescriptor
        using BuiltType = EnumStringMetricDescriptor;

        /// @brief Builder based on given immutable @ref EnumStringMetricDescriptor
        explicit EnumStringMetricDescriptorBuilder(const EnumStringMetricDescriptor& enumStringMetricDescriptor=EnumStringMetricDescriptor());

        /// @brief Builder based on given immutable @ref EnumStringMetricDescriptor
        explicit EnumStringMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<EnumStringMetricDescriptor>>& enumStringMetricDescriptor);

        /// @brief Overwrite all values with given immutable @ref EnumStringMetricDescriptor
        EnumStringMetricDescriptorBuilder& operator=(const EnumStringMetricDescriptor& enumStringMetricDescriptor);

        /// @brief Explicit conversion to immutable @ref EnumStringMetricDescriptor
        EnumStringMetricDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref EnumStringMetricDescriptor
        bool isChanged(const EnumStringMetricDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        EnumStringMetricDescriptorBuilder& safetyClassification(SafetyClassification safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        EnumStringMetricDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        EnumStringMetricDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for unit
        /// @{
        EnumStringMetricDescriptorBuilder& unit(const Unit& unit);
        EnumStringMetricDescriptorBuilder& unit(Unit&& unit);
        /// @}

        /// @brief Setter for bodySites
        /// @{
        EnumStringMetricDescriptorBuilder& bodySites(const BodySites& bodySites);
        EnumStringMetricDescriptorBuilder& bodySites(BodySites&& bodySites);
        /// @}

        /// @brief Setter for metricCategory
        /// @{
        EnumStringMetricDescriptorBuilder& metricCategory(MetricCategory metricCategory);
        /// @}

        /// @brief Setter for derivationMethod
        /// @{
        EnumStringMetricDescriptorBuilder& derivationMethod(boost::optional<DerivationMethod> derivationMethod);
        /// @}

        /// @brief Setter for metricAvailability
        /// @{
        EnumStringMetricDescriptorBuilder& metricAvailability(MetricAvailability metricAvailability);
        /// @}

        /// @brief Setter for maxMeasurementTime
        /// @{
        EnumStringMetricDescriptorBuilder& maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime);
        EnumStringMetricDescriptorBuilder& maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime);
        /// @}

        /// @brief Setter for maxDelayTime
        /// @{
        EnumStringMetricDescriptorBuilder& maxDelayTime(const boost::optional<Duration>& maxDelayTime);
        EnumStringMetricDescriptorBuilder& maxDelayTime(boost::optional<Duration>&& maxDelayTime);
        /// @}

        /// @brief Setter for determinationPeriod
        /// @{
        EnumStringMetricDescriptorBuilder& determinationPeriod(const boost::optional<Duration>& determinationPeriod);
        EnumStringMetricDescriptorBuilder& determinationPeriod(boost::optional<Duration>&& determinationPeriod);
        /// @}

        /// @brief Setter for lifeTimePeriod
        /// @{
        EnumStringMetricDescriptorBuilder& lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod);
        EnumStringMetricDescriptorBuilder& lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod);
        /// @}

        /// @brief Setter for activationDuration
        /// @{
        EnumStringMetricDescriptorBuilder& activationDuration(const boost::optional<Duration>& activationDuration);
        EnumStringMetricDescriptorBuilder& activationDuration(boost::optional<Duration>&& activationDuration);
        /// @}

        /// @brief Setter for relations
        /// @{
        EnumStringMetricDescriptorBuilder& relations(const Relations& relations);
        EnumStringMetricDescriptorBuilder& relations(Relations&& relations);
        /// @}

        /// @brief Setter for allowedValues
        /// @{
        EnumStringMetricDescriptorBuilder& allowedValues(const AllowedEnumValues& allowedValues);
        EnumStringMetricDescriptorBuilder& allowedValues(AllowedEnumValues&& allowedValues);
        /// @}

        /// @brief Setter for extensions
        /// @{
        EnumStringMetricDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        EnumStringMetricDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        SafetyClassification& safetyClassification();
        SafetyClassification safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for unit
        /// @{
        Unit& unit();
        const Unit& unit() const;
        /// @}

        /// @brief Getter for bodySites
        /// @{
        BodySites& bodySites();
        const BodySites& bodySites() const;
        /// @}

        /// @brief Getter for metricCategory
        /// @{
        MetricCategory& metricCategory();
        MetricCategory metricCategory() const;
        /// @}

        /// @brief Getter for derivationMethod
        /// @{
        boost::optional<DerivationMethod>& derivationMethod();
        boost::optional<DerivationMethod> derivationMethod() const;
        /// @}

        /// @brief Getter for metricAvailability
        /// @{
        MetricAvailability& metricAvailability();
        MetricAvailability metricAvailability() const;
        /// @}

        /// @brief Getter for maxMeasurementTime
        /// @{
        boost::optional<Duration>& maxMeasurementTime();
        const boost::optional<Duration>& maxMeasurementTime() const;
        /// @}

        /// @brief Getter for maxDelayTime
        /// @{
        boost::optional<Duration>& maxDelayTime();
        const boost::optional<Duration>& maxDelayTime() const;
        /// @}

        /// @brief Getter for determinationPeriod
        /// @{
        boost::optional<Duration>& determinationPeriod();
        const boost::optional<Duration>& determinationPeriod() const;
        /// @}

        /// @brief Getter for lifeTimePeriod
        /// @{
        boost::optional<Duration>& lifeTimePeriod();
        const boost::optional<Duration>& lifeTimePeriod() const;
        /// @}

        /// @brief Getter for activationDuration
        /// @{
        boost::optional<Duration>& activationDuration();
        const boost::optional<Duration>& activationDuration() const;
        /// @}

        /// @brief Getter for relations
        /// @{
        Relations& relations();
        const Relations& relations() const;
        /// @}

        /// @brief Getter for allowedValues
        /// @{
        AllowedEnumValues& allowedValues();
        const AllowedEnumValues& allowedValues() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        SafetyClassification m_safetyClassification;
        boost::optional<CodedValue> m_type;
        Unit m_unit;
        BodySites m_bodySites;
        MetricCategory m_metricCategory;
        boost::optional<DerivationMethod> m_derivationMethod;
        MetricAvailability m_metricAvailability;
        boost::optional<Duration> m_maxMeasurementTime;
        boost::optional<Duration> m_maxDelayTime;
        boost::optional<Duration> m_determinationPeriod;
        boost::optional<Duration> m_lifeTimePeriod;
        boost::optional<Duration> m_activationDuration;
        Relations m_relations;
        AllowedEnumValues m_allowedValues;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptor& rhs);
bool operator==(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptor& rhs);
bool operator!=(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptorBuilder& rhs);
bool operator!=(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptorBuilder& rhs);
bool operator!=(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref EnumStringMetricDescriptor
 * @ingroup Mdib
 */
/// @{
EnumStringMetricDescriptorBuilder getBuilder(const EnumStringMetricDescriptor& enumStringMetricDescriptor);
EnumStringMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<EnumStringMetricDescriptor>>& enumStringMetricDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptor& rhs);

inline EnumStringMetricDescriptorBuilder::EnumStringMetricDescriptorBuilder(const EnumStringMetricDescriptor& enumStringMetricDescriptor) :
    m_safetyClassification(enumStringMetricDescriptor.safetyClassification()),
    m_type(enumStringMetricDescriptor.type()),
    m_unit(enumStringMetricDescriptor.unit()),
    m_bodySites(enumStringMetricDescriptor.bodySites()),
    m_metricCategory(enumStringMetricDescriptor.metricCategory()),
    m_derivationMethod(enumStringMetricDescriptor.derivationMethod()),
    m_metricAvailability(enumStringMetricDescriptor.metricAvailability()),
    m_maxMeasurementTime(enumStringMetricDescriptor.maxMeasurementTime()),
    m_maxDelayTime(enumStringMetricDescriptor.maxDelayTime()),
    m_determinationPeriod(enumStringMetricDescriptor.determinationPeriod()),
    m_lifeTimePeriod(enumStringMetricDescriptor.lifeTimePeriod()),
    m_activationDuration(enumStringMetricDescriptor.activationDuration()),
    m_relations(enumStringMetricDescriptor.relations()),
    m_allowedValues(enumStringMetricDescriptor.allowedValues()),
    m_extensions(enumStringMetricDescriptor.extensions())
{
}

inline EnumStringMetricDescriptorBuilder::EnumStringMetricDescriptorBuilder(const DFL::NotNull<SharedPtr<EnumStringMetricDescriptor>>& enumStringMetricDescriptor) :
    m_safetyClassification(enumStringMetricDescriptor->safetyClassification()),
    m_type(enumStringMetricDescriptor->type()),
    m_unit(enumStringMetricDescriptor->unit()),
    m_bodySites(enumStringMetricDescriptor->bodySites()),
    m_metricCategory(enumStringMetricDescriptor->metricCategory()),
    m_derivationMethod(enumStringMetricDescriptor->derivationMethod()),
    m_metricAvailability(enumStringMetricDescriptor->metricAvailability()),
    m_maxMeasurementTime(enumStringMetricDescriptor->maxMeasurementTime()),
    m_maxDelayTime(enumStringMetricDescriptor->maxDelayTime()),
    m_determinationPeriod(enumStringMetricDescriptor->determinationPeriod()),
    m_lifeTimePeriod(enumStringMetricDescriptor->lifeTimePeriod()),
    m_activationDuration(enumStringMetricDescriptor->activationDuration()),
    m_relations(enumStringMetricDescriptor->relations()),
    m_allowedValues(enumStringMetricDescriptor->allowedValues()),
    m_extensions(enumStringMetricDescriptor->extensions())
{
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::operator=(const EnumStringMetricDescriptor& enumStringMetricDescriptor)
{
    m_safetyClassification = enumStringMetricDescriptor.safetyClassification();
    m_type = enumStringMetricDescriptor.type();
    m_unit = enumStringMetricDescriptor.unit();
    m_bodySites = enumStringMetricDescriptor.bodySites();
    m_metricCategory = enumStringMetricDescriptor.metricCategory();
    m_derivationMethod = enumStringMetricDescriptor.derivationMethod();
    m_metricAvailability = enumStringMetricDescriptor.metricAvailability();
    m_maxMeasurementTime = enumStringMetricDescriptor.maxMeasurementTime();
    m_maxDelayTime = enumStringMetricDescriptor.maxDelayTime();
    m_determinationPeriod = enumStringMetricDescriptor.determinationPeriod();
    m_lifeTimePeriod = enumStringMetricDescriptor.lifeTimePeriod();
    m_activationDuration = enumStringMetricDescriptor.activationDuration();
    m_relations = enumStringMetricDescriptor.relations();
    m_allowedValues = enumStringMetricDescriptor.allowedValues();
    m_extensions = enumStringMetricDescriptor.extensions();
    return *this;
}

inline EnumStringMetricDescriptor EnumStringMetricDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return EnumStringMetricDescriptor(m_safetyClassification, m_type, m_unit, m_bodySites, m_metricCategory, m_derivationMethod, m_metricAvailability, m_maxMeasurementTime, m_maxDelayTime, m_determinationPeriod, m_lifeTimePeriod, m_activationDuration, m_relations, m_allowedValues, m_extensions);
}

inline bool EnumStringMetricDescriptorBuilder::isChanged(const EnumStringMetricDescriptor& base) const
{
    return *this != base;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::safetyClassification(SafetyClassification safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline SafetyClassification& EnumStringMetricDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline SafetyClassification EnumStringMetricDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& EnumStringMetricDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& EnumStringMetricDescriptorBuilder::type() const
{
    return m_type;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::unit(const Unit& unit)
{
    m_unit = unit;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::unit(Unit&& unit)
{
    m_unit = std::move(unit);
    return *this;
}

inline Unit& EnumStringMetricDescriptorBuilder::unit()
{
    return m_unit;
}

inline const Unit& EnumStringMetricDescriptorBuilder::unit() const
{
    return m_unit;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::bodySites(const BodySites& bodySites)
{
    m_bodySites = bodySites;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::bodySites(BodySites&& bodySites)
{
    m_bodySites = std::move(bodySites);
    return *this;
}

inline BodySites& EnumStringMetricDescriptorBuilder::bodySites()
{
    return m_bodySites;
}

inline const BodySites& EnumStringMetricDescriptorBuilder::bodySites() const
{
    return m_bodySites;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::metricCategory(MetricCategory metricCategory)
{
    m_metricCategory = metricCategory;
    return *this;
}

inline MetricCategory& EnumStringMetricDescriptorBuilder::metricCategory()
{
    return m_metricCategory;
}

inline MetricCategory EnumStringMetricDescriptorBuilder::metricCategory() const
{
    return m_metricCategory;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::derivationMethod(boost::optional<DerivationMethod> derivationMethod)
{
    m_derivationMethod = derivationMethod;
    return *this;
}

inline boost::optional<DerivationMethod>& EnumStringMetricDescriptorBuilder::derivationMethod()
{
    return m_derivationMethod;
}

inline boost::optional<DerivationMethod> EnumStringMetricDescriptorBuilder::derivationMethod() const
{
    return m_derivationMethod;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::metricAvailability(MetricAvailability metricAvailability)
{
    m_metricAvailability = metricAvailability;
    return *this;
}

inline MetricAvailability& EnumStringMetricDescriptorBuilder::metricAvailability()
{
    return m_metricAvailability;
}

inline MetricAvailability EnumStringMetricDescriptorBuilder::metricAvailability() const
{
    return m_metricAvailability;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::maxMeasurementTime(const boost::optional<Duration>& maxMeasurementTime)
{
    m_maxMeasurementTime = maxMeasurementTime;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::maxMeasurementTime(boost::optional<Duration>&& maxMeasurementTime)
{
    m_maxMeasurementTime = std::move(maxMeasurementTime);
    return *this;
}

inline boost::optional<Duration>& EnumStringMetricDescriptorBuilder::maxMeasurementTime()
{
    return m_maxMeasurementTime;
}

inline const boost::optional<Duration>& EnumStringMetricDescriptorBuilder::maxMeasurementTime() const
{
    return m_maxMeasurementTime;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::maxDelayTime(const boost::optional<Duration>& maxDelayTime)
{
    m_maxDelayTime = maxDelayTime;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::maxDelayTime(boost::optional<Duration>&& maxDelayTime)
{
    m_maxDelayTime = std::move(maxDelayTime);
    return *this;
}

inline boost::optional<Duration>& EnumStringMetricDescriptorBuilder::maxDelayTime()
{
    return m_maxDelayTime;
}

inline const boost::optional<Duration>& EnumStringMetricDescriptorBuilder::maxDelayTime() const
{
    return m_maxDelayTime;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::determinationPeriod(const boost::optional<Duration>& determinationPeriod)
{
    m_determinationPeriod = determinationPeriod;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::determinationPeriod(boost::optional<Duration>&& determinationPeriod)
{
    m_determinationPeriod = std::move(determinationPeriod);
    return *this;
}

inline boost::optional<Duration>& EnumStringMetricDescriptorBuilder::determinationPeriod()
{
    return m_determinationPeriod;
}

inline const boost::optional<Duration>& EnumStringMetricDescriptorBuilder::determinationPeriod() const
{
    return m_determinationPeriod;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::lifeTimePeriod(const boost::optional<Duration>& lifeTimePeriod)
{
    m_lifeTimePeriod = lifeTimePeriod;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::lifeTimePeriod(boost::optional<Duration>&& lifeTimePeriod)
{
    m_lifeTimePeriod = std::move(lifeTimePeriod);
    return *this;
}

inline boost::optional<Duration>& EnumStringMetricDescriptorBuilder::lifeTimePeriod()
{
    return m_lifeTimePeriod;
}

inline const boost::optional<Duration>& EnumStringMetricDescriptorBuilder::lifeTimePeriod() const
{
    return m_lifeTimePeriod;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::activationDuration(const boost::optional<Duration>& activationDuration)
{
    m_activationDuration = activationDuration;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::activationDuration(boost::optional<Duration>&& activationDuration)
{
    m_activationDuration = std::move(activationDuration);
    return *this;
}

inline boost::optional<Duration>& EnumStringMetricDescriptorBuilder::activationDuration()
{
    return m_activationDuration;
}

inline const boost::optional<Duration>& EnumStringMetricDescriptorBuilder::activationDuration() const
{
    return m_activationDuration;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::relations(const Relations& relations)
{
    m_relations = relations;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::relations(Relations&& relations)
{
    m_relations = std::move(relations);
    return *this;
}

inline Relations& EnumStringMetricDescriptorBuilder::relations()
{
    return m_relations;
}

inline const Relations& EnumStringMetricDescriptorBuilder::relations() const
{
    return m_relations;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::allowedValues(const AllowedEnumValues& allowedValues)
{
    m_allowedValues = allowedValues;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::allowedValues(AllowedEnumValues&& allowedValues)
{
    m_allowedValues = std::move(allowedValues);
    return *this;
}

inline AllowedEnumValues& EnumStringMetricDescriptorBuilder::allowedValues()
{
    return m_allowedValues;
}

inline const AllowedEnumValues& EnumStringMetricDescriptorBuilder::allowedValues() const
{
    return m_allowedValues;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline EnumStringMetricDescriptorBuilder& EnumStringMetricDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& EnumStringMetricDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& EnumStringMetricDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const EnumStringMetricDescriptor& lhs, const EnumStringMetricDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const EnumStringMetricDescriptorBuilder& lhs, const EnumStringMetricDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline EnumStringMetricDescriptorBuilder getBuilder(const EnumStringMetricDescriptor& enumStringMetricDescriptor)
{
    return EnumStringMetricDescriptorBuilder(enumStringMetricDescriptor);
}

inline EnumStringMetricDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<EnumStringMetricDescriptor>>& enumStringMetricDescriptor)
{
    return EnumStringMetricDescriptorBuilder(enumStringMetricDescriptor);
}

}
}
