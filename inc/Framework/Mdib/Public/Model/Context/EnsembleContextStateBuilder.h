/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Context/EnsembleContextState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref EnsembleContextState
 * @ingroup Mdib
 */
class EnsembleContextStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref EnsembleContextState
        using BuiltType = EnsembleContextState;

        /// @brief Builder based on given immutable @ref EnsembleContextState
        explicit EnsembleContextStateBuilder(const EnsembleContextState& ensembleContextState=EnsembleContextState());

        /// @brief Builder based on given immutable @ref EnsembleContextState
        explicit EnsembleContextStateBuilder(const DFL::NotNull<SharedPtr<EnsembleContextState>>& ensembleContextState);

        /// @brief Overwrite all values with given immutable @ref EnsembleContextState
        EnsembleContextStateBuilder& operator=(const EnsembleContextState& ensembleContextState);

        /// @brief Explicit conversion to immutable @ref EnsembleContextState
        EnsembleContextState build() const;

        /// @brief Test whether the builder differs from the immutable @ref EnsembleContextState
        bool isChanged(const EnsembleContextState& base) const;

        /// @brief Setter for category
        /// @{
        EnsembleContextStateBuilder& category(const boost::optional<CodedValue>& category);
        EnsembleContextStateBuilder& category(boost::optional<CodedValue>&& category);
        /// @}

        /// @brief Setter for contextAssociation
        /// @{
        EnsembleContextStateBuilder& contextAssociation(ContextAssociation contextAssociation);
        /// @}

        /// @brief Setter for bindingMdibVersion
        /// @{
        EnsembleContextStateBuilder& bindingMdibVersion(const boost::optional<VersionCounter>& bindingMdibVersion);
        EnsembleContextStateBuilder& bindingMdibVersion(boost::optional<VersionCounter>&& bindingMdibVersion);
        /// @}

        /// @brief Setter for unbindingMdibVersion
        /// @{
        EnsembleContextStateBuilder& unbindingMdibVersion(const boost::optional<VersionCounter>& unbindingMdibVersion);
        EnsembleContextStateBuilder& unbindingMdibVersion(boost::optional<VersionCounter>&& unbindingMdibVersion);
        /// @}

        /// @brief Setter for bindingStartTime
        /// @{
        EnsembleContextStateBuilder& bindingStartTime(const boost::optional<Timestamp>& bindingStartTime);
        EnsembleContextStateBuilder& bindingStartTime(boost::optional<Timestamp>&& bindingStartTime);
        /// @}

        /// @brief Setter for bindingEndTime
        /// @{
        EnsembleContextStateBuilder& bindingEndTime(const boost::optional<Timestamp>& bindingEndTime);
        EnsembleContextStateBuilder& bindingEndTime(boost::optional<Timestamp>&& bindingEndTime);
        /// @}

        /// @brief Setter for validators
        /// @{
        EnsembleContextStateBuilder& validators(const InstanceIdentifiers& validators);
        EnsembleContextStateBuilder& validators(InstanceIdentifiers&& validators);
        /// @}

        /// @brief Setter for identifications
        /// @{
        EnsembleContextStateBuilder& identifications(const InstanceIdentifiers& identifications);
        EnsembleContextStateBuilder& identifications(InstanceIdentifiers&& identifications);
        /// @}

        /// @brief Setter for extensions
        /// @{
        EnsembleContextStateBuilder& extensions(const ExtensionTypes& extensions);
        EnsembleContextStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for category
        /// @{
        boost::optional<CodedValue>& category();
        const boost::optional<CodedValue>& category() const;
        /// @}

        /// @brief Getter for contextAssociation
        /// @{
        ContextAssociation& contextAssociation();
        ContextAssociation contextAssociation() const;
        /// @}

        /// @brief Getter for bindingMdibVersion
        /// @{
        boost::optional<VersionCounter>& bindingMdibVersion();
        const boost::optional<VersionCounter>& bindingMdibVersion() const;
        /// @}

        /// @brief Getter for unbindingMdibVersion
        /// @{
        boost::optional<VersionCounter>& unbindingMdibVersion();
        const boost::optional<VersionCounter>& unbindingMdibVersion() const;
        /// @}

        /// @brief Getter for bindingStartTime
        /// @{
        boost::optional<Timestamp>& bindingStartTime();
        const boost::optional<Timestamp>& bindingStartTime() const;
        /// @}

        /// @brief Getter for bindingEndTime
        /// @{
        boost::optional<Timestamp>& bindingEndTime();
        const boost::optional<Timestamp>& bindingEndTime() const;
        /// @}

        /// @brief Getter for validators
        /// @{
        InstanceIdentifiers& validators();
        const InstanceIdentifiers& validators() const;
        /// @}

        /// @brief Getter for identifications
        /// @{
        InstanceIdentifiers& identifications();
        const InstanceIdentifiers& identifications() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        boost::optional<CodedValue> m_category;
        ContextAssociation m_contextAssociation;
        boost::optional<VersionCounter> m_bindingMdibVersion;
        boost::optional<VersionCounter> m_unbindingMdibVersion;
        boost::optional<Timestamp> m_bindingStartTime;
        boost::optional<Timestamp> m_bindingEndTime;
        InstanceIdentifiers m_validators;
        InstanceIdentifiers m_identifications;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const EnsembleContextState& lhs, const EnsembleContextState& rhs);
DFL_MDIB_EXPIMP bool operator==(const EnsembleContextStateBuilder& lhs, const EnsembleContextStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const EnsembleContextStateBuilder& lhs, const EnsembleContextState& rhs);
bool operator==(const EnsembleContextState& lhs, const EnsembleContextStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const EnsembleContextState& lhs, const EnsembleContextState& rhs);
bool operator!=(const EnsembleContextStateBuilder& lhs, const EnsembleContextStateBuilder& rhs);
bool operator!=(const EnsembleContextState& lhs, const EnsembleContextStateBuilder& rhs);
bool operator!=(const EnsembleContextStateBuilder& lhs, const EnsembleContextState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref EnsembleContextState
 * @ingroup Mdib
 */
/// @{
EnsembleContextStateBuilder getBuilder(const EnsembleContextState& ensembleContextState);
EnsembleContextStateBuilder getBuilder(const DFL::NotNull<SharedPtr<EnsembleContextState>>& ensembleContextState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const EnsembleContextState& lhs, const EnsembleContextState& rhs);

inline EnsembleContextStateBuilder::EnsembleContextStateBuilder(const EnsembleContextState& ensembleContextState) :
    m_category(ensembleContextState.category()),
    m_contextAssociation(ensembleContextState.contextAssociation()),
    m_bindingMdibVersion(ensembleContextState.bindingMdibVersion()),
    m_unbindingMdibVersion(ensembleContextState.unbindingMdibVersion()),
    m_bindingStartTime(ensembleContextState.bindingStartTime()),
    m_bindingEndTime(ensembleContextState.bindingEndTime()),
    m_validators(ensembleContextState.validators()),
    m_identifications(ensembleContextState.identifications()),
    m_extensions(ensembleContextState.extensions())
{
}

inline EnsembleContextStateBuilder::EnsembleContextStateBuilder(const DFL::NotNull<SharedPtr<EnsembleContextState>>& ensembleContextState) :
    m_category(ensembleContextState->category()),
    m_contextAssociation(ensembleContextState->contextAssociation()),
    m_bindingMdibVersion(ensembleContextState->bindingMdibVersion()),
    m_unbindingMdibVersion(ensembleContextState->unbindingMdibVersion()),
    m_bindingStartTime(ensembleContextState->bindingStartTime()),
    m_bindingEndTime(ensembleContextState->bindingEndTime()),
    m_validators(ensembleContextState->validators()),
    m_identifications(ensembleContextState->identifications()),
    m_extensions(ensembleContextState->extensions())
{
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::operator=(const EnsembleContextState& ensembleContextState)
{
    m_category = ensembleContextState.category();
    m_contextAssociation = ensembleContextState.contextAssociation();
    m_bindingMdibVersion = ensembleContextState.bindingMdibVersion();
    m_unbindingMdibVersion = ensembleContextState.unbindingMdibVersion();
    m_bindingStartTime = ensembleContextState.bindingStartTime();
    m_bindingEndTime = ensembleContextState.bindingEndTime();
    m_validators = ensembleContextState.validators();
    m_identifications = ensembleContextState.identifications();
    m_extensions = ensembleContextState.extensions();
    return *this;
}

inline EnsembleContextState EnsembleContextStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return EnsembleContextState(m_category, m_contextAssociation, m_bindingMdibVersion, m_unbindingMdibVersion, m_bindingStartTime, m_bindingEndTime, m_validators, m_identifications, m_extensions);
}

inline bool EnsembleContextStateBuilder::isChanged(const EnsembleContextState& base) const
{
    return *this != base;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::category(const boost::optional<CodedValue>& category)
{
    m_category = category;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::category(boost::optional<CodedValue>&& category)
{
    m_category = std::move(category);
    return *this;
}

inline boost::optional<CodedValue>& EnsembleContextStateBuilder::category()
{
    return m_category;
}

inline const boost::optional<CodedValue>& EnsembleContextStateBuilder::category() const
{
    return m_category;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::contextAssociation(ContextAssociation contextAssociation)
{
    m_contextAssociation = contextAssociation;
    return *this;
}

inline ContextAssociation& EnsembleContextStateBuilder::contextAssociation()
{
    return m_contextAssociation;
}

inline ContextAssociation EnsembleContextStateBuilder::contextAssociation() const
{
    return m_contextAssociation;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingMdibVersion(const boost::optional<VersionCounter>& bindingMdibVersion)
{
    m_bindingMdibVersion = bindingMdibVersion;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingMdibVersion(boost::optional<VersionCounter>&& bindingMdibVersion)
{
    m_bindingMdibVersion = std::move(bindingMdibVersion);
    return *this;
}

inline boost::optional<VersionCounter>& EnsembleContextStateBuilder::bindingMdibVersion()
{
    return m_bindingMdibVersion;
}

inline const boost::optional<VersionCounter>& EnsembleContextStateBuilder::bindingMdibVersion() const
{
    return m_bindingMdibVersion;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::unbindingMdibVersion(const boost::optional<VersionCounter>& unbindingMdibVersion)
{
    m_unbindingMdibVersion = unbindingMdibVersion;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::unbindingMdibVersion(boost::optional<VersionCounter>&& unbindingMdibVersion)
{
    m_unbindingMdibVersion = std::move(unbindingMdibVersion);
    return *this;
}

inline boost::optional<VersionCounter>& EnsembleContextStateBuilder::unbindingMdibVersion()
{
    return m_unbindingMdibVersion;
}

inline const boost::optional<VersionCounter>& EnsembleContextStateBuilder::unbindingMdibVersion() const
{
    return m_unbindingMdibVersion;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingStartTime(const boost::optional<Timestamp>& bindingStartTime)
{
    m_bindingStartTime = bindingStartTime;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingStartTime(boost::optional<Timestamp>&& bindingStartTime)
{
    m_bindingStartTime = std::move(bindingStartTime);
    return *this;
}

inline boost::optional<Timestamp>& EnsembleContextStateBuilder::bindingStartTime()
{
    return m_bindingStartTime;
}

inline const boost::optional<Timestamp>& EnsembleContextStateBuilder::bindingStartTime() const
{
    return m_bindingStartTime;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingEndTime(const boost::optional<Timestamp>& bindingEndTime)
{
    m_bindingEndTime = bindingEndTime;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::bindingEndTime(boost::optional<Timestamp>&& bindingEndTime)
{
    m_bindingEndTime = std::move(bindingEndTime);
    return *this;
}

inline boost::optional<Timestamp>& EnsembleContextStateBuilder::bindingEndTime()
{
    return m_bindingEndTime;
}

inline const boost::optional<Timestamp>& EnsembleContextStateBuilder::bindingEndTime() const
{
    return m_bindingEndTime;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::validators(const InstanceIdentifiers& validators)
{
    m_validators = validators;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::validators(InstanceIdentifiers&& validators)
{
    m_validators = std::move(validators);
    return *this;
}

inline InstanceIdentifiers& EnsembleContextStateBuilder::validators()
{
    return m_validators;
}

inline const InstanceIdentifiers& EnsembleContextStateBuilder::validators() const
{
    return m_validators;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::identifications(const InstanceIdentifiers& identifications)
{
    m_identifications = identifications;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::identifications(InstanceIdentifiers&& identifications)
{
    m_identifications = std::move(identifications);
    return *this;
}

inline InstanceIdentifiers& EnsembleContextStateBuilder::identifications()
{
    return m_identifications;
}

inline const InstanceIdentifiers& EnsembleContextStateBuilder::identifications() const
{
    return m_identifications;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline EnsembleContextStateBuilder& EnsembleContextStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& EnsembleContextStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& EnsembleContextStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const EnsembleContextState& lhs, const EnsembleContextStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const EnsembleContextStateBuilder& lhs, const EnsembleContextStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const EnsembleContextState& lhs, const EnsembleContextStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const EnsembleContextStateBuilder& lhs, const EnsembleContextState& rhs)
{
    return !(lhs == rhs);
}

inline EnsembleContextStateBuilder getBuilder(const EnsembleContextState& ensembleContextState)
{
    return EnsembleContextStateBuilder(ensembleContextState);
}

inline EnsembleContextStateBuilder getBuilder(const DFL::NotNull<SharedPtr<EnsembleContextState>>& ensembleContextState)
{
    return EnsembleContextStateBuilder(ensembleContextState);
}

}
}
