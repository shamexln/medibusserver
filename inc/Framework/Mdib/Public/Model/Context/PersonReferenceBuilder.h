/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Context/PersonReference.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref PersonReference
 * @ingroup Mdib
 */
class PersonReferenceBuilder
{
    public:
        /// @brief Typedef to the immutable @ref PersonReference
        using BuiltType = PersonReference;

        /// @brief Builder based on given immutable @ref PersonReference
        explicit PersonReferenceBuilder(const PersonReference& personReference=PersonReference());

        /// @brief Builder based on given immutable @ref PersonReference
        explicit PersonReferenceBuilder(const DFL::NotNull<SharedPtr<PersonReference>>& personReference);

        /// @brief Overwrite all values with given immutable @ref PersonReference
        PersonReferenceBuilder& operator=(const PersonReference& personReference);

        /// @brief Explicit conversion to immutable @ref PersonReference
        PersonReference build() const;

        /// @brief Test whether the builder differs from the immutable @ref PersonReference
        bool isChanged(const PersonReference& base) const;

        /// @brief Setter for identification
        /// @{
        PersonReferenceBuilder& identification(const InstanceIdentifiers& identification);
        PersonReferenceBuilder& identification(InstanceIdentifiers&& identification);
        /// @}

        /// @brief Setter for name
        /// @{
        PersonReferenceBuilder& name(const boost::optional<BaseDemographics>& name);
        PersonReferenceBuilder& name(boost::optional<BaseDemographics>&& name);
        /// @}

        /// @brief Setter for extensions
        /// @{
        PersonReferenceBuilder& extensions(const ExtensionTypes& extensions);
        PersonReferenceBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for identification
        /// @{
        InstanceIdentifiers& identification();
        const InstanceIdentifiers& identification() const;
        /// @}

        /// @brief Getter for name
        /// @{
        boost::optional<BaseDemographics>& name();
        const boost::optional<BaseDemographics>& name() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        InstanceIdentifiers m_identification;
        boost::optional<BaseDemographics> m_name;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const PersonReference& lhs, const PersonReference& rhs);
DFL_MDIB_EXPIMP bool operator==(const PersonReferenceBuilder& lhs, const PersonReferenceBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const PersonReferenceBuilder& lhs, const PersonReference& rhs);
bool operator==(const PersonReference& lhs, const PersonReferenceBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const PersonReference& lhs, const PersonReference& rhs);
bool operator!=(const PersonReferenceBuilder& lhs, const PersonReferenceBuilder& rhs);
bool operator!=(const PersonReference& lhs, const PersonReferenceBuilder& rhs);
bool operator!=(const PersonReferenceBuilder& lhs, const PersonReference& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref PersonReference
 * @ingroup Mdib
 */
/// @{
PersonReferenceBuilder getBuilder(const PersonReference& personReference);
PersonReferenceBuilder getBuilder(const DFL::NotNull<SharedPtr<PersonReference>>& personReference);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const PersonReference& lhs, const PersonReference& rhs);

inline PersonReferenceBuilder::PersonReferenceBuilder(const PersonReference& personReference) :
    m_identification(personReference.identification()),
    m_name(personReference.name()),
    m_extensions(personReference.extensions())
{
}

inline PersonReferenceBuilder::PersonReferenceBuilder(const DFL::NotNull<SharedPtr<PersonReference>>& personReference) :
    m_identification(personReference->identification()),
    m_name(personReference->name()),
    m_extensions(personReference->extensions())
{
}

inline PersonReferenceBuilder& PersonReferenceBuilder::operator=(const PersonReference& personReference)
{
    m_identification = personReference.identification();
    m_name = personReference.name();
    m_extensions = personReference.extensions();
    return *this;
}

inline PersonReference PersonReferenceBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return PersonReference(m_identification, m_name, m_extensions);
}

inline bool PersonReferenceBuilder::isChanged(const PersonReference& base) const
{
    return *this != base;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::identification(const InstanceIdentifiers& identification)
{
    m_identification = identification;
    return *this;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::identification(InstanceIdentifiers&& identification)
{
    m_identification = std::move(identification);
    return *this;
}

inline InstanceIdentifiers& PersonReferenceBuilder::identification()
{
    return m_identification;
}

inline const InstanceIdentifiers& PersonReferenceBuilder::identification() const
{
    return m_identification;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::name(const boost::optional<BaseDemographics>& name)
{
    m_name = name;
    return *this;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::name(boost::optional<BaseDemographics>&& name)
{
    m_name = std::move(name);
    return *this;
}

inline boost::optional<BaseDemographics>& PersonReferenceBuilder::name()
{
    return m_name;
}

inline const boost::optional<BaseDemographics>& PersonReferenceBuilder::name() const
{
    return m_name;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline PersonReferenceBuilder& PersonReferenceBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& PersonReferenceBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& PersonReferenceBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const PersonReference& lhs, const PersonReferenceBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const PersonReferenceBuilder& lhs, const PersonReferenceBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const PersonReference& lhs, const PersonReferenceBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const PersonReferenceBuilder& lhs, const PersonReference& rhs)
{
    return !(lhs == rhs);
}

inline PersonReferenceBuilder getBuilder(const PersonReference& personReference)
{
    return PersonReferenceBuilder(personReference);
}

inline PersonReferenceBuilder getBuilder(const DFL::NotNull<SharedPtr<PersonReference>>& personReference)
{
    return PersonReferenceBuilder(personReference);
}

}
}
