/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/BatteryState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref BatteryState
 * @ingroup Mdib
 */
class BatteryStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref BatteryState
        using BuiltType = BatteryState;

        /// @brief Builder based on given immutable @ref BatteryState
        explicit BatteryStateBuilder(const BatteryState& batteryState=BatteryState());

        /// @brief Builder based on given immutable @ref BatteryState
        explicit BatteryStateBuilder(const DFL::NotNull<SharedPtr<BatteryState>>& batteryState);

        /// @brief Overwrite all values with given immutable @ref BatteryState
        BatteryStateBuilder& operator=(const BatteryState& batteryState);

        /// @brief Explicit conversion to immutable @ref BatteryState
        BatteryState build() const;

        /// @brief Test whether the builder differs from the immutable @ref BatteryState
        bool isChanged(const BatteryState& base) const;

        /// @brief Setter for activationState
        /// @{
        BatteryStateBuilder& activationState(ComponentActivation activationState);
        /// @}

        /// @brief Setter for operatingHours
        /// @{
        BatteryStateBuilder& operatingHours(const boost::optional<Chrono::Hours>& operatingHours);
        BatteryStateBuilder& operatingHours(boost::optional<Chrono::Hours>&& operatingHours);
        /// @}

        /// @brief Setter for operatingCycles
        /// @{
        BatteryStateBuilder& operatingCycles(const boost::optional<OperatingCycles>& operatingCycles);
        BatteryStateBuilder& operatingCycles(boost::optional<OperatingCycles>&& operatingCycles);
        /// @}

        /// @brief Setter for calibrationInfo
        /// @{
        BatteryStateBuilder& calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo);
        BatteryStateBuilder& calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo);
        /// @}

        /// @brief Setter for nextCalibrationInfo
        /// @{
        BatteryStateBuilder& nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo);
        BatteryStateBuilder& nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo);
        /// @}

        /// @brief Setter for physicalConnector
        /// @{
        BatteryStateBuilder& physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector);
        BatteryStateBuilder& physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector);
        /// @}

        /// @brief Setter for chargeStatus
        /// @{
        BatteryStateBuilder& chargeStatus(boost::optional<ChargeStatus> chargeStatus);
        /// @}

        /// @brief Setter for chargeCycles
        /// @{
        BatteryStateBuilder& chargeCycles(const boost::optional<ChargeCycles>& chargeCycles);
        BatteryStateBuilder& chargeCycles(boost::optional<ChargeCycles>&& chargeCycles);
        /// @}

        /// @brief Setter for capacityRemaining
        /// @{
        BatteryStateBuilder& capacityRemaining(const boost::optional<Measurement>& capacityRemaining);
        BatteryStateBuilder& capacityRemaining(boost::optional<Measurement>&& capacityRemaining);
        /// @}

        /// @brief Setter for voltage
        /// @{
        BatteryStateBuilder& voltage(const boost::optional<Measurement>& voltage);
        BatteryStateBuilder& voltage(boost::optional<Measurement>&& voltage);
        /// @}

        /// @brief Setter for current
        /// @{
        BatteryStateBuilder& current(const boost::optional<Measurement>& current);
        BatteryStateBuilder& current(boost::optional<Measurement>&& current);
        /// @}

        /// @brief Setter for temperature
        /// @{
        BatteryStateBuilder& temperature(const boost::optional<Measurement>& temperature);
        BatteryStateBuilder& temperature(boost::optional<Measurement>&& temperature);
        /// @}

        /// @brief Setter for remainingBatteryTime
        /// @{
        BatteryStateBuilder& remainingBatteryTime(const boost::optional<Measurement>& remainingBatteryTime);
        BatteryStateBuilder& remainingBatteryTime(boost::optional<Measurement>&& remainingBatteryTime);
        /// @}

        /// @brief Setter for extensions
        /// @{
        BatteryStateBuilder& extensions(const ExtensionTypes& extensions);
        BatteryStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        ComponentActivation& activationState();
        ComponentActivation activationState() const;
        /// @}

        /// @brief Getter for operatingHours
        /// @{
        boost::optional<Chrono::Hours>& operatingHours();
        const boost::optional<Chrono::Hours>& operatingHours() const;
        /// @}

        /// @brief Getter for operatingCycles
        /// @{
        boost::optional<OperatingCycles>& operatingCycles();
        const boost::optional<OperatingCycles>& operatingCycles() const;
        /// @}

        /// @brief Getter for calibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& calibrationInfo();
        const boost::optional<CalibrationInfo>& calibrationInfo() const;
        /// @}

        /// @brief Getter for nextCalibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& nextCalibrationInfo();
        const boost::optional<CalibrationInfo>& nextCalibrationInfo() const;
        /// @}

        /// @brief Getter for physicalConnector
        /// @{
        boost::optional<PhysicalConnectorInfo>& physicalConnector();
        const boost::optional<PhysicalConnectorInfo>& physicalConnector() const;
        /// @}

        /// @brief Getter for chargeStatus
        /// @{
        boost::optional<ChargeStatus>& chargeStatus();
        boost::optional<ChargeStatus> chargeStatus() const;
        /// @}

        /// @brief Getter for chargeCycles
        /// @{
        boost::optional<ChargeCycles>& chargeCycles();
        const boost::optional<ChargeCycles>& chargeCycles() const;
        /// @}

        /// @brief Getter for capacityRemaining
        /// @{
        boost::optional<Measurement>& capacityRemaining();
        const boost::optional<Measurement>& capacityRemaining() const;
        /// @}

        /// @brief Getter for voltage
        /// @{
        boost::optional<Measurement>& voltage();
        const boost::optional<Measurement>& voltage() const;
        /// @}

        /// @brief Getter for current
        /// @{
        boost::optional<Measurement>& current();
        const boost::optional<Measurement>& current() const;
        /// @}

        /// @brief Getter for temperature
        /// @{
        boost::optional<Measurement>& temperature();
        const boost::optional<Measurement>& temperature() const;
        /// @}

        /// @brief Getter for remainingBatteryTime
        /// @{
        boost::optional<Measurement>& remainingBatteryTime();
        const boost::optional<Measurement>& remainingBatteryTime() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        ComponentActivation m_activationState;
        boost::optional<Chrono::Hours> m_operatingHours;
        boost::optional<OperatingCycles> m_operatingCycles;
        boost::optional<CalibrationInfo> m_calibrationInfo;
        boost::optional<CalibrationInfo> m_nextCalibrationInfo;
        boost::optional<PhysicalConnectorInfo> m_physicalConnector;
        boost::optional<ChargeStatus> m_chargeStatus;
        boost::optional<ChargeCycles> m_chargeCycles;
        boost::optional<Measurement> m_capacityRemaining;
        boost::optional<Measurement> m_voltage;
        boost::optional<Measurement> m_current;
        boost::optional<Measurement> m_temperature;
        boost::optional<Measurement> m_remainingBatteryTime;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const BatteryState& lhs, const BatteryState& rhs);
DFL_MDIB_EXPIMP bool operator==(const BatteryStateBuilder& lhs, const BatteryStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const BatteryStateBuilder& lhs, const BatteryState& rhs);
bool operator==(const BatteryState& lhs, const BatteryStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const BatteryState& lhs, const BatteryState& rhs);
bool operator!=(const BatteryStateBuilder& lhs, const BatteryStateBuilder& rhs);
bool operator!=(const BatteryState& lhs, const BatteryStateBuilder& rhs);
bool operator!=(const BatteryStateBuilder& lhs, const BatteryState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref BatteryState
 * @ingroup Mdib
 */
/// @{
BatteryStateBuilder getBuilder(const BatteryState& batteryState);
BatteryStateBuilder getBuilder(const DFL::NotNull<SharedPtr<BatteryState>>& batteryState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const BatteryState& lhs, const BatteryState& rhs);

inline BatteryStateBuilder::BatteryStateBuilder(const BatteryState& batteryState) :
    m_activationState(batteryState.activationState()),
    m_operatingHours(batteryState.operatingHours()),
    m_operatingCycles(batteryState.operatingCycles()),
    m_calibrationInfo(batteryState.calibrationInfo()),
    m_nextCalibrationInfo(batteryState.nextCalibrationInfo()),
    m_physicalConnector(batteryState.physicalConnector()),
    m_chargeStatus(batteryState.chargeStatus()),
    m_chargeCycles(batteryState.chargeCycles()),
    m_capacityRemaining(batteryState.capacityRemaining()),
    m_voltage(batteryState.voltage()),
    m_current(batteryState.current()),
    m_temperature(batteryState.temperature()),
    m_remainingBatteryTime(batteryState.remainingBatteryTime()),
    m_extensions(batteryState.extensions())
{
}

inline BatteryStateBuilder::BatteryStateBuilder(const DFL::NotNull<SharedPtr<BatteryState>>& batteryState) :
    m_activationState(batteryState->activationState()),
    m_operatingHours(batteryState->operatingHours()),
    m_operatingCycles(batteryState->operatingCycles()),
    m_calibrationInfo(batteryState->calibrationInfo()),
    m_nextCalibrationInfo(batteryState->nextCalibrationInfo()),
    m_physicalConnector(batteryState->physicalConnector()),
    m_chargeStatus(batteryState->chargeStatus()),
    m_chargeCycles(batteryState->chargeCycles()),
    m_capacityRemaining(batteryState->capacityRemaining()),
    m_voltage(batteryState->voltage()),
    m_current(batteryState->current()),
    m_temperature(batteryState->temperature()),
    m_remainingBatteryTime(batteryState->remainingBatteryTime()),
    m_extensions(batteryState->extensions())
{
}

inline BatteryStateBuilder& BatteryStateBuilder::operator=(const BatteryState& batteryState)
{
    m_activationState = batteryState.activationState();
    m_operatingHours = batteryState.operatingHours();
    m_operatingCycles = batteryState.operatingCycles();
    m_calibrationInfo = batteryState.calibrationInfo();
    m_nextCalibrationInfo = batteryState.nextCalibrationInfo();
    m_physicalConnector = batteryState.physicalConnector();
    m_chargeStatus = batteryState.chargeStatus();
    m_chargeCycles = batteryState.chargeCycles();
    m_capacityRemaining = batteryState.capacityRemaining();
    m_voltage = batteryState.voltage();
    m_current = batteryState.current();
    m_temperature = batteryState.temperature();
    m_remainingBatteryTime = batteryState.remainingBatteryTime();
    m_extensions = batteryState.extensions();
    return *this;
}

inline BatteryState BatteryStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return BatteryState(m_activationState, m_operatingHours, m_operatingCycles, m_calibrationInfo, m_nextCalibrationInfo, m_physicalConnector, m_chargeStatus, m_chargeCycles, m_capacityRemaining, m_voltage, m_current, m_temperature, m_remainingBatteryTime, m_extensions);
}

inline bool BatteryStateBuilder::isChanged(const BatteryState& base) const
{
    return *this != base;
}

inline BatteryStateBuilder& BatteryStateBuilder::activationState(ComponentActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline ComponentActivation& BatteryStateBuilder::activationState()
{
    return m_activationState;
}

inline ComponentActivation BatteryStateBuilder::activationState() const
{
    return m_activationState;
}

inline BatteryStateBuilder& BatteryStateBuilder::operatingHours(const boost::optional<Chrono::Hours>& operatingHours)
{
    m_operatingHours = operatingHours;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::operatingHours(boost::optional<Chrono::Hours>&& operatingHours)
{
    m_operatingHours = std::move(operatingHours);
    return *this;
}

inline boost::optional<Chrono::Hours>& BatteryStateBuilder::operatingHours()
{
    return m_operatingHours;
}

inline const boost::optional<Chrono::Hours>& BatteryStateBuilder::operatingHours() const
{
    return m_operatingHours;
}

inline BatteryStateBuilder& BatteryStateBuilder::operatingCycles(const boost::optional<OperatingCycles>& operatingCycles)
{
    m_operatingCycles = operatingCycles;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::operatingCycles(boost::optional<OperatingCycles>&& operatingCycles)
{
    m_operatingCycles = std::move(operatingCycles);
    return *this;
}

inline boost::optional<OperatingCycles>& BatteryStateBuilder::operatingCycles()
{
    return m_operatingCycles;
}

inline const boost::optional<OperatingCycles>& BatteryStateBuilder::operatingCycles() const
{
    return m_operatingCycles;
}

inline BatteryStateBuilder& BatteryStateBuilder::calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo)
{
    m_calibrationInfo = calibrationInfo;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo)
{
    m_calibrationInfo = std::move(calibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& BatteryStateBuilder::calibrationInfo()
{
    return m_calibrationInfo;
}

inline const boost::optional<CalibrationInfo>& BatteryStateBuilder::calibrationInfo() const
{
    return m_calibrationInfo;
}

inline BatteryStateBuilder& BatteryStateBuilder::nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo)
{
    m_nextCalibrationInfo = nextCalibrationInfo;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo)
{
    m_nextCalibrationInfo = std::move(nextCalibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& BatteryStateBuilder::nextCalibrationInfo()
{
    return m_nextCalibrationInfo;
}

inline const boost::optional<CalibrationInfo>& BatteryStateBuilder::nextCalibrationInfo() const
{
    return m_nextCalibrationInfo;
}

inline BatteryStateBuilder& BatteryStateBuilder::physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector)
{
    m_physicalConnector = physicalConnector;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector)
{
    m_physicalConnector = std::move(physicalConnector);
    return *this;
}

inline boost::optional<PhysicalConnectorInfo>& BatteryStateBuilder::physicalConnector()
{
    return m_physicalConnector;
}

inline const boost::optional<PhysicalConnectorInfo>& BatteryStateBuilder::physicalConnector() const
{
    return m_physicalConnector;
}

inline BatteryStateBuilder& BatteryStateBuilder::chargeStatus(boost::optional<ChargeStatus> chargeStatus)
{
    m_chargeStatus = chargeStatus;
    return *this;
}

inline boost::optional<ChargeStatus>& BatteryStateBuilder::chargeStatus()
{
    return m_chargeStatus;
}

inline boost::optional<ChargeStatus> BatteryStateBuilder::chargeStatus() const
{
    return m_chargeStatus;
}

inline BatteryStateBuilder& BatteryStateBuilder::chargeCycles(const boost::optional<ChargeCycles>& chargeCycles)
{
    m_chargeCycles = chargeCycles;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::chargeCycles(boost::optional<ChargeCycles>&& chargeCycles)
{
    m_chargeCycles = std::move(chargeCycles);
    return *this;
}

inline boost::optional<ChargeCycles>& BatteryStateBuilder::chargeCycles()
{
    return m_chargeCycles;
}

inline const boost::optional<ChargeCycles>& BatteryStateBuilder::chargeCycles() const
{
    return m_chargeCycles;
}

inline BatteryStateBuilder& BatteryStateBuilder::capacityRemaining(const boost::optional<Measurement>& capacityRemaining)
{
    m_capacityRemaining = capacityRemaining;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::capacityRemaining(boost::optional<Measurement>&& capacityRemaining)
{
    m_capacityRemaining = std::move(capacityRemaining);
    return *this;
}

inline boost::optional<Measurement>& BatteryStateBuilder::capacityRemaining()
{
    return m_capacityRemaining;
}

inline const boost::optional<Measurement>& BatteryStateBuilder::capacityRemaining() const
{
    return m_capacityRemaining;
}

inline BatteryStateBuilder& BatteryStateBuilder::voltage(const boost::optional<Measurement>& voltage)
{
    m_voltage = voltage;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::voltage(boost::optional<Measurement>&& voltage)
{
    m_voltage = std::move(voltage);
    return *this;
}

inline boost::optional<Measurement>& BatteryStateBuilder::voltage()
{
    return m_voltage;
}

inline const boost::optional<Measurement>& BatteryStateBuilder::voltage() const
{
    return m_voltage;
}

inline BatteryStateBuilder& BatteryStateBuilder::current(const boost::optional<Measurement>& current)
{
    m_current = current;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::current(boost::optional<Measurement>&& current)
{
    m_current = std::move(current);
    return *this;
}

inline boost::optional<Measurement>& BatteryStateBuilder::current()
{
    return m_current;
}

inline const boost::optional<Measurement>& BatteryStateBuilder::current() const
{
    return m_current;
}

inline BatteryStateBuilder& BatteryStateBuilder::temperature(const boost::optional<Measurement>& temperature)
{
    m_temperature = temperature;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::temperature(boost::optional<Measurement>&& temperature)
{
    m_temperature = std::move(temperature);
    return *this;
}

inline boost::optional<Measurement>& BatteryStateBuilder::temperature()
{
    return m_temperature;
}

inline const boost::optional<Measurement>& BatteryStateBuilder::temperature() const
{
    return m_temperature;
}

inline BatteryStateBuilder& BatteryStateBuilder::remainingBatteryTime(const boost::optional<Measurement>& remainingBatteryTime)
{
    m_remainingBatteryTime = remainingBatteryTime;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::remainingBatteryTime(boost::optional<Measurement>&& remainingBatteryTime)
{
    m_remainingBatteryTime = std::move(remainingBatteryTime);
    return *this;
}

inline boost::optional<Measurement>& BatteryStateBuilder::remainingBatteryTime()
{
    return m_remainingBatteryTime;
}

inline const boost::optional<Measurement>& BatteryStateBuilder::remainingBatteryTime() const
{
    return m_remainingBatteryTime;
}

inline BatteryStateBuilder& BatteryStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline BatteryStateBuilder& BatteryStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& BatteryStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& BatteryStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const BatteryState& lhs, const BatteryStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const BatteryStateBuilder& lhs, const BatteryStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const BatteryState& lhs, const BatteryStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const BatteryStateBuilder& lhs, const BatteryState& rhs)
{
    return !(lhs == rhs);
}

inline BatteryStateBuilder getBuilder(const BatteryState& batteryState)
{
    return BatteryStateBuilder(batteryState);
}

inline BatteryStateBuilder getBuilder(const DFL::NotNull<SharedPtr<BatteryState>>& batteryState)
{
    return BatteryStateBuilder(batteryState);
}

}
}
