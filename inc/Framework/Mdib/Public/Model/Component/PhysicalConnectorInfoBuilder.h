/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/PhysicalConnectorInfo.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref PhysicalConnectorInfo
 * @ingroup Mdib
 */
class PhysicalConnectorInfoBuilder
{
    public:
        /// @brief Typedef to the immutable @ref PhysicalConnectorInfo
        using BuiltType = PhysicalConnectorInfo;

        /// @brief Builder based on given immutable @ref PhysicalConnectorInfo
        explicit PhysicalConnectorInfoBuilder(const PhysicalConnectorInfo& physicalConnectorInfo=PhysicalConnectorInfo());

        /// @brief Builder based on given immutable @ref PhysicalConnectorInfo
        explicit PhysicalConnectorInfoBuilder(const DFL::NotNull<SharedPtr<PhysicalConnectorInfo>>& physicalConnectorInfo);

        /// @brief Overwrite all values with given immutable @ref PhysicalConnectorInfo
        PhysicalConnectorInfoBuilder& operator=(const PhysicalConnectorInfo& physicalConnectorInfo);

        /// @brief Explicit conversion to immutable @ref PhysicalConnectorInfo
        PhysicalConnectorInfo build() const;

        /// @brief Test whether the builder differs from the immutable @ref PhysicalConnectorInfo
        bool isChanged(const PhysicalConnectorInfo& base) const;

        /// @brief Setter for number
        /// @{
        PhysicalConnectorInfoBuilder& number(boost::optional<PhysicalConnectorNumber> number);
        /// @}

        /// @brief Setter for labels
        /// @{
        PhysicalConnectorInfoBuilder& labels(const LocalizedTexts& labels);
        PhysicalConnectorInfoBuilder& labels(LocalizedTexts&& labels);
        /// @}

        /// @brief Setter for extensions
        /// @{
        PhysicalConnectorInfoBuilder& extensions(const ExtensionTypes& extensions);
        PhysicalConnectorInfoBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for number
        /// @{
        boost::optional<PhysicalConnectorNumber>& number();
        boost::optional<PhysicalConnectorNumber> number() const;
        /// @}

        /// @brief Getter for labels
        /// @{
        LocalizedTexts& labels();
        const LocalizedTexts& labels() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        boost::optional<PhysicalConnectorNumber> m_number;
        LocalizedTexts m_labels;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfo& rhs);
DFL_MDIB_EXPIMP bool operator==(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfoBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfo& rhs);
bool operator==(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfoBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfo& rhs);
bool operator!=(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfoBuilder& rhs);
bool operator!=(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfoBuilder& rhs);
bool operator!=(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfo& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref PhysicalConnectorInfo
 * @ingroup Mdib
 */
/// @{
PhysicalConnectorInfoBuilder getBuilder(const PhysicalConnectorInfo& physicalConnectorInfo);
PhysicalConnectorInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<PhysicalConnectorInfo>>& physicalConnectorInfo);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfo& rhs);

inline PhysicalConnectorInfoBuilder::PhysicalConnectorInfoBuilder(const PhysicalConnectorInfo& physicalConnectorInfo) :
    m_number(physicalConnectorInfo.number()),
    m_labels(physicalConnectorInfo.labels()),
    m_extensions(physicalConnectorInfo.extensions())
{
}

inline PhysicalConnectorInfoBuilder::PhysicalConnectorInfoBuilder(const DFL::NotNull<SharedPtr<PhysicalConnectorInfo>>& physicalConnectorInfo) :
    m_number(physicalConnectorInfo->number()),
    m_labels(physicalConnectorInfo->labels()),
    m_extensions(physicalConnectorInfo->extensions())
{
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::operator=(const PhysicalConnectorInfo& physicalConnectorInfo)
{
    m_number = physicalConnectorInfo.number();
    m_labels = physicalConnectorInfo.labels();
    m_extensions = physicalConnectorInfo.extensions();
    return *this;
}

inline PhysicalConnectorInfo PhysicalConnectorInfoBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return PhysicalConnectorInfo(m_number, m_labels, m_extensions);
}

inline bool PhysicalConnectorInfoBuilder::isChanged(const PhysicalConnectorInfo& base) const
{
    return *this != base;
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::number(boost::optional<PhysicalConnectorNumber> number)
{
    m_number = number;
    return *this;
}

inline boost::optional<PhysicalConnectorNumber>& PhysicalConnectorInfoBuilder::number()
{
    return m_number;
}

inline boost::optional<PhysicalConnectorNumber> PhysicalConnectorInfoBuilder::number() const
{
    return m_number;
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::labels(const LocalizedTexts& labels)
{
    m_labels = labels;
    return *this;
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::labels(LocalizedTexts&& labels)
{
    m_labels = std::move(labels);
    return *this;
}

inline LocalizedTexts& PhysicalConnectorInfoBuilder::labels()
{
    return m_labels;
}

inline const LocalizedTexts& PhysicalConnectorInfoBuilder::labels() const
{
    return m_labels;
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline PhysicalConnectorInfoBuilder& PhysicalConnectorInfoBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& PhysicalConnectorInfoBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& PhysicalConnectorInfoBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfoBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const PhysicalConnectorInfo& lhs, const PhysicalConnectorInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const PhysicalConnectorInfoBuilder& lhs, const PhysicalConnectorInfo& rhs)
{
    return !(lhs == rhs);
}

inline PhysicalConnectorInfoBuilder getBuilder(const PhysicalConnectorInfo& physicalConnectorInfo)
{
    return PhysicalConnectorInfoBuilder(physicalConnectorInfo);
}

inline PhysicalConnectorInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<PhysicalConnectorInfo>>& physicalConnectorInfo)
{
    return PhysicalConnectorInfoBuilder(physicalConnectorInfo);
}

}
}
