/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <Framework/Mdib/Public/Model/Component/ClockState.h>
#include <Framework/Chrono/Public/DurationSerialize.h>
#include <Framework/Chrono/Public/SystemTimeSerialize.h>
#include <Framework/Chrono/Public/TimeZoneSerialize.h>
#include <Framework/Mdib/Public/Model/CodedValueSerialize.h>
#include <Framework/Mdib/Public/Model/Component/CalibrationInfoSerialize.h>
#include <Framework/Mdib/Public/Model/Component/PhysicalConnectorInfoSerialize.h>
#include <Framework/Mdib/Public/Model/DecimalSerialize.h>
#include <Framework/Mdib/Public/Model/ExtensionTypeSerialize.h>
#include <Framework/Utils/Public/SerializationHelper.h>
#include <Framework/Utils/Public/Utf8Serialize.h>

#include <boost/serialization/nvp.hpp>
#include <boost/serialization/split_free.hpp>
#include <boost/serialization/version.hpp>
#include <boost/serialization/optional.hpp>
#include <boost/serialization/vector.hpp>

#include <utility>

BOOST_SERIALIZATION_SPLIT_FREE(::DFL::Mdib::ClockState)

BOOST_CLASS_VERSION(::DFL::Mdib::ClockState, 0)

BOOST_CLASS_TRACKING(::DFL::Mdib::ClockState, boost::serialization::track_never)

namespace boost
{
namespace serialization
{
/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void save(Archive& ar, const ::DFL::Mdib::ClockState& src, const unsigned int /*fileVersion*/)
{
    const auto& activationState = src.activationState();
    ar & make_nvp("ActivationState", activationState);

    const auto& operatingHours = src.operatingHours();
    ar & make_nvp("OperatingHours", operatingHours);

    const auto& operatingCycles = src.operatingCycles();
    ar & make_nvp("OperatingCycles", operatingCycles);

    const auto& calibrationInfo = src.calibrationInfo();
    ar & make_nvp("CalibrationInfo", calibrationInfo);

    const auto& nextCalibrationInfo = src.nextCalibrationInfo();
    ar & make_nvp("NextCalibrationInfo", nextCalibrationInfo);

    const auto& physicalConnector = src.physicalConnector();
    ar & make_nvp("PhysicalConnector", physicalConnector);

    const auto& activeSyncProtocol = src.activeSyncProtocol();
    DFL::Serialization::saveNvpOptional(ar, "ActiveSyncProtocol", activeSyncProtocol);

    const auto& referenceSources = src.referenceSources();
    ar & make_nvp("ReferenceSources", referenceSources);

    const auto& remoteSync = src.remoteSync();
    ar & make_nvp("RemoteSync", remoteSync);

    const auto& accuracy = src.accuracy();
    ar & make_nvp("Accuracy", accuracy);

    const auto& lastSet = src.lastSet();
    ar & make_nvp("LastSet", lastSet);

    const auto& timeZone = src.timeZone();
    DFL::Serialization::saveNvpOptional(ar, "TimeZone", timeZone);

    const auto& criticalUse = src.criticalUse();
    ar & make_nvp("CriticalUse", criticalUse);

    const auto& extensions = src.extensions();
    ar & make_nvp("Extensions", extensions);
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load_construct_data(Archive& ar, ::DFL::Mdib::ClockState* dst, const unsigned int /*version*/)
{
    ::DFL::Mdib::ComponentActivation activationState{};
    ar & make_nvp("ActivationState", activationState);

    boost::optional<::DFL::Chrono::Hours> operatingHours{};
    ar & make_nvp("OperatingHours", operatingHours);

    boost::optional<::DFL::Mdib::OperatingCycles> operatingCycles{};
    ar & make_nvp("OperatingCycles", operatingCycles);

    boost::optional<::DFL::Mdib::CalibrationInfo> calibrationInfo{};
    ar & make_nvp("CalibrationInfo", calibrationInfo);

    boost::optional<::DFL::Mdib::CalibrationInfo> nextCalibrationInfo{};
    ar & make_nvp("NextCalibrationInfo", nextCalibrationInfo);

    boost::optional<::DFL::Mdib::PhysicalConnectorInfo> physicalConnector{};
    ar & make_nvp("PhysicalConnector", physicalConnector);

    boost::optional<::DFL::Mdib::CodedValue> activeSyncProtocol{};
    DFL::Serialization::loadNvpOptional(ar, "ActiveSyncProtocol", activeSyncProtocol);

    std::vector<::DFL::Locale::Utf8> referenceSources{};
    ar & make_nvp("ReferenceSources", referenceSources);

    ::DFL::Mdib::ClockSynchronization remoteSync{};
    ar & make_nvp("RemoteSync", remoteSync);

    boost::optional<::DFL::Mdib::Decimal> accuracy{};
    ar & make_nvp("Accuracy", accuracy);

    boost::optional<::DFL::Mdib::Timestamp> lastSet{};
    ar & make_nvp("LastSet", lastSet);

    boost::optional<::DFL::Chrono::TimeZone> timeZone{};
    DFL::Serialization::loadNvpOptional(ar, "TimeZone", timeZone);

    ::DFL::Mdib::ClockUsage criticalUse{};
    ar & make_nvp("CriticalUse", criticalUse);

    ::DFL::Mdib::ExtensionTypes extensions{};
    ar & make_nvp("Extensions", extensions);

    ::new(dst) ::DFL::Mdib::ClockState(
        activationState,
        operatingHours,
        operatingCycles,
        calibrationInfo,
        nextCalibrationInfo,
        physicalConnector,
        activeSyncProtocol,
        referenceSources,
        remoteSync,
        accuracy,
        lastSet,
        timeZone,
        criticalUse,
        std::move(extensions));
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load(Archive& /*ar*/, ::DFL::Mdib::ClockState& /*dst*/, const unsigned int /*version*/)
{
}

}
}
