/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/ScoState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref ScoState
 * @ingroup Mdib
 */
class ScoStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref ScoState
        using BuiltType = ScoState;

        /// @brief Builder based on given immutable @ref ScoState
        explicit ScoStateBuilder(const ScoState& scoState=ScoState());

        /// @brief Builder based on given immutable @ref ScoState
        explicit ScoStateBuilder(const DFL::NotNull<SharedPtr<ScoState>>& scoState);

        /// @brief Overwrite all values with given immutable @ref ScoState
        ScoStateBuilder& operator=(const ScoState& scoState);

        /// @brief Explicit conversion to immutable @ref ScoState
        ScoState build() const;

        /// @brief Test whether the builder differs from the immutable @ref ScoState
        bool isChanged(const ScoState& base) const;

        /// @brief Setter for activationState
        /// @{
        ScoStateBuilder& activationState(ComponentActivation activationState);
        /// @}

        /// @brief Setter for operatingHours
        /// @{
        ScoStateBuilder& operatingHours(const boost::optional<Chrono::Hours>& operatingHours);
        ScoStateBuilder& operatingHours(boost::optional<Chrono::Hours>&& operatingHours);
        /// @}

        /// @brief Setter for operatingCycles
        /// @{
        ScoStateBuilder& operatingCycles(const boost::optional<OperatingCycles>& operatingCycles);
        ScoStateBuilder& operatingCycles(boost::optional<OperatingCycles>&& operatingCycles);
        /// @}

        /// @brief Setter for calibrationInfo
        /// @{
        ScoStateBuilder& calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo);
        ScoStateBuilder& calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo);
        /// @}

        /// @brief Setter for nextCalibrationInfo
        /// @{
        ScoStateBuilder& nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo);
        ScoStateBuilder& nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo);
        /// @}

        /// @brief Setter for physicalConnector
        /// @{
        ScoStateBuilder& physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector);
        ScoStateBuilder& physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector);
        /// @}

        /// @brief Setter for invocationRequested
        /// @{
        ScoStateBuilder& invocationRequested(const Handles& invocationRequested);
        ScoStateBuilder& invocationRequested(Handles&& invocationRequested);
        /// @}

        /// @brief Setter for invocationRequired
        /// @{
        ScoStateBuilder& invocationRequired(const Handles& invocationRequired);
        ScoStateBuilder& invocationRequired(Handles&& invocationRequired);
        /// @}

        /// @brief Setter for operationGroups
        /// @{
        ScoStateBuilder& operationGroups(const OperationGroups& operationGroups);
        ScoStateBuilder& operationGroups(OperationGroups&& operationGroups);
        /// @}

        /// @brief Setter for extensions
        /// @{
        ScoStateBuilder& extensions(const ExtensionTypes& extensions);
        ScoStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        ComponentActivation& activationState();
        ComponentActivation activationState() const;
        /// @}

        /// @brief Getter for operatingHours
        /// @{
        boost::optional<Chrono::Hours>& operatingHours();
        const boost::optional<Chrono::Hours>& operatingHours() const;
        /// @}

        /// @brief Getter for operatingCycles
        /// @{
        boost::optional<OperatingCycles>& operatingCycles();
        const boost::optional<OperatingCycles>& operatingCycles() const;
        /// @}

        /// @brief Getter for calibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& calibrationInfo();
        const boost::optional<CalibrationInfo>& calibrationInfo() const;
        /// @}

        /// @brief Getter for nextCalibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& nextCalibrationInfo();
        const boost::optional<CalibrationInfo>& nextCalibrationInfo() const;
        /// @}

        /// @brief Getter for physicalConnector
        /// @{
        boost::optional<PhysicalConnectorInfo>& physicalConnector();
        const boost::optional<PhysicalConnectorInfo>& physicalConnector() const;
        /// @}

        /// @brief Getter for invocationRequested
        /// @{
        Handles& invocationRequested();
        const Handles& invocationRequested() const;
        /// @}

        /// @brief Getter for invocationRequired
        /// @{
        Handles& invocationRequired();
        const Handles& invocationRequired() const;
        /// @}

        /// @brief Getter for operationGroups
        /// @{
        OperationGroups& operationGroups();
        const OperationGroups& operationGroups() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        ComponentActivation m_activationState;
        boost::optional<Chrono::Hours> m_operatingHours;
        boost::optional<OperatingCycles> m_operatingCycles;
        boost::optional<CalibrationInfo> m_calibrationInfo;
        boost::optional<CalibrationInfo> m_nextCalibrationInfo;
        boost::optional<PhysicalConnectorInfo> m_physicalConnector;
        Handles m_invocationRequested;
        Handles m_invocationRequired;
        OperationGroups m_operationGroups;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const ScoState& lhs, const ScoState& rhs);
DFL_MDIB_EXPIMP bool operator==(const ScoStateBuilder& lhs, const ScoStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const ScoStateBuilder& lhs, const ScoState& rhs);
bool operator==(const ScoState& lhs, const ScoStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const ScoState& lhs, const ScoState& rhs);
bool operator!=(const ScoStateBuilder& lhs, const ScoStateBuilder& rhs);
bool operator!=(const ScoState& lhs, const ScoStateBuilder& rhs);
bool operator!=(const ScoStateBuilder& lhs, const ScoState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref ScoState
 * @ingroup Mdib
 */
/// @{
ScoStateBuilder getBuilder(const ScoState& scoState);
ScoStateBuilder getBuilder(const DFL::NotNull<SharedPtr<ScoState>>& scoState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const ScoState& lhs, const ScoState& rhs);

inline ScoStateBuilder::ScoStateBuilder(const ScoState& scoState) :
    m_activationState(scoState.activationState()),
    m_operatingHours(scoState.operatingHours()),
    m_operatingCycles(scoState.operatingCycles()),
    m_calibrationInfo(scoState.calibrationInfo()),
    m_nextCalibrationInfo(scoState.nextCalibrationInfo()),
    m_physicalConnector(scoState.physicalConnector()),
    m_invocationRequested(scoState.invocationRequested()),
    m_invocationRequired(scoState.invocationRequired()),
    m_operationGroups(scoState.operationGroups()),
    m_extensions(scoState.extensions())
{
}

inline ScoStateBuilder::ScoStateBuilder(const DFL::NotNull<SharedPtr<ScoState>>& scoState) :
    m_activationState(scoState->activationState()),
    m_operatingHours(scoState->operatingHours()),
    m_operatingCycles(scoState->operatingCycles()),
    m_calibrationInfo(scoState->calibrationInfo()),
    m_nextCalibrationInfo(scoState->nextCalibrationInfo()),
    m_physicalConnector(scoState->physicalConnector()),
    m_invocationRequested(scoState->invocationRequested()),
    m_invocationRequired(scoState->invocationRequired()),
    m_operationGroups(scoState->operationGroups()),
    m_extensions(scoState->extensions())
{
}

inline ScoStateBuilder& ScoStateBuilder::operator=(const ScoState& scoState)
{
    m_activationState = scoState.activationState();
    m_operatingHours = scoState.operatingHours();
    m_operatingCycles = scoState.operatingCycles();
    m_calibrationInfo = scoState.calibrationInfo();
    m_nextCalibrationInfo = scoState.nextCalibrationInfo();
    m_physicalConnector = scoState.physicalConnector();
    m_invocationRequested = scoState.invocationRequested();
    m_invocationRequired = scoState.invocationRequired();
    m_operationGroups = scoState.operationGroups();
    m_extensions = scoState.extensions();
    return *this;
}

inline ScoState ScoStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return ScoState(m_activationState, m_operatingHours, m_operatingCycles, m_calibrationInfo, m_nextCalibrationInfo, m_physicalConnector, m_invocationRequested, m_invocationRequired, m_operationGroups, m_extensions);
}

inline bool ScoStateBuilder::isChanged(const ScoState& base) const
{
    return *this != base;
}

inline ScoStateBuilder& ScoStateBuilder::activationState(ComponentActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline ComponentActivation& ScoStateBuilder::activationState()
{
    return m_activationState;
}

inline ComponentActivation ScoStateBuilder::activationState() const
{
    return m_activationState;
}

inline ScoStateBuilder& ScoStateBuilder::operatingHours(const boost::optional<Chrono::Hours>& operatingHours)
{
    m_operatingHours = operatingHours;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::operatingHours(boost::optional<Chrono::Hours>&& operatingHours)
{
    m_operatingHours = std::move(operatingHours);
    return *this;
}

inline boost::optional<Chrono::Hours>& ScoStateBuilder::operatingHours()
{
    return m_operatingHours;
}

inline const boost::optional<Chrono::Hours>& ScoStateBuilder::operatingHours() const
{
    return m_operatingHours;
}

inline ScoStateBuilder& ScoStateBuilder::operatingCycles(const boost::optional<OperatingCycles>& operatingCycles)
{
    m_operatingCycles = operatingCycles;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::operatingCycles(boost::optional<OperatingCycles>&& operatingCycles)
{
    m_operatingCycles = std::move(operatingCycles);
    return *this;
}

inline boost::optional<OperatingCycles>& ScoStateBuilder::operatingCycles()
{
    return m_operatingCycles;
}

inline const boost::optional<OperatingCycles>& ScoStateBuilder::operatingCycles() const
{
    return m_operatingCycles;
}

inline ScoStateBuilder& ScoStateBuilder::calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo)
{
    m_calibrationInfo = calibrationInfo;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo)
{
    m_calibrationInfo = std::move(calibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& ScoStateBuilder::calibrationInfo()
{
    return m_calibrationInfo;
}

inline const boost::optional<CalibrationInfo>& ScoStateBuilder::calibrationInfo() const
{
    return m_calibrationInfo;
}

inline ScoStateBuilder& ScoStateBuilder::nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo)
{
    m_nextCalibrationInfo = nextCalibrationInfo;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo)
{
    m_nextCalibrationInfo = std::move(nextCalibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& ScoStateBuilder::nextCalibrationInfo()
{
    return m_nextCalibrationInfo;
}

inline const boost::optional<CalibrationInfo>& ScoStateBuilder::nextCalibrationInfo() const
{
    return m_nextCalibrationInfo;
}

inline ScoStateBuilder& ScoStateBuilder::physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector)
{
    m_physicalConnector = physicalConnector;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector)
{
    m_physicalConnector = std::move(physicalConnector);
    return *this;
}

inline boost::optional<PhysicalConnectorInfo>& ScoStateBuilder::physicalConnector()
{
    return m_physicalConnector;
}

inline const boost::optional<PhysicalConnectorInfo>& ScoStateBuilder::physicalConnector() const
{
    return m_physicalConnector;
}

inline ScoStateBuilder& ScoStateBuilder::invocationRequested(const Handles& invocationRequested)
{
    m_invocationRequested = invocationRequested;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::invocationRequested(Handles&& invocationRequested)
{
    m_invocationRequested = std::move(invocationRequested);
    return *this;
}

inline Handles& ScoStateBuilder::invocationRequested()
{
    return m_invocationRequested;
}

inline const Handles& ScoStateBuilder::invocationRequested() const
{
    return m_invocationRequested;
}

inline ScoStateBuilder& ScoStateBuilder::invocationRequired(const Handles& invocationRequired)
{
    m_invocationRequired = invocationRequired;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::invocationRequired(Handles&& invocationRequired)
{
    m_invocationRequired = std::move(invocationRequired);
    return *this;
}

inline Handles& ScoStateBuilder::invocationRequired()
{
    return m_invocationRequired;
}

inline const Handles& ScoStateBuilder::invocationRequired() const
{
    return m_invocationRequired;
}

inline ScoStateBuilder& ScoStateBuilder::operationGroups(const OperationGroups& operationGroups)
{
    m_operationGroups = operationGroups;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::operationGroups(OperationGroups&& operationGroups)
{
    m_operationGroups = std::move(operationGroups);
    return *this;
}

inline OperationGroups& ScoStateBuilder::operationGroups()
{
    return m_operationGroups;
}

inline const OperationGroups& ScoStateBuilder::operationGroups() const
{
    return m_operationGroups;
}

inline ScoStateBuilder& ScoStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline ScoStateBuilder& ScoStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& ScoStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& ScoStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const ScoState& lhs, const ScoStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const ScoStateBuilder& lhs, const ScoStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const ScoState& lhs, const ScoStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const ScoStateBuilder& lhs, const ScoState& rhs)
{
    return !(lhs == rhs);
}

inline ScoStateBuilder getBuilder(const ScoState& scoState)
{
    return ScoStateBuilder(scoState);
}

inline ScoStateBuilder getBuilder(const DFL::NotNull<SharedPtr<ScoState>>& scoState)
{
    return ScoStateBuilder(scoState);
}

}
}
