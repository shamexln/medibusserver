/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/MdsState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref MdsState
 * @ingroup Mdib
 */
class MdsStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref MdsState
        using BuiltType = MdsState;

        /// @brief Builder based on given immutable @ref MdsState
        explicit MdsStateBuilder(const MdsState& mdsState=MdsState());

        /// @brief Builder based on given immutable @ref MdsState
        explicit MdsStateBuilder(const DFL::NotNull<SharedPtr<MdsState>>& mdsState);

        /// @brief Overwrite all values with given immutable @ref MdsState
        MdsStateBuilder& operator=(const MdsState& mdsState);

        /// @brief Explicit conversion to immutable @ref MdsState
        MdsState build() const;

        /// @brief Test whether the builder differs from the immutable @ref MdsState
        bool isChanged(const MdsState& base) const;

        /// @brief Setter for activationState
        /// @{
        MdsStateBuilder& activationState(ComponentActivation activationState);
        /// @}

        /// @brief Setter for operatingHours
        /// @{
        MdsStateBuilder& operatingHours(const boost::optional<Chrono::Hours>& operatingHours);
        MdsStateBuilder& operatingHours(boost::optional<Chrono::Hours>&& operatingHours);
        /// @}

        /// @brief Setter for operatingCycles
        /// @{
        MdsStateBuilder& operatingCycles(const boost::optional<OperatingCycles>& operatingCycles);
        MdsStateBuilder& operatingCycles(boost::optional<OperatingCycles>&& operatingCycles);
        /// @}

        /// @brief Setter for calibrationInfo
        /// @{
        MdsStateBuilder& calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo);
        MdsStateBuilder& calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo);
        /// @}

        /// @brief Setter for nextCalibrationInfo
        /// @{
        MdsStateBuilder& nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo);
        MdsStateBuilder& nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo);
        /// @}

        /// @brief Setter for physicalConnector
        /// @{
        MdsStateBuilder& physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector);
        MdsStateBuilder& physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector);
        /// @}

        /// @brief Setter for lang
        /// @{
        MdsStateBuilder& lang(const Locale::LanguageTag& lang);
        MdsStateBuilder& lang(Locale::LanguageTag&& lang);
        /// @}

        /// @brief Setter for operatingMode
        /// @{
        MdsStateBuilder& operatingMode(MdsOperatingMode operatingMode);
        /// @}

        /// @brief Setter for operatingJurisdiction
        /// @{
        MdsStateBuilder& operatingJurisdiction(const boost::optional<InstanceIdentifier>& operatingJurisdiction);
        MdsStateBuilder& operatingJurisdiction(boost::optional<InstanceIdentifier>&& operatingJurisdiction);
        /// @}

        /// @brief Setter for extensions
        /// @{
        MdsStateBuilder& extensions(const ExtensionTypes& extensions);
        MdsStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        ComponentActivation& activationState();
        ComponentActivation activationState() const;
        /// @}

        /// @brief Getter for operatingHours
        /// @{
        boost::optional<Chrono::Hours>& operatingHours();
        const boost::optional<Chrono::Hours>& operatingHours() const;
        /// @}

        /// @brief Getter for operatingCycles
        /// @{
        boost::optional<OperatingCycles>& operatingCycles();
        const boost::optional<OperatingCycles>& operatingCycles() const;
        /// @}

        /// @brief Getter for calibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& calibrationInfo();
        const boost::optional<CalibrationInfo>& calibrationInfo() const;
        /// @}

        /// @brief Getter for nextCalibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& nextCalibrationInfo();
        const boost::optional<CalibrationInfo>& nextCalibrationInfo() const;
        /// @}

        /// @brief Getter for physicalConnector
        /// @{
        boost::optional<PhysicalConnectorInfo>& physicalConnector();
        const boost::optional<PhysicalConnectorInfo>& physicalConnector() const;
        /// @}

        /// @brief Getter for lang
        /// @{
        Locale::LanguageTag& lang();
        const Locale::LanguageTag& lang() const;
        /// @}

        /// @brief Getter for operatingMode
        /// @{
        MdsOperatingMode& operatingMode();
        MdsOperatingMode operatingMode() const;
        /// @}

        /// @brief Getter for operatingJurisdiction
        /// @{
        boost::optional<InstanceIdentifier>& operatingJurisdiction();
        const boost::optional<InstanceIdentifier>& operatingJurisdiction() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        ComponentActivation m_activationState;
        boost::optional<Chrono::Hours> m_operatingHours;
        boost::optional<OperatingCycles> m_operatingCycles;
        boost::optional<CalibrationInfo> m_calibrationInfo;
        boost::optional<CalibrationInfo> m_nextCalibrationInfo;
        boost::optional<PhysicalConnectorInfo> m_physicalConnector;
        Locale::LanguageTag m_lang;
        MdsOperatingMode m_operatingMode;
        boost::optional<InstanceIdentifier> m_operatingJurisdiction;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const MdsState& lhs, const MdsState& rhs);
DFL_MDIB_EXPIMP bool operator==(const MdsStateBuilder& lhs, const MdsStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const MdsStateBuilder& lhs, const MdsState& rhs);
bool operator==(const MdsState& lhs, const MdsStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const MdsState& lhs, const MdsState& rhs);
bool operator!=(const MdsStateBuilder& lhs, const MdsStateBuilder& rhs);
bool operator!=(const MdsState& lhs, const MdsStateBuilder& rhs);
bool operator!=(const MdsStateBuilder& lhs, const MdsState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref MdsState
 * @ingroup Mdib
 */
/// @{
MdsStateBuilder getBuilder(const MdsState& mdsState);
MdsStateBuilder getBuilder(const DFL::NotNull<SharedPtr<MdsState>>& mdsState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const MdsState& lhs, const MdsState& rhs);

inline MdsStateBuilder::MdsStateBuilder(const MdsState& mdsState) :
    m_activationState(mdsState.activationState()),
    m_operatingHours(mdsState.operatingHours()),
    m_operatingCycles(mdsState.operatingCycles()),
    m_calibrationInfo(mdsState.calibrationInfo()),
    m_nextCalibrationInfo(mdsState.nextCalibrationInfo()),
    m_physicalConnector(mdsState.physicalConnector()),
    m_lang(mdsState.lang()),
    m_operatingMode(mdsState.operatingMode()),
    m_operatingJurisdiction(mdsState.operatingJurisdiction()),
    m_extensions(mdsState.extensions())
{
}

inline MdsStateBuilder::MdsStateBuilder(const DFL::NotNull<SharedPtr<MdsState>>& mdsState) :
    m_activationState(mdsState->activationState()),
    m_operatingHours(mdsState->operatingHours()),
    m_operatingCycles(mdsState->operatingCycles()),
    m_calibrationInfo(mdsState->calibrationInfo()),
    m_nextCalibrationInfo(mdsState->nextCalibrationInfo()),
    m_physicalConnector(mdsState->physicalConnector()),
    m_lang(mdsState->lang()),
    m_operatingMode(mdsState->operatingMode()),
    m_operatingJurisdiction(mdsState->operatingJurisdiction()),
    m_extensions(mdsState->extensions())
{
}

inline MdsStateBuilder& MdsStateBuilder::operator=(const MdsState& mdsState)
{
    m_activationState = mdsState.activationState();
    m_operatingHours = mdsState.operatingHours();
    m_operatingCycles = mdsState.operatingCycles();
    m_calibrationInfo = mdsState.calibrationInfo();
    m_nextCalibrationInfo = mdsState.nextCalibrationInfo();
    m_physicalConnector = mdsState.physicalConnector();
    m_lang = mdsState.lang();
    m_operatingMode = mdsState.operatingMode();
    m_operatingJurisdiction = mdsState.operatingJurisdiction();
    m_extensions = mdsState.extensions();
    return *this;
}

inline MdsState MdsStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return MdsState(m_activationState, m_operatingHours, m_operatingCycles, m_calibrationInfo, m_nextCalibrationInfo, m_physicalConnector, m_lang, m_operatingMode, m_operatingJurisdiction, m_extensions);
}

inline bool MdsStateBuilder::isChanged(const MdsState& base) const
{
    return *this != base;
}

inline MdsStateBuilder& MdsStateBuilder::activationState(ComponentActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline ComponentActivation& MdsStateBuilder::activationState()
{
    return m_activationState;
}

inline ComponentActivation MdsStateBuilder::activationState() const
{
    return m_activationState;
}

inline MdsStateBuilder& MdsStateBuilder::operatingHours(const boost::optional<Chrono::Hours>& operatingHours)
{
    m_operatingHours = operatingHours;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::operatingHours(boost::optional<Chrono::Hours>&& operatingHours)
{
    m_operatingHours = std::move(operatingHours);
    return *this;
}

inline boost::optional<Chrono::Hours>& MdsStateBuilder::operatingHours()
{
    return m_operatingHours;
}

inline const boost::optional<Chrono::Hours>& MdsStateBuilder::operatingHours() const
{
    return m_operatingHours;
}

inline MdsStateBuilder& MdsStateBuilder::operatingCycles(const boost::optional<OperatingCycles>& operatingCycles)
{
    m_operatingCycles = operatingCycles;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::operatingCycles(boost::optional<OperatingCycles>&& operatingCycles)
{
    m_operatingCycles = std::move(operatingCycles);
    return *this;
}

inline boost::optional<OperatingCycles>& MdsStateBuilder::operatingCycles()
{
    return m_operatingCycles;
}

inline const boost::optional<OperatingCycles>& MdsStateBuilder::operatingCycles() const
{
    return m_operatingCycles;
}

inline MdsStateBuilder& MdsStateBuilder::calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo)
{
    m_calibrationInfo = calibrationInfo;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo)
{
    m_calibrationInfo = std::move(calibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& MdsStateBuilder::calibrationInfo()
{
    return m_calibrationInfo;
}

inline const boost::optional<CalibrationInfo>& MdsStateBuilder::calibrationInfo() const
{
    return m_calibrationInfo;
}

inline MdsStateBuilder& MdsStateBuilder::nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo)
{
    m_nextCalibrationInfo = nextCalibrationInfo;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo)
{
    m_nextCalibrationInfo = std::move(nextCalibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& MdsStateBuilder::nextCalibrationInfo()
{
    return m_nextCalibrationInfo;
}

inline const boost::optional<CalibrationInfo>& MdsStateBuilder::nextCalibrationInfo() const
{
    return m_nextCalibrationInfo;
}

inline MdsStateBuilder& MdsStateBuilder::physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector)
{
    m_physicalConnector = physicalConnector;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector)
{
    m_physicalConnector = std::move(physicalConnector);
    return *this;
}

inline boost::optional<PhysicalConnectorInfo>& MdsStateBuilder::physicalConnector()
{
    return m_physicalConnector;
}

inline const boost::optional<PhysicalConnectorInfo>& MdsStateBuilder::physicalConnector() const
{
    return m_physicalConnector;
}

inline MdsStateBuilder& MdsStateBuilder::lang(const Locale::LanguageTag& lang)
{
    m_lang = lang;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::lang(Locale::LanguageTag&& lang)
{
    m_lang = std::move(lang);
    return *this;
}

inline Locale::LanguageTag& MdsStateBuilder::lang()
{
    return m_lang;
}

inline const Locale::LanguageTag& MdsStateBuilder::lang() const
{
    return m_lang;
}

inline MdsStateBuilder& MdsStateBuilder::operatingMode(MdsOperatingMode operatingMode)
{
    m_operatingMode = operatingMode;
    return *this;
}

inline MdsOperatingMode& MdsStateBuilder::operatingMode()
{
    return m_operatingMode;
}

inline MdsOperatingMode MdsStateBuilder::operatingMode() const
{
    return m_operatingMode;
}

inline MdsStateBuilder& MdsStateBuilder::operatingJurisdiction(const boost::optional<InstanceIdentifier>& operatingJurisdiction)
{
    m_operatingJurisdiction = operatingJurisdiction;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::operatingJurisdiction(boost::optional<InstanceIdentifier>&& operatingJurisdiction)
{
    m_operatingJurisdiction = std::move(operatingJurisdiction);
    return *this;
}

inline boost::optional<InstanceIdentifier>& MdsStateBuilder::operatingJurisdiction()
{
    return m_operatingJurisdiction;
}

inline const boost::optional<InstanceIdentifier>& MdsStateBuilder::operatingJurisdiction() const
{
    return m_operatingJurisdiction;
}

inline MdsStateBuilder& MdsStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline MdsStateBuilder& MdsStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& MdsStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& MdsStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const MdsState& lhs, const MdsStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const MdsStateBuilder& lhs, const MdsStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const MdsState& lhs, const MdsStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const MdsStateBuilder& lhs, const MdsState& rhs)
{
    return !(lhs == rhs);
}

inline MdsStateBuilder getBuilder(const MdsState& mdsState)
{
    return MdsStateBuilder(mdsState);
}

inline MdsStateBuilder getBuilder(const DFL::NotNull<SharedPtr<MdsState>>& mdsState)
{
    return MdsStateBuilder(mdsState);
}

}
}
