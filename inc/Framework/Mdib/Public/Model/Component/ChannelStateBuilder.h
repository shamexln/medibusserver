/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/ChannelState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref ChannelState
 * @ingroup Mdib
 */
class ChannelStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref ChannelState
        using BuiltType = ChannelState;

        /// @brief Builder based on given immutable @ref ChannelState
        explicit ChannelStateBuilder(const ChannelState& channelState=ChannelState());

        /// @brief Builder based on given immutable @ref ChannelState
        explicit ChannelStateBuilder(const DFL::NotNull<SharedPtr<ChannelState>>& channelState);

        /// @brief Overwrite all values with given immutable @ref ChannelState
        ChannelStateBuilder& operator=(const ChannelState& channelState);

        /// @brief Explicit conversion to immutable @ref ChannelState
        ChannelState build() const;

        /// @brief Test whether the builder differs from the immutable @ref ChannelState
        bool isChanged(const ChannelState& base) const;

        /// @brief Setter for activationState
        /// @{
        ChannelStateBuilder& activationState(ComponentActivation activationState);
        /// @}

        /// @brief Setter for operatingHours
        /// @{
        ChannelStateBuilder& operatingHours(const boost::optional<Chrono::Hours>& operatingHours);
        ChannelStateBuilder& operatingHours(boost::optional<Chrono::Hours>&& operatingHours);
        /// @}

        /// @brief Setter for operatingCycles
        /// @{
        ChannelStateBuilder& operatingCycles(const boost::optional<OperatingCycles>& operatingCycles);
        ChannelStateBuilder& operatingCycles(boost::optional<OperatingCycles>&& operatingCycles);
        /// @}

        /// @brief Setter for calibrationInfo
        /// @{
        ChannelStateBuilder& calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo);
        ChannelStateBuilder& calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo);
        /// @}

        /// @brief Setter for nextCalibrationInfo
        /// @{
        ChannelStateBuilder& nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo);
        ChannelStateBuilder& nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo);
        /// @}

        /// @brief Setter for physicalConnector
        /// @{
        ChannelStateBuilder& physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector);
        ChannelStateBuilder& physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector);
        /// @}

        /// @brief Setter for extensions
        /// @{
        ChannelStateBuilder& extensions(const ExtensionTypes& extensions);
        ChannelStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        ComponentActivation& activationState();
        ComponentActivation activationState() const;
        /// @}

        /// @brief Getter for operatingHours
        /// @{
        boost::optional<Chrono::Hours>& operatingHours();
        const boost::optional<Chrono::Hours>& operatingHours() const;
        /// @}

        /// @brief Getter for operatingCycles
        /// @{
        boost::optional<OperatingCycles>& operatingCycles();
        const boost::optional<OperatingCycles>& operatingCycles() const;
        /// @}

        /// @brief Getter for calibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& calibrationInfo();
        const boost::optional<CalibrationInfo>& calibrationInfo() const;
        /// @}

        /// @brief Getter for nextCalibrationInfo
        /// @{
        boost::optional<CalibrationInfo>& nextCalibrationInfo();
        const boost::optional<CalibrationInfo>& nextCalibrationInfo() const;
        /// @}

        /// @brief Getter for physicalConnector
        /// @{
        boost::optional<PhysicalConnectorInfo>& physicalConnector();
        const boost::optional<PhysicalConnectorInfo>& physicalConnector() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        ComponentActivation m_activationState;
        boost::optional<Chrono::Hours> m_operatingHours;
        boost::optional<OperatingCycles> m_operatingCycles;
        boost::optional<CalibrationInfo> m_calibrationInfo;
        boost::optional<CalibrationInfo> m_nextCalibrationInfo;
        boost::optional<PhysicalConnectorInfo> m_physicalConnector;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const ChannelState& lhs, const ChannelState& rhs);
DFL_MDIB_EXPIMP bool operator==(const ChannelStateBuilder& lhs, const ChannelStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const ChannelStateBuilder& lhs, const ChannelState& rhs);
bool operator==(const ChannelState& lhs, const ChannelStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const ChannelState& lhs, const ChannelState& rhs);
bool operator!=(const ChannelStateBuilder& lhs, const ChannelStateBuilder& rhs);
bool operator!=(const ChannelState& lhs, const ChannelStateBuilder& rhs);
bool operator!=(const ChannelStateBuilder& lhs, const ChannelState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref ChannelState
 * @ingroup Mdib
 */
/// @{
ChannelStateBuilder getBuilder(const ChannelState& channelState);
ChannelStateBuilder getBuilder(const DFL::NotNull<SharedPtr<ChannelState>>& channelState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const ChannelState& lhs, const ChannelState& rhs);

inline ChannelStateBuilder::ChannelStateBuilder(const ChannelState& channelState) :
    m_activationState(channelState.activationState()),
    m_operatingHours(channelState.operatingHours()),
    m_operatingCycles(channelState.operatingCycles()),
    m_calibrationInfo(channelState.calibrationInfo()),
    m_nextCalibrationInfo(channelState.nextCalibrationInfo()),
    m_physicalConnector(channelState.physicalConnector()),
    m_extensions(channelState.extensions())
{
}

inline ChannelStateBuilder::ChannelStateBuilder(const DFL::NotNull<SharedPtr<ChannelState>>& channelState) :
    m_activationState(channelState->activationState()),
    m_operatingHours(channelState->operatingHours()),
    m_operatingCycles(channelState->operatingCycles()),
    m_calibrationInfo(channelState->calibrationInfo()),
    m_nextCalibrationInfo(channelState->nextCalibrationInfo()),
    m_physicalConnector(channelState->physicalConnector()),
    m_extensions(channelState->extensions())
{
}

inline ChannelStateBuilder& ChannelStateBuilder::operator=(const ChannelState& channelState)
{
    m_activationState = channelState.activationState();
    m_operatingHours = channelState.operatingHours();
    m_operatingCycles = channelState.operatingCycles();
    m_calibrationInfo = channelState.calibrationInfo();
    m_nextCalibrationInfo = channelState.nextCalibrationInfo();
    m_physicalConnector = channelState.physicalConnector();
    m_extensions = channelState.extensions();
    return *this;
}

inline ChannelState ChannelStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return ChannelState(m_activationState, m_operatingHours, m_operatingCycles, m_calibrationInfo, m_nextCalibrationInfo, m_physicalConnector, m_extensions);
}

inline bool ChannelStateBuilder::isChanged(const ChannelState& base) const
{
    return *this != base;
}

inline ChannelStateBuilder& ChannelStateBuilder::activationState(ComponentActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline ComponentActivation& ChannelStateBuilder::activationState()
{
    return m_activationState;
}

inline ComponentActivation ChannelStateBuilder::activationState() const
{
    return m_activationState;
}

inline ChannelStateBuilder& ChannelStateBuilder::operatingHours(const boost::optional<Chrono::Hours>& operatingHours)
{
    m_operatingHours = operatingHours;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::operatingHours(boost::optional<Chrono::Hours>&& operatingHours)
{
    m_operatingHours = std::move(operatingHours);
    return *this;
}

inline boost::optional<Chrono::Hours>& ChannelStateBuilder::operatingHours()
{
    return m_operatingHours;
}

inline const boost::optional<Chrono::Hours>& ChannelStateBuilder::operatingHours() const
{
    return m_operatingHours;
}

inline ChannelStateBuilder& ChannelStateBuilder::operatingCycles(const boost::optional<OperatingCycles>& operatingCycles)
{
    m_operatingCycles = operatingCycles;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::operatingCycles(boost::optional<OperatingCycles>&& operatingCycles)
{
    m_operatingCycles = std::move(operatingCycles);
    return *this;
}

inline boost::optional<OperatingCycles>& ChannelStateBuilder::operatingCycles()
{
    return m_operatingCycles;
}

inline const boost::optional<OperatingCycles>& ChannelStateBuilder::operatingCycles() const
{
    return m_operatingCycles;
}

inline ChannelStateBuilder& ChannelStateBuilder::calibrationInfo(const boost::optional<CalibrationInfo>& calibrationInfo)
{
    m_calibrationInfo = calibrationInfo;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::calibrationInfo(boost::optional<CalibrationInfo>&& calibrationInfo)
{
    m_calibrationInfo = std::move(calibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& ChannelStateBuilder::calibrationInfo()
{
    return m_calibrationInfo;
}

inline const boost::optional<CalibrationInfo>& ChannelStateBuilder::calibrationInfo() const
{
    return m_calibrationInfo;
}

inline ChannelStateBuilder& ChannelStateBuilder::nextCalibrationInfo(const boost::optional<CalibrationInfo>& nextCalibrationInfo)
{
    m_nextCalibrationInfo = nextCalibrationInfo;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::nextCalibrationInfo(boost::optional<CalibrationInfo>&& nextCalibrationInfo)
{
    m_nextCalibrationInfo = std::move(nextCalibrationInfo);
    return *this;
}

inline boost::optional<CalibrationInfo>& ChannelStateBuilder::nextCalibrationInfo()
{
    return m_nextCalibrationInfo;
}

inline const boost::optional<CalibrationInfo>& ChannelStateBuilder::nextCalibrationInfo() const
{
    return m_nextCalibrationInfo;
}

inline ChannelStateBuilder& ChannelStateBuilder::physicalConnector(const boost::optional<PhysicalConnectorInfo>& physicalConnector)
{
    m_physicalConnector = physicalConnector;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::physicalConnector(boost::optional<PhysicalConnectorInfo>&& physicalConnector)
{
    m_physicalConnector = std::move(physicalConnector);
    return *this;
}

inline boost::optional<PhysicalConnectorInfo>& ChannelStateBuilder::physicalConnector()
{
    return m_physicalConnector;
}

inline const boost::optional<PhysicalConnectorInfo>& ChannelStateBuilder::physicalConnector() const
{
    return m_physicalConnector;
}

inline ChannelStateBuilder& ChannelStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline ChannelStateBuilder& ChannelStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& ChannelStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& ChannelStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const ChannelState& lhs, const ChannelStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const ChannelStateBuilder& lhs, const ChannelStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const ChannelState& lhs, const ChannelStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const ChannelStateBuilder& lhs, const ChannelState& rhs)
{
    return !(lhs == rhs);
}

inline ChannelStateBuilder getBuilder(const ChannelState& channelState)
{
    return ChannelStateBuilder(channelState);
}

inline ChannelStateBuilder getBuilder(const DFL::NotNull<SharedPtr<ChannelState>>& channelState)
{
    return ChannelStateBuilder(channelState);
}

}
}
