/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Component/CalibrationInfo.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref CalibrationInfo
 * @ingroup Mdib
 */
class CalibrationInfoBuilder
{
    public:
        /// @brief Typedef to the immutable @ref CalibrationInfo
        using BuiltType = CalibrationInfo;

        /// @brief Builder based on given immutable @ref CalibrationInfo
        explicit CalibrationInfoBuilder(const CalibrationInfo& calibrationInfo=CalibrationInfo());

        /// @brief Builder based on given immutable @ref CalibrationInfo
        explicit CalibrationInfoBuilder(const DFL::NotNull<SharedPtr<CalibrationInfo>>& calibrationInfo);

        /// @brief Overwrite all values with given immutable @ref CalibrationInfo
        CalibrationInfoBuilder& operator=(const CalibrationInfo& calibrationInfo);

        /// @brief Explicit conversion to immutable @ref CalibrationInfo
        CalibrationInfo build() const;

        /// @brief Test whether the builder differs from the immutable @ref CalibrationInfo
        bool isChanged(const CalibrationInfo& base) const;

        /// @brief Setter for componentCalibrationState
        /// @{
        CalibrationInfoBuilder& componentCalibrationState(boost::optional<CalibrationState> componentCalibrationState);
        /// @}

        /// @brief Setter for type
        /// @{
        CalibrationInfoBuilder& type(CalibrationType type);
        /// @}

        /// @brief Setter for time
        /// @{
        CalibrationInfoBuilder& time(const boost::optional<Timestamp>& time);
        CalibrationInfoBuilder& time(boost::optional<Timestamp>&& time);
        /// @}

        /// @brief Setter for calibrationDocumentation
        /// @{
        CalibrationInfoBuilder& calibrationDocumentation(const CalibrationDocumentations& calibrationDocumentation);
        CalibrationInfoBuilder& calibrationDocumentation(CalibrationDocumentations&& calibrationDocumentation);
        /// @}

        /// @brief Setter for extensions
        /// @{
        CalibrationInfoBuilder& extensions(const ExtensionTypes& extensions);
        CalibrationInfoBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for componentCalibrationState
        /// @{
        boost::optional<CalibrationState>& componentCalibrationState();
        boost::optional<CalibrationState> componentCalibrationState() const;
        /// @}

        /// @brief Getter for type
        /// @{
        CalibrationType& type();
        CalibrationType type() const;
        /// @}

        /// @brief Getter for time
        /// @{
        boost::optional<Timestamp>& time();
        const boost::optional<Timestamp>& time() const;
        /// @}

        /// @brief Getter for calibrationDocumentation
        /// @{
        CalibrationDocumentations& calibrationDocumentation();
        const CalibrationDocumentations& calibrationDocumentation() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        boost::optional<CalibrationState> m_componentCalibrationState;
        CalibrationType m_type;
        boost::optional<Timestamp> m_time;
        CalibrationDocumentations m_calibrationDocumentation;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const CalibrationInfo& lhs, const CalibrationInfo& rhs);
DFL_MDIB_EXPIMP bool operator==(const CalibrationInfoBuilder& lhs, const CalibrationInfoBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const CalibrationInfoBuilder& lhs, const CalibrationInfo& rhs);
bool operator==(const CalibrationInfo& lhs, const CalibrationInfoBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const CalibrationInfo& lhs, const CalibrationInfo& rhs);
bool operator!=(const CalibrationInfoBuilder& lhs, const CalibrationInfoBuilder& rhs);
bool operator!=(const CalibrationInfo& lhs, const CalibrationInfoBuilder& rhs);
bool operator!=(const CalibrationInfoBuilder& lhs, const CalibrationInfo& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref CalibrationInfo
 * @ingroup Mdib
 */
/// @{
CalibrationInfoBuilder getBuilder(const CalibrationInfo& calibrationInfo);
CalibrationInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<CalibrationInfo>>& calibrationInfo);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const CalibrationInfo& lhs, const CalibrationInfo& rhs);

inline CalibrationInfoBuilder::CalibrationInfoBuilder(const CalibrationInfo& calibrationInfo) :
    m_componentCalibrationState(calibrationInfo.componentCalibrationState()),
    m_type(calibrationInfo.type()),
    m_time(calibrationInfo.time()),
    m_calibrationDocumentation(calibrationInfo.calibrationDocumentation()),
    m_extensions(calibrationInfo.extensions())
{
}

inline CalibrationInfoBuilder::CalibrationInfoBuilder(const DFL::NotNull<SharedPtr<CalibrationInfo>>& calibrationInfo) :
    m_componentCalibrationState(calibrationInfo->componentCalibrationState()),
    m_type(calibrationInfo->type()),
    m_time(calibrationInfo->time()),
    m_calibrationDocumentation(calibrationInfo->calibrationDocumentation()),
    m_extensions(calibrationInfo->extensions())
{
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::operator=(const CalibrationInfo& calibrationInfo)
{
    m_componentCalibrationState = calibrationInfo.componentCalibrationState();
    m_type = calibrationInfo.type();
    m_time = calibrationInfo.time();
    m_calibrationDocumentation = calibrationInfo.calibrationDocumentation();
    m_extensions = calibrationInfo.extensions();
    return *this;
}

inline CalibrationInfo CalibrationInfoBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return CalibrationInfo(m_componentCalibrationState, m_type, m_time, m_calibrationDocumentation, m_extensions);
}

inline bool CalibrationInfoBuilder::isChanged(const CalibrationInfo& base) const
{
    return *this != base;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::componentCalibrationState(boost::optional<CalibrationState> componentCalibrationState)
{
    m_componentCalibrationState = componentCalibrationState;
    return *this;
}

inline boost::optional<CalibrationState>& CalibrationInfoBuilder::componentCalibrationState()
{
    return m_componentCalibrationState;
}

inline boost::optional<CalibrationState> CalibrationInfoBuilder::componentCalibrationState() const
{
    return m_componentCalibrationState;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::type(CalibrationType type)
{
    m_type = type;
    return *this;
}

inline CalibrationType& CalibrationInfoBuilder::type()
{
    return m_type;
}

inline CalibrationType CalibrationInfoBuilder::type() const
{
    return m_type;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::time(const boost::optional<Timestamp>& time)
{
    m_time = time;
    return *this;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::time(boost::optional<Timestamp>&& time)
{
    m_time = std::move(time);
    return *this;
}

inline boost::optional<Timestamp>& CalibrationInfoBuilder::time()
{
    return m_time;
}

inline const boost::optional<Timestamp>& CalibrationInfoBuilder::time() const
{
    return m_time;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::calibrationDocumentation(const CalibrationDocumentations& calibrationDocumentation)
{
    m_calibrationDocumentation = calibrationDocumentation;
    return *this;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::calibrationDocumentation(CalibrationDocumentations&& calibrationDocumentation)
{
    m_calibrationDocumentation = std::move(calibrationDocumentation);
    return *this;
}

inline CalibrationDocumentations& CalibrationInfoBuilder::calibrationDocumentation()
{
    return m_calibrationDocumentation;
}

inline const CalibrationDocumentations& CalibrationInfoBuilder::calibrationDocumentation() const
{
    return m_calibrationDocumentation;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline CalibrationInfoBuilder& CalibrationInfoBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& CalibrationInfoBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& CalibrationInfoBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const CalibrationInfo& lhs, const CalibrationInfoBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const CalibrationInfoBuilder& lhs, const CalibrationInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const CalibrationInfo& lhs, const CalibrationInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const CalibrationInfoBuilder& lhs, const CalibrationInfo& rhs)
{
    return !(lhs == rhs);
}

inline CalibrationInfoBuilder getBuilder(const CalibrationInfo& calibrationInfo)
{
    return CalibrationInfoBuilder(calibrationInfo);
}

inline CalibrationInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<CalibrationInfo>>& calibrationInfo)
{
    return CalibrationInfoBuilder(calibrationInfo);
}

}
}
