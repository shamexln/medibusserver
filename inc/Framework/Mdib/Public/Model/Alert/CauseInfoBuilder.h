/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Alert/CauseInfo.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref CauseInfo
 * @ingroup Mdib
 */
class CauseInfoBuilder
{
    public:
        /// @brief Typedef to the immutable @ref CauseInfo
        using BuiltType = CauseInfo;

        /// @brief Builder based on given immutable @ref CauseInfo
        explicit CauseInfoBuilder(const CauseInfo& causeInfo=CauseInfo());

        /// @brief Builder based on given immutable @ref CauseInfo
        explicit CauseInfoBuilder(const DFL::NotNull<SharedPtr<CauseInfo>>& causeInfo);

        /// @brief Overwrite all values with given immutable @ref CauseInfo
        CauseInfoBuilder& operator=(const CauseInfo& causeInfo);

        /// @brief Explicit conversion to immutable @ref CauseInfo
        CauseInfo build() const;

        /// @brief Test whether the builder differs from the immutable @ref CauseInfo
        bool isChanged(const CauseInfo& base) const;

        /// @brief Setter for remedyInfo
        /// @{
        CauseInfoBuilder& remedyInfo(const boost::optional<RemedyInfo>& remedyInfo);
        CauseInfoBuilder& remedyInfo(boost::optional<RemedyInfo>&& remedyInfo);
        /// @}

        /// @brief Setter for description
        /// @{
        CauseInfoBuilder& description(const LocalizedTexts& description);
        CauseInfoBuilder& description(LocalizedTexts&& description);
        /// @}

        /// @brief Setter for extensions
        /// @{
        CauseInfoBuilder& extensions(const ExtensionTypes& extensions);
        CauseInfoBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for remedyInfo
        /// @{
        boost::optional<RemedyInfo>& remedyInfo();
        const boost::optional<RemedyInfo>& remedyInfo() const;
        /// @}

        /// @brief Getter for description
        /// @{
        LocalizedTexts& description();
        const LocalizedTexts& description() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        boost::optional<RemedyInfo> m_remedyInfo;
        LocalizedTexts m_description;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const CauseInfo& lhs, const CauseInfo& rhs);
DFL_MDIB_EXPIMP bool operator==(const CauseInfoBuilder& lhs, const CauseInfoBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const CauseInfoBuilder& lhs, const CauseInfo& rhs);
bool operator==(const CauseInfo& lhs, const CauseInfoBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const CauseInfo& lhs, const CauseInfo& rhs);
bool operator!=(const CauseInfoBuilder& lhs, const CauseInfoBuilder& rhs);
bool operator!=(const CauseInfo& lhs, const CauseInfoBuilder& rhs);
bool operator!=(const CauseInfoBuilder& lhs, const CauseInfo& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref CauseInfo
 * @ingroup Mdib
 */
/// @{
CauseInfoBuilder getBuilder(const CauseInfo& causeInfo);
CauseInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<CauseInfo>>& causeInfo);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const CauseInfo& lhs, const CauseInfo& rhs);

inline CauseInfoBuilder::CauseInfoBuilder(const CauseInfo& causeInfo) :
    m_remedyInfo(causeInfo.remedyInfo()),
    m_description(causeInfo.description()),
    m_extensions(causeInfo.extensions())
{
}

inline CauseInfoBuilder::CauseInfoBuilder(const DFL::NotNull<SharedPtr<CauseInfo>>& causeInfo) :
    m_remedyInfo(causeInfo->remedyInfo()),
    m_description(causeInfo->description()),
    m_extensions(causeInfo->extensions())
{
}

inline CauseInfoBuilder& CauseInfoBuilder::operator=(const CauseInfo& causeInfo)
{
    m_remedyInfo = causeInfo.remedyInfo();
    m_description = causeInfo.description();
    m_extensions = causeInfo.extensions();
    return *this;
}

inline CauseInfo CauseInfoBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return CauseInfo(m_remedyInfo, m_description, m_extensions);
}

inline bool CauseInfoBuilder::isChanged(const CauseInfo& base) const
{
    return *this != base;
}

inline CauseInfoBuilder& CauseInfoBuilder::remedyInfo(const boost::optional<RemedyInfo>& remedyInfo)
{
    m_remedyInfo = remedyInfo;
    return *this;
}

inline CauseInfoBuilder& CauseInfoBuilder::remedyInfo(boost::optional<RemedyInfo>&& remedyInfo)
{
    m_remedyInfo = std::move(remedyInfo);
    return *this;
}

inline boost::optional<RemedyInfo>& CauseInfoBuilder::remedyInfo()
{
    return m_remedyInfo;
}

inline const boost::optional<RemedyInfo>& CauseInfoBuilder::remedyInfo() const
{
    return m_remedyInfo;
}

inline CauseInfoBuilder& CauseInfoBuilder::description(const LocalizedTexts& description)
{
    m_description = description;
    return *this;
}

inline CauseInfoBuilder& CauseInfoBuilder::description(LocalizedTexts&& description)
{
    m_description = std::move(description);
    return *this;
}

inline LocalizedTexts& CauseInfoBuilder::description()
{
    return m_description;
}

inline const LocalizedTexts& CauseInfoBuilder::description() const
{
    return m_description;
}

inline CauseInfoBuilder& CauseInfoBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline CauseInfoBuilder& CauseInfoBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& CauseInfoBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& CauseInfoBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const CauseInfo& lhs, const CauseInfoBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const CauseInfoBuilder& lhs, const CauseInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const CauseInfo& lhs, const CauseInfoBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const CauseInfoBuilder& lhs, const CauseInfo& rhs)
{
    return !(lhs == rhs);
}

inline CauseInfoBuilder getBuilder(const CauseInfo& causeInfo)
{
    return CauseInfoBuilder(causeInfo);
}

inline CauseInfoBuilder getBuilder(const DFL::NotNull<SharedPtr<CauseInfo>>& causeInfo)
{
    return CauseInfoBuilder(causeInfo);
}

}
}
