/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Alert/LimitAlertConditionState.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref LimitAlertConditionState
 * @ingroup Mdib
 */
class LimitAlertConditionStateBuilder
{
    public:
        /// @brief Typedef to the immutable @ref LimitAlertConditionState
        using BuiltType = LimitAlertConditionState;

        /// @brief Builder based on given immutable @ref LimitAlertConditionState
        explicit LimitAlertConditionStateBuilder(const LimitAlertConditionState& limitAlertConditionState=LimitAlertConditionState());

        /// @brief Builder based on given immutable @ref LimitAlertConditionState
        explicit LimitAlertConditionStateBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionState>>& limitAlertConditionState);

        /// @brief Overwrite all values with given immutable @ref LimitAlertConditionState
        LimitAlertConditionStateBuilder& operator=(const LimitAlertConditionState& limitAlertConditionState);

        /// @brief Explicit conversion to immutable @ref LimitAlertConditionState
        LimitAlertConditionState build() const;

        /// @brief Test whether the builder differs from the immutable @ref LimitAlertConditionState
        bool isChanged(const LimitAlertConditionState& base) const;

        /// @brief Setter for activationState
        /// @{
        LimitAlertConditionStateBuilder& activationState(AlertActivation activationState);
        /// @}

        /// @brief Setter for actualConditionGenerationDelay
        /// @{
        LimitAlertConditionStateBuilder& actualConditionGenerationDelay(const boost::optional<Duration>& actualConditionGenerationDelay);
        LimitAlertConditionStateBuilder& actualConditionGenerationDelay(boost::optional<Duration>&& actualConditionGenerationDelay);
        /// @}

        /// @brief Setter for actualPriority
        /// @{
        LimitAlertConditionStateBuilder& actualPriority(boost::optional<AlertConditionPriority> actualPriority);
        /// @}

        /// @brief Setter for rank
        /// @{
        LimitAlertConditionStateBuilder& rank(const boost::optional<Rank>& rank);
        LimitAlertConditionStateBuilder& rank(boost::optional<Rank>&& rank);
        /// @}

        /// @brief Setter for presence
        /// @{
        LimitAlertConditionStateBuilder& presence(AlertConditionPresence presence);
        /// @}

        /// @brief Setter for determinationTime
        /// @{
        LimitAlertConditionStateBuilder& determinationTime(const boost::optional<Timestamp>& determinationTime);
        LimitAlertConditionStateBuilder& determinationTime(boost::optional<Timestamp>&& determinationTime);
        /// @}

        /// @brief Setter for autoLimitActivationState
        /// @{
        LimitAlertConditionStateBuilder& autoLimitActivationState(boost::optional<AlertActivation> autoLimitActivationState);
        /// @}

        /// @brief Setter for monitoredAlertLimits
        /// @{
        LimitAlertConditionStateBuilder& monitoredAlertLimits(AlertConditionMonitoredLimits monitoredAlertLimits);
        /// @}

        /// @brief Setter for limits
        /// @{
        LimitAlertConditionStateBuilder& limits(const Range& limits);
        LimitAlertConditionStateBuilder& limits(Range&& limits);
        /// @}

        /// @brief Setter for extensions
        /// @{
        LimitAlertConditionStateBuilder& extensions(const ExtensionTypes& extensions);
        LimitAlertConditionStateBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for activationState
        /// @{
        AlertActivation& activationState();
        AlertActivation activationState() const;
        /// @}

        /// @brief Getter for actualConditionGenerationDelay
        /// @{
        boost::optional<Duration>& actualConditionGenerationDelay();
        const boost::optional<Duration>& actualConditionGenerationDelay() const;
        /// @}

        /// @brief Getter for actualPriority
        /// @{
        boost::optional<AlertConditionPriority>& actualPriority();
        boost::optional<AlertConditionPriority> actualPriority() const;
        /// @}

        /// @brief Getter for rank
        /// @{
        boost::optional<Rank>& rank();
        const boost::optional<Rank>& rank() const;
        /// @}

        /// @brief Getter for presence
        /// @{
        AlertConditionPresence& presence();
        AlertConditionPresence presence() const;
        /// @}

        /// @brief Getter for determinationTime
        /// @{
        boost::optional<Timestamp>& determinationTime();
        const boost::optional<Timestamp>& determinationTime() const;
        /// @}

        /// @brief Getter for autoLimitActivationState
        /// @{
        boost::optional<AlertActivation>& autoLimitActivationState();
        boost::optional<AlertActivation> autoLimitActivationState() const;
        /// @}

        /// @brief Getter for monitoredAlertLimits
        /// @{
        AlertConditionMonitoredLimits& monitoredAlertLimits();
        AlertConditionMonitoredLimits monitoredAlertLimits() const;
        /// @}

        /// @brief Getter for limits
        /// @{
        Range& limits();
        const Range& limits() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        AlertActivation m_activationState;
        boost::optional<Duration> m_actualConditionGenerationDelay;
        boost::optional<AlertConditionPriority> m_actualPriority;
        boost::optional<Rank> m_rank;
        AlertConditionPresence m_presence;
        boost::optional<Timestamp> m_determinationTime;
        boost::optional<AlertActivation> m_autoLimitActivationState;
        AlertConditionMonitoredLimits m_monitoredAlertLimits;
        Range m_limits;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionState& lhs, const LimitAlertConditionState& rhs);
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionStateBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionState& rhs);
bool operator==(const LimitAlertConditionState& lhs, const LimitAlertConditionStateBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const LimitAlertConditionState& lhs, const LimitAlertConditionState& rhs);
bool operator!=(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionStateBuilder& rhs);
bool operator!=(const LimitAlertConditionState& lhs, const LimitAlertConditionStateBuilder& rhs);
bool operator!=(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionState& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref LimitAlertConditionState
 * @ingroup Mdib
 */
/// @{
LimitAlertConditionStateBuilder getBuilder(const LimitAlertConditionState& limitAlertConditionState);
LimitAlertConditionStateBuilder getBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionState>>& limitAlertConditionState);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const LimitAlertConditionState& lhs, const LimitAlertConditionState& rhs);

inline LimitAlertConditionStateBuilder::LimitAlertConditionStateBuilder(const LimitAlertConditionState& limitAlertConditionState) :
    m_activationState(limitAlertConditionState.activationState()),
    m_actualConditionGenerationDelay(limitAlertConditionState.actualConditionGenerationDelay()),
    m_actualPriority(limitAlertConditionState.actualPriority()),
    m_rank(limitAlertConditionState.rank()),
    m_presence(limitAlertConditionState.presence()),
    m_determinationTime(limitAlertConditionState.determinationTime()),
    m_autoLimitActivationState(limitAlertConditionState.autoLimitActivationState()),
    m_monitoredAlertLimits(limitAlertConditionState.monitoredAlertLimits()),
    m_limits(limitAlertConditionState.limits()),
    m_extensions(limitAlertConditionState.extensions())
{
}

inline LimitAlertConditionStateBuilder::LimitAlertConditionStateBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionState>>& limitAlertConditionState) :
    m_activationState(limitAlertConditionState->activationState()),
    m_actualConditionGenerationDelay(limitAlertConditionState->actualConditionGenerationDelay()),
    m_actualPriority(limitAlertConditionState->actualPriority()),
    m_rank(limitAlertConditionState->rank()),
    m_presence(limitAlertConditionState->presence()),
    m_determinationTime(limitAlertConditionState->determinationTime()),
    m_autoLimitActivationState(limitAlertConditionState->autoLimitActivationState()),
    m_monitoredAlertLimits(limitAlertConditionState->monitoredAlertLimits()),
    m_limits(limitAlertConditionState->limits()),
    m_extensions(limitAlertConditionState->extensions())
{
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::operator=(const LimitAlertConditionState& limitAlertConditionState)
{
    m_activationState = limitAlertConditionState.activationState();
    m_actualConditionGenerationDelay = limitAlertConditionState.actualConditionGenerationDelay();
    m_actualPriority = limitAlertConditionState.actualPriority();
    m_rank = limitAlertConditionState.rank();
    m_presence = limitAlertConditionState.presence();
    m_determinationTime = limitAlertConditionState.determinationTime();
    m_autoLimitActivationState = limitAlertConditionState.autoLimitActivationState();
    m_monitoredAlertLimits = limitAlertConditionState.monitoredAlertLimits();
    m_limits = limitAlertConditionState.limits();
    m_extensions = limitAlertConditionState.extensions();
    return *this;
}

inline LimitAlertConditionState LimitAlertConditionStateBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return LimitAlertConditionState(m_activationState, m_actualConditionGenerationDelay, m_actualPriority, m_rank, m_presence, m_determinationTime, m_autoLimitActivationState, m_monitoredAlertLimits, m_limits, m_extensions);
}

inline bool LimitAlertConditionStateBuilder::isChanged(const LimitAlertConditionState& base) const
{
    return *this != base;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::activationState(AlertActivation activationState)
{
    m_activationState = activationState;
    return *this;
}

inline AlertActivation& LimitAlertConditionStateBuilder::activationState()
{
    return m_activationState;
}

inline AlertActivation LimitAlertConditionStateBuilder::activationState() const
{
    return m_activationState;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::actualConditionGenerationDelay(const boost::optional<Duration>& actualConditionGenerationDelay)
{
    m_actualConditionGenerationDelay = actualConditionGenerationDelay;
    return *this;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::actualConditionGenerationDelay(boost::optional<Duration>&& actualConditionGenerationDelay)
{
    m_actualConditionGenerationDelay = std::move(actualConditionGenerationDelay);
    return *this;
}

inline boost::optional<Duration>& LimitAlertConditionStateBuilder::actualConditionGenerationDelay()
{
    return m_actualConditionGenerationDelay;
}

inline const boost::optional<Duration>& LimitAlertConditionStateBuilder::actualConditionGenerationDelay() const
{
    return m_actualConditionGenerationDelay;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::actualPriority(boost::optional<AlertConditionPriority> actualPriority)
{
    m_actualPriority = actualPriority;
    return *this;
}

inline boost::optional<AlertConditionPriority>& LimitAlertConditionStateBuilder::actualPriority()
{
    return m_actualPriority;
}

inline boost::optional<AlertConditionPriority> LimitAlertConditionStateBuilder::actualPriority() const
{
    return m_actualPriority;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::rank(const boost::optional<Rank>& rank)
{
    m_rank = rank;
    return *this;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::rank(boost::optional<Rank>&& rank)
{
    m_rank = std::move(rank);
    return *this;
}

inline boost::optional<Rank>& LimitAlertConditionStateBuilder::rank()
{
    return m_rank;
}

inline const boost::optional<Rank>& LimitAlertConditionStateBuilder::rank() const
{
    return m_rank;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::presence(AlertConditionPresence presence)
{
    m_presence = presence;
    return *this;
}

inline AlertConditionPresence& LimitAlertConditionStateBuilder::presence()
{
    return m_presence;
}

inline AlertConditionPresence LimitAlertConditionStateBuilder::presence() const
{
    return m_presence;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::determinationTime(const boost::optional<Timestamp>& determinationTime)
{
    m_determinationTime = determinationTime;
    return *this;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::determinationTime(boost::optional<Timestamp>&& determinationTime)
{
    m_determinationTime = std::move(determinationTime);
    return *this;
}

inline boost::optional<Timestamp>& LimitAlertConditionStateBuilder::determinationTime()
{
    return m_determinationTime;
}

inline const boost::optional<Timestamp>& LimitAlertConditionStateBuilder::determinationTime() const
{
    return m_determinationTime;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::autoLimitActivationState(boost::optional<AlertActivation> autoLimitActivationState)
{
    m_autoLimitActivationState = autoLimitActivationState;
    return *this;
}

inline boost::optional<AlertActivation>& LimitAlertConditionStateBuilder::autoLimitActivationState()
{
    return m_autoLimitActivationState;
}

inline boost::optional<AlertActivation> LimitAlertConditionStateBuilder::autoLimitActivationState() const
{
    return m_autoLimitActivationState;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::monitoredAlertLimits(AlertConditionMonitoredLimits monitoredAlertLimits)
{
    m_monitoredAlertLimits = monitoredAlertLimits;
    return *this;
}

inline AlertConditionMonitoredLimits& LimitAlertConditionStateBuilder::monitoredAlertLimits()
{
    return m_monitoredAlertLimits;
}

inline AlertConditionMonitoredLimits LimitAlertConditionStateBuilder::monitoredAlertLimits() const
{
    return m_monitoredAlertLimits;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::limits(const Range& limits)
{
    m_limits = limits;
    return *this;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::limits(Range&& limits)
{
    m_limits = std::move(limits);
    return *this;
}

inline Range& LimitAlertConditionStateBuilder::limits()
{
    return m_limits;
}

inline const Range& LimitAlertConditionStateBuilder::limits() const
{
    return m_limits;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline LimitAlertConditionStateBuilder& LimitAlertConditionStateBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& LimitAlertConditionStateBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& LimitAlertConditionStateBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const LimitAlertConditionState& lhs, const LimitAlertConditionStateBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const LimitAlertConditionState& lhs, const LimitAlertConditionStateBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const LimitAlertConditionStateBuilder& lhs, const LimitAlertConditionState& rhs)
{
    return !(lhs == rhs);
}

inline LimitAlertConditionStateBuilder getBuilder(const LimitAlertConditionState& limitAlertConditionState)
{
    return LimitAlertConditionStateBuilder(limitAlertConditionState);
}

inline LimitAlertConditionStateBuilder getBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionState>>& limitAlertConditionState)
{
    return LimitAlertConditionStateBuilder(limitAlertConditionState);
}

}
}
