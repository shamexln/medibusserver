/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <Framework/Mdib/Public/Model/Alert/AlertSignalDescriptor.h>
#include <Framework/Chrono/Public/DurationSerialize.h>
#include <Framework/Mdib/Public/Model/CodedValueSerialize.h>
#include <Framework/Mdib/Public/Model/ExtensionTypeSerialize.h>
#include <Framework/Mdib/Public/Model/HandleSerialize.h>
#include <Framework/Utils/Public/SerializationHelper.h>

#include <boost/serialization/nvp.hpp>
#include <boost/serialization/split_free.hpp>
#include <boost/serialization/version.hpp>
#include <boost/serialization/optional.hpp>
#include <boost/serialization/vector.hpp>

#include <utility>

BOOST_SERIALIZATION_SPLIT_FREE(::DFL::Mdib::AlertSignalDescriptor)

BOOST_CLASS_VERSION(::DFL::Mdib::AlertSignalDescriptor, 0)

BOOST_CLASS_TRACKING(::DFL::Mdib::AlertSignalDescriptor, boost::serialization::track_never)

namespace boost
{
namespace serialization
{
/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void save(Archive& ar, const ::DFL::Mdib::AlertSignalDescriptor& src, const unsigned int /*fileVersion*/)
{
    const auto& safetyClassification = src.safetyClassification();
    ar & make_nvp("SafetyClassification", safetyClassification);

    const auto& type = src.type();
    DFL::Serialization::saveNvpOptional(ar, "Type", type);

    const auto& conditionSignaledHandle = src.conditionSignaledHandle();
    ar & make_nvp("ConditionSignaledHandle", conditionSignaledHandle);

    const auto& manifestation = src.manifestation();
    ar & make_nvp("Manifestation", manifestation);

    const auto& latching = src.latching();
    ar & make_nvp("Latching", latching);

    const auto& defaultSignalGenerationDelay = src.defaultSignalGenerationDelay();
    ar & make_nvp("DefaultSignalGenerationDelay", defaultSignalGenerationDelay);

    const auto& minSignalGenerationDelay = src.minSignalGenerationDelay();
    ar & make_nvp("MinSignalGenerationDelay", minSignalGenerationDelay);

    const auto& maxSignalGenerationDelay = src.maxSignalGenerationDelay();
    ar & make_nvp("MaxSignalGenerationDelay", maxSignalGenerationDelay);

    const auto& signalDelegationSupport = src.signalDelegationSupport();
    ar & make_nvp("SignalDelegationSupport", signalDelegationSupport);

    const auto& acknowledgmentSupport = src.acknowledgmentSupport();
    ar & make_nvp("AcknowledgmentSupport", acknowledgmentSupport);

    const auto& acknowledgeTimeout = src.acknowledgeTimeout();
    ar & make_nvp("AcknowledgeTimeout", acknowledgeTimeout);

    const auto& extensions = src.extensions();
    ar & make_nvp("Extensions", extensions);
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load_construct_data(Archive& ar, ::DFL::Mdib::AlertSignalDescriptor* dst, const unsigned int /*version*/)
{
    ::DFL::Mdib::SafetyClassification safetyClassification{};
    ar & make_nvp("SafetyClassification", safetyClassification);

    boost::optional<::DFL::Mdib::CodedValue> type{};
    DFL::Serialization::loadNvpOptional(ar, "Type", type);

    ::DFL::Mdib::Handle conditionSignaledHandle{};
    ar & make_nvp("ConditionSignaledHandle", conditionSignaledHandle);

    ::DFL::Mdib::AlertSignalManifestation manifestation{};
    ar & make_nvp("Manifestation", manifestation);

    ::DFL::Mdib::Latching latching{};
    ar & make_nvp("Latching", latching);

    ::DFL::Mdib::Duration defaultSignalGenerationDelay{};
    ar & make_nvp("DefaultSignalGenerationDelay", defaultSignalGenerationDelay);

    boost::optional<::DFL::Mdib::Duration> minSignalGenerationDelay{};
    ar & make_nvp("MinSignalGenerationDelay", minSignalGenerationDelay);

    boost::optional<::DFL::Mdib::Duration> maxSignalGenerationDelay{};
    ar & make_nvp("MaxSignalGenerationDelay", maxSignalGenerationDelay);

    ::DFL::Mdib::SignalDelegation signalDelegationSupport{};
    ar & make_nvp("SignalDelegationSupport", signalDelegationSupport);

    ::DFL::Mdib::AcknowledgmentSupport acknowledgmentSupport{};
    ar & make_nvp("AcknowledgmentSupport", acknowledgmentSupport);

    boost::optional<::DFL::Mdib::Duration> acknowledgeTimeout{};
    ar & make_nvp("AcknowledgeTimeout", acknowledgeTimeout);

    ::DFL::Mdib::ExtensionTypes extensions{};
    ar & make_nvp("Extensions", extensions);

    ::new(dst) ::DFL::Mdib::AlertSignalDescriptor(
        safetyClassification,
        std::move(type),
        conditionSignaledHandle,
        manifestation,
        latching,
        defaultSignalGenerationDelay,
        minSignalGenerationDelay,
        maxSignalGenerationDelay,
        signalDelegationSupport,
        acknowledgmentSupport,
        acknowledgeTimeout,
        std::move(extensions));
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load(Archive& /*ar*/, ::DFL::Mdib::AlertSignalDescriptor& /*dst*/, const unsigned int /*version*/)
{
}

}
}
