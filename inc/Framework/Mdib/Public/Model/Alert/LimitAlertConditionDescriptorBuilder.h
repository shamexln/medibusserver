/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Alert/LimitAlertConditionDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref LimitAlertConditionDescriptor
 * @ingroup Mdib
 */
class LimitAlertConditionDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref LimitAlertConditionDescriptor
        using BuiltType = LimitAlertConditionDescriptor;

        /// @brief Builder based on given immutable @ref LimitAlertConditionDescriptor
        explicit LimitAlertConditionDescriptorBuilder(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor=LimitAlertConditionDescriptor());

        /// @brief Builder based on given immutable @ref LimitAlertConditionDescriptor
        explicit LimitAlertConditionDescriptorBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionDescriptor>>& limitAlertConditionDescriptor);

        /// @brief Overwrite all values with given immutable @ref LimitAlertConditionDescriptor
        LimitAlertConditionDescriptorBuilder& operator=(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor);

        /// @brief Explicit conversion to immutable @ref LimitAlertConditionDescriptor
        LimitAlertConditionDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref LimitAlertConditionDescriptor
        bool isChanged(const LimitAlertConditionDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        LimitAlertConditionDescriptorBuilder& safetyClassification(SafetyClassification safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        LimitAlertConditionDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        LimitAlertConditionDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for kind
        /// @{
        LimitAlertConditionDescriptorBuilder& kind(AlertConditionKind kind);
        /// @}

        /// @brief Setter for priority
        /// @{
        LimitAlertConditionDescriptorBuilder& priority(AlertConditionPriority priority);
        /// @}

        /// @brief Setter for defaultConditionGenerationDelay
        /// @{
        LimitAlertConditionDescriptorBuilder& defaultConditionGenerationDelay(Duration defaultConditionGenerationDelay);
        /// @}

        /// @brief Setter for canEscalate
        /// @{
        LimitAlertConditionDescriptorBuilder& canEscalate(boost::optional<AlertConditionPriority> canEscalate);
        /// @}

        /// @brief Setter for canDeescalate
        /// @{
        LimitAlertConditionDescriptorBuilder& canDeescalate(boost::optional<AlertConditionPriority> canDeescalate);
        /// @}

        /// @brief Setter for sources
        /// @{
        LimitAlertConditionDescriptorBuilder& sources(const Handles& sources);
        LimitAlertConditionDescriptorBuilder& sources(Handles&& sources);
        /// @}

        /// @brief Setter for causeInfos
        /// @{
        LimitAlertConditionDescriptorBuilder& causeInfos(const CauseInfos& causeInfos);
        LimitAlertConditionDescriptorBuilder& causeInfos(CauseInfos&& causeInfos);
        /// @}

        /// @brief Setter for autoLimitSupported
        /// @{
        LimitAlertConditionDescriptorBuilder& autoLimitSupported(bool autoLimitSupported);
        /// @}

        /// @brief Setter for maxLimits
        /// @{
        LimitAlertConditionDescriptorBuilder& maxLimits(const boost::optional<Range>& maxLimits);
        LimitAlertConditionDescriptorBuilder& maxLimits(boost::optional<Range>&& maxLimits);
        /// @}

        /// @brief Setter for extensions
        /// @{
        LimitAlertConditionDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        LimitAlertConditionDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        SafetyClassification& safetyClassification();
        SafetyClassification safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for kind
        /// @{
        AlertConditionKind& kind();
        AlertConditionKind kind() const;
        /// @}

        /// @brief Getter for priority
        /// @{
        AlertConditionPriority& priority();
        AlertConditionPriority priority() const;
        /// @}

        /// @brief Getter for defaultConditionGenerationDelay
        /// @{
        Duration& defaultConditionGenerationDelay();
        Duration defaultConditionGenerationDelay() const;
        /// @}

        /// @brief Getter for canEscalate
        /// @{
        boost::optional<AlertConditionPriority>& canEscalate();
        boost::optional<AlertConditionPriority> canEscalate() const;
        /// @}

        /// @brief Getter for canDeescalate
        /// @{
        boost::optional<AlertConditionPriority>& canDeescalate();
        boost::optional<AlertConditionPriority> canDeescalate() const;
        /// @}

        /// @brief Getter for sources
        /// @{
        Handles& sources();
        const Handles& sources() const;
        /// @}

        /// @brief Getter for causeInfos
        /// @{
        CauseInfos& causeInfos();
        const CauseInfos& causeInfos() const;
        /// @}

        /// @brief Getter for autoLimitSupported
        /// @{
        bool& autoLimitSupported();
        bool autoLimitSupported() const;
        /// @}

        /// @brief Getter for maxLimits
        /// @{
        boost::optional<Range>& maxLimits();
        const boost::optional<Range>& maxLimits() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        SafetyClassification m_safetyClassification;
        boost::optional<CodedValue> m_type;
        AlertConditionKind m_kind;
        AlertConditionPriority m_priority;
        Duration m_defaultConditionGenerationDelay;
        boost::optional<AlertConditionPriority> m_canEscalate;
        boost::optional<AlertConditionPriority> m_canDeescalate;
        Handles m_sources;
        CauseInfos m_causeInfos;
        bool m_autoLimitSupported;
        boost::optional<Range> m_maxLimits;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptor& rhs);
bool operator==(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptor& rhs);
bool operator!=(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptorBuilder& rhs);
bool operator!=(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptorBuilder& rhs);
bool operator!=(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref LimitAlertConditionDescriptor
 * @ingroup Mdib
 */
/// @{
LimitAlertConditionDescriptorBuilder getBuilder(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor);
LimitAlertConditionDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionDescriptor>>& limitAlertConditionDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptor& rhs);

inline LimitAlertConditionDescriptorBuilder::LimitAlertConditionDescriptorBuilder(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor) :
    m_safetyClassification(limitAlertConditionDescriptor.safetyClassification()),
    m_type(limitAlertConditionDescriptor.type()),
    m_kind(limitAlertConditionDescriptor.kind()),
    m_priority(limitAlertConditionDescriptor.priority()),
    m_defaultConditionGenerationDelay(limitAlertConditionDescriptor.defaultConditionGenerationDelay()),
    m_canEscalate(limitAlertConditionDescriptor.canEscalate()),
    m_canDeescalate(limitAlertConditionDescriptor.canDeescalate()),
    m_sources(limitAlertConditionDescriptor.sources()),
    m_causeInfos(limitAlertConditionDescriptor.causeInfos()),
    m_autoLimitSupported(limitAlertConditionDescriptor.autoLimitSupported()),
    m_maxLimits(limitAlertConditionDescriptor.maxLimits()),
    m_extensions(limitAlertConditionDescriptor.extensions())
{
}

inline LimitAlertConditionDescriptorBuilder::LimitAlertConditionDescriptorBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionDescriptor>>& limitAlertConditionDescriptor) :
    m_safetyClassification(limitAlertConditionDescriptor->safetyClassification()),
    m_type(limitAlertConditionDescriptor->type()),
    m_kind(limitAlertConditionDescriptor->kind()),
    m_priority(limitAlertConditionDescriptor->priority()),
    m_defaultConditionGenerationDelay(limitAlertConditionDescriptor->defaultConditionGenerationDelay()),
    m_canEscalate(limitAlertConditionDescriptor->canEscalate()),
    m_canDeescalate(limitAlertConditionDescriptor->canDeescalate()),
    m_sources(limitAlertConditionDescriptor->sources()),
    m_causeInfos(limitAlertConditionDescriptor->causeInfos()),
    m_autoLimitSupported(limitAlertConditionDescriptor->autoLimitSupported()),
    m_maxLimits(limitAlertConditionDescriptor->maxLimits()),
    m_extensions(limitAlertConditionDescriptor->extensions())
{
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::operator=(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor)
{
    m_safetyClassification = limitAlertConditionDescriptor.safetyClassification();
    m_type = limitAlertConditionDescriptor.type();
    m_kind = limitAlertConditionDescriptor.kind();
    m_priority = limitAlertConditionDescriptor.priority();
    m_defaultConditionGenerationDelay = limitAlertConditionDescriptor.defaultConditionGenerationDelay();
    m_canEscalate = limitAlertConditionDescriptor.canEscalate();
    m_canDeescalate = limitAlertConditionDescriptor.canDeescalate();
    m_sources = limitAlertConditionDescriptor.sources();
    m_causeInfos = limitAlertConditionDescriptor.causeInfos();
    m_autoLimitSupported = limitAlertConditionDescriptor.autoLimitSupported();
    m_maxLimits = limitAlertConditionDescriptor.maxLimits();
    m_extensions = limitAlertConditionDescriptor.extensions();
    return *this;
}

inline LimitAlertConditionDescriptor LimitAlertConditionDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return LimitAlertConditionDescriptor(m_safetyClassification, m_type, m_kind, m_priority, m_defaultConditionGenerationDelay, m_canEscalate, m_canDeescalate, m_sources, m_causeInfos, m_autoLimitSupported, m_maxLimits, m_extensions);
}

inline bool LimitAlertConditionDescriptorBuilder::isChanged(const LimitAlertConditionDescriptor& base) const
{
    return *this != base;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::safetyClassification(SafetyClassification safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline SafetyClassification& LimitAlertConditionDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline SafetyClassification LimitAlertConditionDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& LimitAlertConditionDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& LimitAlertConditionDescriptorBuilder::type() const
{
    return m_type;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::kind(AlertConditionKind kind)
{
    m_kind = kind;
    return *this;
}

inline AlertConditionKind& LimitAlertConditionDescriptorBuilder::kind()
{
    return m_kind;
}

inline AlertConditionKind LimitAlertConditionDescriptorBuilder::kind() const
{
    return m_kind;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::priority(AlertConditionPriority priority)
{
    m_priority = priority;
    return *this;
}

inline AlertConditionPriority& LimitAlertConditionDescriptorBuilder::priority()
{
    return m_priority;
}

inline AlertConditionPriority LimitAlertConditionDescriptorBuilder::priority() const
{
    return m_priority;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::defaultConditionGenerationDelay(Duration defaultConditionGenerationDelay)
{
    m_defaultConditionGenerationDelay = defaultConditionGenerationDelay;
    return *this;
}

inline Duration& LimitAlertConditionDescriptorBuilder::defaultConditionGenerationDelay()
{
    return m_defaultConditionGenerationDelay;
}

inline Duration LimitAlertConditionDescriptorBuilder::defaultConditionGenerationDelay() const
{
    return m_defaultConditionGenerationDelay;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::canEscalate(boost::optional<AlertConditionPriority> canEscalate)
{
    m_canEscalate = canEscalate;
    return *this;
}

inline boost::optional<AlertConditionPriority>& LimitAlertConditionDescriptorBuilder::canEscalate()
{
    return m_canEscalate;
}

inline boost::optional<AlertConditionPriority> LimitAlertConditionDescriptorBuilder::canEscalate() const
{
    return m_canEscalate;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::canDeescalate(boost::optional<AlertConditionPriority> canDeescalate)
{
    m_canDeescalate = canDeescalate;
    return *this;
}

inline boost::optional<AlertConditionPriority>& LimitAlertConditionDescriptorBuilder::canDeescalate()
{
    return m_canDeescalate;
}

inline boost::optional<AlertConditionPriority> LimitAlertConditionDescriptorBuilder::canDeescalate() const
{
    return m_canDeescalate;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::sources(const Handles& sources)
{
    m_sources = sources;
    return *this;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::sources(Handles&& sources)
{
    m_sources = std::move(sources);
    return *this;
}

inline Handles& LimitAlertConditionDescriptorBuilder::sources()
{
    return m_sources;
}

inline const Handles& LimitAlertConditionDescriptorBuilder::sources() const
{
    return m_sources;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::causeInfos(const CauseInfos& causeInfos)
{
    m_causeInfos = causeInfos;
    return *this;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::causeInfos(CauseInfos&& causeInfos)
{
    m_causeInfos = std::move(causeInfos);
    return *this;
}

inline CauseInfos& LimitAlertConditionDescriptorBuilder::causeInfos()
{
    return m_causeInfos;
}

inline const CauseInfos& LimitAlertConditionDescriptorBuilder::causeInfos() const
{
    return m_causeInfos;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::autoLimitSupported(bool autoLimitSupported)
{
    m_autoLimitSupported = autoLimitSupported;
    return *this;
}

inline bool& LimitAlertConditionDescriptorBuilder::autoLimitSupported()
{
    return m_autoLimitSupported;
}

inline bool LimitAlertConditionDescriptorBuilder::autoLimitSupported() const
{
    return m_autoLimitSupported;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::maxLimits(const boost::optional<Range>& maxLimits)
{
    m_maxLimits = maxLimits;
    return *this;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::maxLimits(boost::optional<Range>&& maxLimits)
{
    m_maxLimits = std::move(maxLimits);
    return *this;
}

inline boost::optional<Range>& LimitAlertConditionDescriptorBuilder::maxLimits()
{
    return m_maxLimits;
}

inline const boost::optional<Range>& LimitAlertConditionDescriptorBuilder::maxLimits() const
{
    return m_maxLimits;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline LimitAlertConditionDescriptorBuilder& LimitAlertConditionDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& LimitAlertConditionDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& LimitAlertConditionDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const LimitAlertConditionDescriptor& lhs, const LimitAlertConditionDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const LimitAlertConditionDescriptorBuilder& lhs, const LimitAlertConditionDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline LimitAlertConditionDescriptorBuilder getBuilder(const LimitAlertConditionDescriptor& limitAlertConditionDescriptor)
{
    return LimitAlertConditionDescriptorBuilder(limitAlertConditionDescriptor);
}

inline LimitAlertConditionDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<LimitAlertConditionDescriptor>>& limitAlertConditionDescriptor)
{
    return LimitAlertConditionDescriptorBuilder(limitAlertConditionDescriptor);
}

}
}
