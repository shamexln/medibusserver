/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <Framework/Mdib/Public/Model/Alert/LimitAlertConditionState.h>
#include <Framework/Chrono/Public/DurationSerialize.h>
#include <Framework/Chrono/Public/SystemTimeSerialize.h>
#include <Framework/Mdib/Public/Model/ExtensionTypeSerialize.h>
#include <Framework/Mdib/Public/Model/RangeSerialize.h>
#include <Framework/Utils/Public/SerializationHelper.h>

#include <boost/serialization/nvp.hpp>
#include <boost/serialization/split_free.hpp>
#include <boost/serialization/version.hpp>
#include <boost/serialization/optional.hpp>
#include <boost/serialization/vector.hpp>

#include <utility>

BOOST_SERIALIZATION_SPLIT_FREE(::DFL::Mdib::LimitAlertConditionState)

BOOST_CLASS_VERSION(::DFL::Mdib::LimitAlertConditionState, 0)

BOOST_CLASS_TRACKING(::DFL::Mdib::LimitAlertConditionState, boost::serialization::track_never)

namespace boost
{
namespace serialization
{
/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void save(Archive& ar, const ::DFL::Mdib::LimitAlertConditionState& src, const unsigned int /*fileVersion*/)
{
    const auto& activationState = src.activationState();
    ar & make_nvp("ActivationState", activationState);

    const auto& actualConditionGenerationDelay = src.actualConditionGenerationDelay();
    ar & make_nvp("ActualConditionGenerationDelay", actualConditionGenerationDelay);

    const auto& actualPriority = src.actualPriority();
    ar & make_nvp("ActualPriority", actualPriority);

    const auto& rank = src.rank();
    ar & make_nvp("Rank", rank);

    const auto& presence = src.presence();
    ar & make_nvp("Presence", presence);

    const auto& determinationTime = src.determinationTime();
    ar & make_nvp("DeterminationTime", determinationTime);

    const auto& autoLimitActivationState = src.autoLimitActivationState();
    ar & make_nvp("AutoLimitActivationState", autoLimitActivationState);

    const auto& monitoredAlertLimits = src.monitoredAlertLimits();
    ar & make_nvp("MonitoredAlertLimits", monitoredAlertLimits);

    const auto& limits = src.limits();
    ar & make_nvp("Limits", limits);

    const auto& extensions = src.extensions();
    ar & make_nvp("Extensions", extensions);
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load_construct_data(Archive& ar, ::DFL::Mdib::LimitAlertConditionState* dst, const unsigned int /*version*/)
{
    ::DFL::Mdib::AlertActivation activationState{};
    ar & make_nvp("ActivationState", activationState);

    boost::optional<::DFL::Mdib::Duration> actualConditionGenerationDelay{};
    ar & make_nvp("ActualConditionGenerationDelay", actualConditionGenerationDelay);

    boost::optional<::DFL::Mdib::AlertConditionPriority> actualPriority{};
    ar & make_nvp("ActualPriority", actualPriority);

    boost::optional<::DFL::Mdib::Rank> rank{};
    ar & make_nvp("Rank", rank);

    ::DFL::Mdib::AlertConditionPresence presence{};
    ar & make_nvp("Presence", presence);

    boost::optional<::DFL::Mdib::Timestamp> determinationTime{};
    ar & make_nvp("DeterminationTime", determinationTime);

    boost::optional<::DFL::Mdib::AlertActivation> autoLimitActivationState{};
    ar & make_nvp("AutoLimitActivationState", autoLimitActivationState);

    ::DFL::Mdib::AlertConditionMonitoredLimits monitoredAlertLimits{};
    ar & make_nvp("MonitoredAlertLimits", monitoredAlertLimits);

    ::DFL::Mdib::Range limits{};
    ar & make_nvp("Limits", limits);

    ::DFL::Mdib::ExtensionTypes extensions{};
    ar & make_nvp("Extensions", extensions);

    ::new(dst) ::DFL::Mdib::LimitAlertConditionState(
        activationState,
        actualConditionGenerationDelay,
        actualPriority,
        rank,
        presence,
        determinationTime,
        autoLimitActivationState,
        monitoredAlertLimits,
        limits,
        std::move(extensions));
}

/**
 * @brief Support for Boost Serialization.
 * @ingroup Mdib
 */
template<class Archive>
void load(Archive& /*ar*/, ::DFL::Mdib::LimitAlertConditionState& /*dst*/, const unsigned int /*version*/)
{
}

}
}
