/**************************************************************************************
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * THIS FILE IS GENERATED BY
 * modules\S32\Tools\MdibBuilders\RunGenerator.cmd
 *
 **************************************************************************************/

#pragma once

#include <memory>
#include <boost/optional.hpp>
#include <Framework/Mdib/Private/ExpImp.h>
#include <Framework/Mdib/Private/Utils/SmartPtrTypes.h>
#include <Framework/Utils/Public/NotNull.h>

#include <Framework/Mdib/Public/Model/Operation/SetMetricStateOperationDescriptor.h>

namespace DFL
{
namespace Mdib
{

/**
 * @brief Builder with fluent interface for @ref SetMetricStateOperationDescriptor
 * @ingroup Mdib
 */
class SetMetricStateOperationDescriptorBuilder
{
    public:
        /// @brief Typedef to the immutable @ref SetMetricStateOperationDescriptor
        using BuiltType = SetMetricStateOperationDescriptor;

        /// @brief Builder based on given immutable @ref SetMetricStateOperationDescriptor
        explicit SetMetricStateOperationDescriptorBuilder(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor=SetMetricStateOperationDescriptor());

        /// @brief Builder based on given immutable @ref SetMetricStateOperationDescriptor
        explicit SetMetricStateOperationDescriptorBuilder(const DFL::NotNull<SharedPtr<SetMetricStateOperationDescriptor>>& setMetricStateOperationDescriptor);

        /// @brief Overwrite all values with given immutable @ref SetMetricStateOperationDescriptor
        SetMetricStateOperationDescriptorBuilder& operator=(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor);

        /// @brief Explicit conversion to immutable @ref SetMetricStateOperationDescriptor
        SetMetricStateOperationDescriptor build() const;

        /// @brief Test whether the builder differs from the immutable @ref SetMetricStateOperationDescriptor
        bool isChanged(const SetMetricStateOperationDescriptor& base) const;

        /// @brief Setter for safetyClassification
        /// @{
        SetMetricStateOperationDescriptorBuilder& safetyClassification(boost::optional<SafetyClassification> safetyClassification);
        /// @}

        /// @brief Setter for type
        /// @{
        SetMetricStateOperationDescriptorBuilder& type(const boost::optional<CodedValue>& type);
        SetMetricStateOperationDescriptorBuilder& type(boost::optional<CodedValue>&& type);
        /// @}

        /// @brief Setter for operationTarget
        /// @{
        SetMetricStateOperationDescriptorBuilder& operationTarget(const Handle& operationTarget);
        SetMetricStateOperationDescriptorBuilder& operationTarget(Handle&& operationTarget);
        /// @}

        /// @brief Setter for maxTimeToFinish
        /// @{
        SetMetricStateOperationDescriptorBuilder& maxTimeToFinish(const boost::optional<Duration>& maxTimeToFinish);
        SetMetricStateOperationDescriptorBuilder& maxTimeToFinish(boost::optional<Duration>&& maxTimeToFinish);
        /// @}

        /// @brief Setter for invocationEffectiveTimeout
        /// @{
        SetMetricStateOperationDescriptorBuilder& invocationEffectiveTimeout(const boost::optional<Duration>& invocationEffectiveTimeout);
        SetMetricStateOperationDescriptorBuilder& invocationEffectiveTimeout(boost::optional<Duration>&& invocationEffectiveTimeout);
        /// @}

        /// @brief Setter for retriggerable
        /// @{
        SetMetricStateOperationDescriptorBuilder& retriggerable(Retriggerable retriggerable);
        /// @}

        /// @brief Setter for accessLevel
        /// @{
        SetMetricStateOperationDescriptorBuilder& accessLevel(AccessLevel accessLevel);
        /// @}

        /// @brief Setter for modifiableData
        /// @{
        SetMetricStateOperationDescriptorBuilder& modifiableData(const XPathExpressions& modifiableData);
        SetMetricStateOperationDescriptorBuilder& modifiableData(XPathExpressions&& modifiableData);
        /// @}

        /// @brief Setter for extensions
        /// @{
        SetMetricStateOperationDescriptorBuilder& extensions(const ExtensionTypes& extensions);
        SetMetricStateOperationDescriptorBuilder& extensions(ExtensionTypes&& extensions);
        /// @}

        /// @brief Getter for safetyClassification
        /// @{
        boost::optional<SafetyClassification>& safetyClassification();
        boost::optional<SafetyClassification> safetyClassification() const;
        /// @}

        /// @brief Getter for type
        /// @{
        boost::optional<CodedValue>& type();
        const boost::optional<CodedValue>& type() const;
        /// @}

        /// @brief Getter for operationTarget
        /// @{
        Handle& operationTarget();
        const Handle& operationTarget() const;
        /// @}

        /// @brief Getter for maxTimeToFinish
        /// @{
        boost::optional<Duration>& maxTimeToFinish();
        const boost::optional<Duration>& maxTimeToFinish() const;
        /// @}

        /// @brief Getter for invocationEffectiveTimeout
        /// @{
        boost::optional<Duration>& invocationEffectiveTimeout();
        const boost::optional<Duration>& invocationEffectiveTimeout() const;
        /// @}

        /// @brief Getter for retriggerable
        /// @{
        Retriggerable& retriggerable();
        Retriggerable retriggerable() const;
        /// @}

        /// @brief Getter for accessLevel
        /// @{
        AccessLevel& accessLevel();
        AccessLevel accessLevel() const;
        /// @}

        /// @brief Getter for modifiableData
        /// @{
        XPathExpressions& modifiableData();
        const XPathExpressions& modifiableData() const;
        /// @}

        /// @brief Getter for extensions
        /// @{
        ExtensionTypes& extensions();
        const ExtensionTypes& extensions() const;
        /// @}

    private:
        boost::optional<SafetyClassification> m_safetyClassification;
        boost::optional<CodedValue> m_type;
        Handle m_operationTarget;
        boost::optional<Duration> m_maxTimeToFinish;
        boost::optional<Duration> m_invocationEffectiveTimeout;
        Retriggerable m_retriggerable;
        AccessLevel m_accessLevel;
        XPathExpressions m_modifiableData;
        ExtensionTypes m_extensions;
};

/**
 * @brief Equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator==(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptor& rhs);
DFL_MDIB_EXPIMP bool operator==(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptorBuilder& rhs);
DFL_MDIB_EXPIMP bool operator==(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptor& rhs);
bool operator==(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptorBuilder& rhs);
/// @}

/**
 * @brief Not equal operator compares all members
 * @ingroup Mdib
 */
/// @{
DFL_MDIB_EXPIMP bool operator!=(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptor& rhs);
bool operator!=(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptorBuilder& rhs);
bool operator!=(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptorBuilder& rhs);
bool operator!=(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptor& rhs);
/// @}

/**
 * @brief Factory function to create %Builder based on given immutable @ref SetMetricStateOperationDescriptor
 * @ingroup Mdib
 */
/// @{
SetMetricStateOperationDescriptorBuilder getBuilder(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor);
SetMetricStateOperationDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<SetMetricStateOperationDescriptor>>& setMetricStateOperationDescriptor);
/// @}

/**
 * @brief Helper function throws runtime_error in case of a not equal member
 * @ingroup Mdib
 */
DFL_MDIB_EXPIMP void assertEqual(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptor& rhs);

inline SetMetricStateOperationDescriptorBuilder::SetMetricStateOperationDescriptorBuilder(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor) :
    m_safetyClassification(setMetricStateOperationDescriptor.safetyClassification()),
    m_type(setMetricStateOperationDescriptor.type()),
    m_operationTarget(setMetricStateOperationDescriptor.operationTarget()),
    m_maxTimeToFinish(setMetricStateOperationDescriptor.maxTimeToFinish()),
    m_invocationEffectiveTimeout(setMetricStateOperationDescriptor.invocationEffectiveTimeout()),
    m_retriggerable(setMetricStateOperationDescriptor.retriggerable()),
    m_accessLevel(setMetricStateOperationDescriptor.accessLevel()),
    m_modifiableData(setMetricStateOperationDescriptor.modifiableData()),
    m_extensions(setMetricStateOperationDescriptor.extensions())
{
}

inline SetMetricStateOperationDescriptorBuilder::SetMetricStateOperationDescriptorBuilder(const DFL::NotNull<SharedPtr<SetMetricStateOperationDescriptor>>& setMetricStateOperationDescriptor) :
    m_safetyClassification(setMetricStateOperationDescriptor->safetyClassification()),
    m_type(setMetricStateOperationDescriptor->type()),
    m_operationTarget(setMetricStateOperationDescriptor->operationTarget()),
    m_maxTimeToFinish(setMetricStateOperationDescriptor->maxTimeToFinish()),
    m_invocationEffectiveTimeout(setMetricStateOperationDescriptor->invocationEffectiveTimeout()),
    m_retriggerable(setMetricStateOperationDescriptor->retriggerable()),
    m_accessLevel(setMetricStateOperationDescriptor->accessLevel()),
    m_modifiableData(setMetricStateOperationDescriptor->modifiableData()),
    m_extensions(setMetricStateOperationDescriptor->extensions())
{
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::operator=(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor)
{
    m_safetyClassification = setMetricStateOperationDescriptor.safetyClassification();
    m_type = setMetricStateOperationDescriptor.type();
    m_operationTarget = setMetricStateOperationDescriptor.operationTarget();
    m_maxTimeToFinish = setMetricStateOperationDescriptor.maxTimeToFinish();
    m_invocationEffectiveTimeout = setMetricStateOperationDescriptor.invocationEffectiveTimeout();
    m_retriggerable = setMetricStateOperationDescriptor.retriggerable();
    m_accessLevel = setMetricStateOperationDescriptor.accessLevel();
    m_modifiableData = setMetricStateOperationDescriptor.modifiableData();
    m_extensions = setMetricStateOperationDescriptor.extensions();
    return *this;
}

inline SetMetricStateOperationDescriptor SetMetricStateOperationDescriptorBuilder::build() const
{
    // NOLINTNEXTLINE(modernize-return-braced-init-list)
    return SetMetricStateOperationDescriptor(m_safetyClassification, m_type, m_operationTarget, m_maxTimeToFinish, m_invocationEffectiveTimeout, m_retriggerable, m_accessLevel, m_modifiableData, m_extensions);
}

inline bool SetMetricStateOperationDescriptorBuilder::isChanged(const SetMetricStateOperationDescriptor& base) const
{
    return *this != base;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::safetyClassification(boost::optional<SafetyClassification> safetyClassification)
{
    m_safetyClassification = safetyClassification;
    return *this;
}

inline boost::optional<SafetyClassification>& SetMetricStateOperationDescriptorBuilder::safetyClassification()
{
    return m_safetyClassification;
}

inline boost::optional<SafetyClassification> SetMetricStateOperationDescriptorBuilder::safetyClassification() const
{
    return m_safetyClassification;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::type(const boost::optional<CodedValue>& type)
{
    m_type = type;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::type(boost::optional<CodedValue>&& type)
{
    m_type = std::move(type);
    return *this;
}

inline boost::optional<CodedValue>& SetMetricStateOperationDescriptorBuilder::type()
{
    return m_type;
}

inline const boost::optional<CodedValue>& SetMetricStateOperationDescriptorBuilder::type() const
{
    return m_type;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::operationTarget(const Handle& operationTarget)
{
    m_operationTarget = operationTarget;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::operationTarget(Handle&& operationTarget)
{
    m_operationTarget = std::move(operationTarget);
    return *this;
}

inline Handle& SetMetricStateOperationDescriptorBuilder::operationTarget()
{
    return m_operationTarget;
}

inline const Handle& SetMetricStateOperationDescriptorBuilder::operationTarget() const
{
    return m_operationTarget;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::maxTimeToFinish(const boost::optional<Duration>& maxTimeToFinish)
{
    m_maxTimeToFinish = maxTimeToFinish;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::maxTimeToFinish(boost::optional<Duration>&& maxTimeToFinish)
{
    m_maxTimeToFinish = std::move(maxTimeToFinish);
    return *this;
}

inline boost::optional<Duration>& SetMetricStateOperationDescriptorBuilder::maxTimeToFinish()
{
    return m_maxTimeToFinish;
}

inline const boost::optional<Duration>& SetMetricStateOperationDescriptorBuilder::maxTimeToFinish() const
{
    return m_maxTimeToFinish;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::invocationEffectiveTimeout(const boost::optional<Duration>& invocationEffectiveTimeout)
{
    m_invocationEffectiveTimeout = invocationEffectiveTimeout;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::invocationEffectiveTimeout(boost::optional<Duration>&& invocationEffectiveTimeout)
{
    m_invocationEffectiveTimeout = std::move(invocationEffectiveTimeout);
    return *this;
}

inline boost::optional<Duration>& SetMetricStateOperationDescriptorBuilder::invocationEffectiveTimeout()
{
    return m_invocationEffectiveTimeout;
}

inline const boost::optional<Duration>& SetMetricStateOperationDescriptorBuilder::invocationEffectiveTimeout() const
{
    return m_invocationEffectiveTimeout;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::retriggerable(Retriggerable retriggerable)
{
    m_retriggerable = retriggerable;
    return *this;
}

inline Retriggerable& SetMetricStateOperationDescriptorBuilder::retriggerable()
{
    return m_retriggerable;
}

inline Retriggerable SetMetricStateOperationDescriptorBuilder::retriggerable() const
{
    return m_retriggerable;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::accessLevel(AccessLevel accessLevel)
{
    m_accessLevel = accessLevel;
    return *this;
}

inline AccessLevel& SetMetricStateOperationDescriptorBuilder::accessLevel()
{
    return m_accessLevel;
}

inline AccessLevel SetMetricStateOperationDescriptorBuilder::accessLevel() const
{
    return m_accessLevel;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::modifiableData(const XPathExpressions& modifiableData)
{
    m_modifiableData = modifiableData;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::modifiableData(XPathExpressions&& modifiableData)
{
    m_modifiableData = std::move(modifiableData);
    return *this;
}

inline XPathExpressions& SetMetricStateOperationDescriptorBuilder::modifiableData()
{
    return m_modifiableData;
}

inline const XPathExpressions& SetMetricStateOperationDescriptorBuilder::modifiableData() const
{
    return m_modifiableData;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::extensions(const ExtensionTypes& extensions)
{
    m_extensions = extensions;
    return *this;
}

inline SetMetricStateOperationDescriptorBuilder& SetMetricStateOperationDescriptorBuilder::extensions(ExtensionTypes&& extensions)
{
    m_extensions = std::move(extensions);
    return *this;
}

inline ExtensionTypes& SetMetricStateOperationDescriptorBuilder::extensions()
{
    return m_extensions;
}

inline const ExtensionTypes& SetMetricStateOperationDescriptorBuilder::extensions() const
{
    return m_extensions;
}

inline bool operator==(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptorBuilder& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const SetMetricStateOperationDescriptor& lhs, const SetMetricStateOperationDescriptorBuilder& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const SetMetricStateOperationDescriptorBuilder& lhs, const SetMetricStateOperationDescriptor& rhs)
{
    return !(lhs == rhs);
}

inline SetMetricStateOperationDescriptorBuilder getBuilder(const SetMetricStateOperationDescriptor& setMetricStateOperationDescriptor)
{
    return SetMetricStateOperationDescriptorBuilder(setMetricStateOperationDescriptor);
}

inline SetMetricStateOperationDescriptorBuilder getBuilder(const DFL::NotNull<SharedPtr<SetMetricStateOperationDescriptor>>& setMetricStateOperationDescriptor)
{
    return SetMetricStateOperationDescriptorBuilder(setMetricStateOperationDescriptor);
}

}
}
